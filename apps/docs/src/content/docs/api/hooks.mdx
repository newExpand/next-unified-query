---
title: React Hooks API
description: Complete API reference for useQuery, useMutation, and useQueryClient hooks
---

import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Badge } from '@/components/ui/badge';

# React Hooks API

next-unified-query provides powerful React hooks for data fetching and state management.

## useQuery

The primary hook for fetching and caching data.

### Signature

```typescript
function useQuery<T = unknown>(
  options: QueryOptions<T> | QueryFactory<T>,
  queryOptions?: Partial<QueryOptions<T>>
): QueryResult<T>
```

### Parameters

#### options

Can be either a `QueryOptions` object or a `QueryFactory` function.

```typescript
interface QueryOptions<T> {
  // Required
  cacheKey: QueryKey
  
  // One of these is required
  url?: string
  queryFn?: (fetcher: QueryFetcher) => Promise<T>
  
  // Optional
  schema?: ZodSchema<T>
  enabled?: boolean
  staleTime?: number
  gcTime?: number
  refetchInterval?: number | false
  refetchIntervalInBackground?: boolean
  refetchOnMount?: boolean | 'always'
  refetchOnWindowFocus?: boolean | 'always'
  refetchOnReconnect?: boolean | 'always'
  retry?: boolean | number | RetryFunction
  retryDelay?: number | RetryDelayFunction
  select?: (data: T) => unknown
  suspense?: boolean
  keepPreviousData?: boolean
  placeholderData?: T | (() => T)
  structuralSharing?: boolean | ((oldData: T | undefined, newData: T) => T)
  meta?: Record<string, unknown>
  
  // Callbacks
  onSuccess?: (data: T) => void
  onError?: (error: FetchError) => void
  onSettled?: (data: T | undefined, error: FetchError | null) => void
}
```

### Return Value

```typescript
interface QueryResult<T> {
  // Data
  data: T | undefined
  error: FetchError | null
  
  // Status booleans
  isLoading: boolean    // First load without data
  isFetching: boolean   // Any fetch in progress
  isSuccess: boolean    // Query succeeded with data
  isError: boolean      // Query failed with error
  isPending: boolean    // No data yet (loading or idle)
  isStale: boolean      // Data is stale
  isPlaceholderData: boolean  // Showing placeholder data
  
  // Status
  status: 'pending' | 'error' | 'success'
  fetchStatus: 'fetching' | 'paused' | 'idle'
  
  // Actions
  refetch: (options?: RefetchOptions) => Promise<QueryResult<T>>
  remove: () => void
  
  // Metadata
  dataUpdatedAt: number
  errorUpdatedAt: number
  failureCount: number
  failureReason: FetchError | null
}
```

### Basic Examples

<Tabs defaultValue="basic" className="w-full">
  <TabsList>
    <TabsTrigger value="basic">Basic</TabsTrigger>
    <TabsTrigger value="schema">With Schema</TabsTrigger>
    <TabsTrigger value="factory">With Factory</TabsTrigger>
    <TabsTrigger value="custom">Custom Function</TabsTrigger>
  </TabsList>
  <TabsContent value="basic">
    ```tsx
    function UserProfile({ userId }: { userId: string }) {
      const { data, isLoading, error } = useQuery({
        cacheKey: ['user', userId],
        url: `/api/users/${userId}`,
      });

      if (isLoading) return <div>Loading...</div>;
      if (error) return <div>Error: {error.message}</div>;
      
      return <div>Hello, {data.name}!</div>;
    }
    ```
  </TabsContent>
  <TabsContent value="schema">
    ```tsx
    import { z } from '@my/next-unified-query/core';

    const userSchema = z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    });

    function UserProfile({ userId }: { userId: string }) {
      const { data, isLoading } = useQuery({
        cacheKey: ['user', userId],
        url: `/api/users/${userId}`,
        schema: userSchema,
      });

      // data is typed as { id: string; name: string; email: string }
      return data ? <div>{data.name}</div> : null;
    }
    ```
  </TabsContent>
  <TabsContent value="factory">
    ```tsx
    const userQueries = createQueryFactory({
      baseURL: '/api/users',
      defaultOptions: { staleTime: 1000 * 60 * 5 },
    });

    function UserProfile({ userId }: { userId: string }) {
      const { data } = useQuery(userQueries.get, {
        params: { id: userId },
      });

      return <div>{data?.name}</div>;
    }
    ```
  </TabsContent>
  <TabsContent value="custom">
    ```tsx
    function UserProfile({ userId }: { userId: string }) {
      const { data } = useQuery({
        cacheKey: ['user', userId],
        queryFn: async (fetcher) => {
          // Custom logic before fetch
          const token = await getAuthToken();
          
          // Use the fetcher (GET/HEAD only)
          const response = await fetcher.get(`/api/users/${userId}`, {
            headers: { Authorization: `Bearer ${token}` },
          });
          
          // Custom transformation
          return transformUserData(response.data);
        },
      });

      return <div>{data?.displayName}</div>;
    }
    ```
  </TabsContent>
</Tabs>

### Advanced Examples

#### Dependent Queries

```tsx
function UserPosts({ userId }: { userId: string }) {
  // First query
  const { data: user } = useQuery({
    cacheKey: ['user', userId],
    url: `/api/users/${userId}`,
  });

  // Dependent query - only runs when user is loaded
  const { data: posts } = useQuery({
    cacheKey: ['posts', userId],
    url: `/api/users/${userId}/posts`,
    enabled: !!user,
  });

  return (
    <div>
      <h1>{user?.name}'s Posts</h1>
      {posts?.map(post => <div key={post.id}>{post.title}</div>)}
    </div>
  );
}
```

#### Polling / Real-time Updates

```tsx
function LiveData() {
  const { data } = useQuery({
    cacheKey: ['live-data'],
    url: '/api/live-data',
    refetchInterval: 1000, // Poll every second
    refetchIntervalInBackground: true, // Continue when tab is inactive
  });

  return <div>Current value: {data?.value}</div>;
}
```

#### Select Transform

```tsx
function TodoStats() {
  const { data: completedCount } = useQuery({
    cacheKey: ['todos'],
    url: '/api/todos',
    select: (data) => data.filter(todo => todo.completed).length,
  });

  return <div>Completed: {completedCount ?? 0}</div>;
}
```

#### Suspense Mode

```tsx
function UserProfile({ userId }: { userId: string }) {
  const { data } = useQuery({
    cacheKey: ['user', userId],
    url: `/api/users/${userId}`,
    suspense: true, // Enable suspense
  });

  // data is guaranteed to be defined here
  return <div>{data.name}</div>;
}

// Parent component
function App() {
  return (
    <Suspense fallback={<Loading />}>
      <UserProfile userId="123" />
    </Suspense>
  );
}
```

## useMutation

Hook for performing data mutations (create, update, delete).

### Signature

```typescript
function useMutation<TData = unknown, TVariables = void, TError = FetchError>(
  options: MutationOptions<TData, TVariables, TError> | MutationFactory<TData, TVariables>
): MutationResult<TData, TVariables, TError>
```

### Parameters

```typescript
interface MutationOptions<TData, TVariables, TError> {
  // Required
  mutationFn: (variables: TVariables, fetcher: NextTypeFetch) => Promise<TData>
  
  // Optional
  mutationKey?: MutationKey
  retry?: boolean | number | RetryFunction
  retryDelay?: number | RetryDelayFunction
  gcTime?: number
  meta?: Record<string, unknown>
  
  // Callbacks
  onMutate?: (variables: TVariables) => Promise<any> | any
  onSuccess?: (data: TData, variables: TVariables, context: any) => Promise<any> | any
  onError?: (error: TError, variables: TVariables, context: any) => Promise<any> | any
  onSettled?: (data: TData | undefined, error: TError | null, variables: TVariables, context: any) => Promise<any> | any
}
```

### Return Value

```typescript
interface MutationResult<TData, TVariables, TError> {
  // Data
  data: TData | undefined
  error: TError | null
  variables: TVariables | undefined
  
  // Status
  isIdle: boolean
  isLoading: boolean
  isSuccess: boolean
  isError: boolean
  isPaused: boolean
  status: 'idle' | 'loading' | 'success' | 'error'
  
  // Actions
  mutate: (variables: TVariables, options?: MutateOptions) => void
  mutateAsync: (variables: TVariables, options?: MutateOptions) => Promise<TData>
  reset: () => void
  
  // Metadata
  submittedAt: number
  failureCount: number
  failureReason: TError | null
}
```

### Examples

<Tabs defaultValue="basic" className="w-full">
  <TabsList>
    <TabsTrigger value="basic">Basic</TabsTrigger>
    <TabsTrigger value="factory">With Factory</TabsTrigger>
    <TabsTrigger value="optimistic">Optimistic Update</TabsTrigger>
    <TabsTrigger value="async">Async/Await</TabsTrigger>
  </TabsList>
  <TabsContent value="basic">
    ```tsx
    function CreateUser() {
      const createUser = useMutation({
        mutationFn: async (userData, fetcher) => {
          return fetcher.post('/api/users', userData);
        },
        onSuccess: (data) => {
          console.log('User created:', data);
          queryClient.invalidateQueries({ cacheKey: ['users'] });
        },
        onError: (error) => {
          console.error('Failed to create user:', error);
        },
      });

      const handleSubmit = (formData) => {
        createUser.mutate(formData);
      };

      return (
        <form onSubmit={handleSubmit}>
          <button 
            type="submit" 
            disabled={createUser.isLoading}
          >
            {createUser.isLoading ? 'Creating...' : 'Create User'}
          </button>
          {createUser.error && (
            <div>Error: {createUser.error.message}</div>
          )}
        </form>
      );
    }
    ```
  </TabsContent>
  <TabsContent value="factory">
    ```tsx
    const userMutations = createMutationFactory({
      baseURL: '/api/users',
    });

    function UpdateUser({ userId }: { userId: string }) {
      const updateUser = useMutation(userMutations.put, {
        onSuccess: () => {
          queryClient.invalidateQueries({ cacheKey: ['user', userId] });
        },
      });

      const handleUpdate = (data) => {
        updateUser.mutate({ id: userId, ...data });
      };

      return <UserForm onSubmit={handleUpdate} />;
    }
    ```
  </TabsContent>
  <TabsContent value="optimistic">
    ```tsx
    function UpdateTodo({ todo }: { todo: Todo }) {
      const queryClient = useQueryClient();
      
      const updateTodo = useMutation({
        mutationFn: (updates, fetcher) => 
          fetcher.patch(`/api/todos/${todo.id}`, updates),
        
        onMutate: async (updates) => {
          // Cancel in-flight queries
          await queryClient.cancelQueries(['todo', todo.id]);
          
          // Snapshot previous value
          const previousTodo = queryClient.getQueryData(['todo', todo.id]);
          
          // Optimistically update
          queryClient.setQueryData(['todo', todo.id], {
            ...todo,
            ...updates,
          });
          
          return { previousTodo };
        },
        
        onError: (err, updates, context) => {
          // Rollback on error
          queryClient.setQueryData(
            ['todo', todo.id],
            context.previousTodo
          );
        },
        
        onSettled: () => {
          // Always refetch
          queryClient.invalidateQueries(['todo', todo.id]);
        },
      });

      return (
        <button onClick={() => updateTodo.mutate({ completed: true })}>
          Complete
        </button>
      );
    }
    ```
  </TabsContent>
  <TabsContent value="async">
    ```tsx
    function DeleteUser({ userId }: { userId: string }) {
      const deleteUser = useMutation({
        mutationFn: (_, fetcher) => 
          fetcher.delete(`/api/users/${userId}`),
      });

      const handleDelete = async () => {
        try {
          // mutateAsync returns a promise
          await deleteUser.mutateAsync();
          
          // Success - navigate away
          router.push('/users');
        } catch (error) {
          // Error handled
          console.error('Delete failed:', error);
        }
      };

      return (
        <button onClick={handleDelete}>
          Delete User
        </button>
      );
    }
    ```
  </TabsContent>
</Tabs>

## useQueryClient

Hook to access the QueryClient instance.

### Signature

```typescript
function useQueryClient(): QueryClient
```

### Examples

```tsx
function UserActions({ userId }: { userId: string }) {
  const queryClient = useQueryClient();

  const invalidateUser = () => {
    queryClient.invalidateQueries({ cacheKey: ['user', userId] });
  };

  const prefetchUserPosts = () => {
    queryClient.prefetchQuery({
      cacheKey: ['posts', userId],
      url: `/api/users/${userId}/posts`,
    });
  };

  const updateUserCache = (updates: Partial<User>) => {
    queryClient.setQueryData(['user', userId], (old) => {
      if (!old) return old;
      return { ...old, ...updates };
    });
  };

  return (
    <div>
      <button onClick={invalidateUser}>Refresh</button>
      <button onClick={prefetchUserPosts}>Load Posts</button>
      <button onClick={() => updateUserCache({ name: 'New Name' })}>
        Update Name
      </button>
    </div>
  );
}
```

## Type Safety

All hooks are fully type-safe with TypeScript:

```tsx
import { z } from '@my/next-unified-query/core';

// Define schemas
const userSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

const createUserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  password: z.string().min(8),
});

// Type-safe query
const { data } = useQuery({
  cacheKey: ['user', userId],
  url: `/api/users/${userId}`,
  schema: userSchema,
});
// data is typed as { id: string; name: string; email: string } | undefined

// Type-safe mutation
const createUser = useMutation<
  z.infer<typeof userSchema>,    // Return type
  z.infer<typeof createUserSchema> // Variables type
>({
  mutationFn: async (userData, fetcher) => {
    const validated = createUserSchema.parse(userData);
    const response = await fetcher.post('/api/users', validated);
    return userSchema.parse(response.data);
  },
});

// Fully typed mutate call
createUser.mutate({
  name: 'John',
  email: 'john@example.com',
  password: 'securepass123',
});
```

## Best Practices

1. **Use factories for reusability**
   ```tsx
   const userQueries = createQueryFactory({
     baseURL: '/api/users',
     defaultOptions: { staleTime: 1000 * 60 * 5 },
   });
   
   // Reuse across components
   const { data } = useQuery(userQueries.get, { params: { id } });
   ```

2. **Handle loading and error states**
   ```tsx
   const { data, isLoading, error } = useQuery({ ... });
   
   if (isLoading) return <Skeleton />;
   if (error) return <ErrorBoundary error={error} />;
   return <Content data={data} />;
   ```

3. **Use mutation callbacks appropriately**
   ```tsx
   const mutation = useMutation({
     mutationFn: updateUser,
     onSuccess: () => {
       // UI updates, notifications
       toast.success('User updated');
     },
     onError: (error) => {
       // Error handling
       toast.error(error.message);
     },
     onSettled: () => {
       // Always runs - good for cleanup
       queryClient.invalidateQueries(['users']);
     },
   });
   ```

4. **Prefetch data for better UX**
   ```tsx
   const prefetchUser = (userId: string) => {
     queryClient.prefetchQuery({
       cacheKey: ['user', userId],
       url: `/api/users/${userId}`,
     });
   };
   
   return (
     <Link 
       href={`/users/${userId}`}
       onMouseEnter={() => prefetchUser(userId)}
     >
       View User
     </Link>
   );
   ```

## See Also

- [Core Hooks Guide](/docs/core-hooks) - Detailed usage guide
- [Factory Patterns](/docs/factory-patterns) - Creating reusable queries
- [QueryClient API](/docs/api/query-client) - QueryClient methods
- [Type Safety](/docs/type-safety/overview) - TypeScript integration