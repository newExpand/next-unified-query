---
title: Error Handling API
description: Complete API reference for error handling utilities
---

import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Badge } from '@/components/ui/badge';

# Error Handling API

next-unified-query provides comprehensive error handling utilities for managing HTTP errors, validation errors, and network issues.

## Error Types

### FetchError <Badge variant="secondary">Class</Badge>

The main error class for all HTTP-related errors.

```typescript
class FetchError extends Error {
  name: 'FetchError'
  message: string
  code?: ErrorCodeType
  request?: Request
  response?: Response
  config?: RequestConfig
  isAxiosError: true
  
  toJSON(): object
}
```

### Error Codes <Badge variant="secondary">Constants</Badge>

```typescript
const ErrorCode = {
  NETWORK: "ERR_NETWORK",                    // Network connectivity issues
  CANCELED: "ERR_CANCELED",                  // Request was canceled
  TIMEOUT: "ERR_TIMEOUT",                    // Request timeout
  BAD_RESPONSE: "ERR_BAD_RESPONSE",         // Invalid response format
  VALIDATION: "ERR_VALIDATION",              // Schema validation failed
  VALIDATION_UNKNOWN: "ERR_VALIDATION_UNKNOWN", // Unknown validation error
  UNKNOWN: "ERR_UNKNOWN"                     // Unknown error
} as const;

type ErrorCodeType = typeof ErrorCode[keyof typeof ErrorCode];
```

## Type Guards

### isFetchError

Checks if an error is a FetchError instance.

```typescript
function isFetchError(error: unknown): error is FetchError
```

```typescript
try {
  const data = await api.get('/users');
} catch (error) {
  if (isFetchError(error)) {
    console.log('HTTP Error:', error.response?.status);
    console.log('Error Code:', error.code);
  }
}
```

### isValidationError

Checks if an error is a validation error (schema validation failed).

```typescript
function isValidationError(error: unknown): boolean
```

```typescript
try {
  const data = await api.get('/users');
} catch (error) {
  if (isValidationError(error)) {
    const errors = getValidationErrors(error);
    console.log('Validation errors:', errors);
  }
}
```

### hasErrorCode

Checks if an error has a specific error code.

```typescript
function hasErrorCode(
  error: unknown, 
  code: ErrorCodeType
): boolean
```

```typescript
try {
  const data = await api.get('/users');
} catch (error) {
  if (hasErrorCode(error, ErrorCode.TIMEOUT)) {
    console.log('Request timed out');
  }
  if (hasErrorCode(error, ErrorCode.NETWORK)) {
    console.log('Network error');
  }
}
```

### hasStatus

Checks if a response has a specific HTTP status code.

```typescript
function hasStatus(
  response: unknown, 
  status: number
): boolean
```

```typescript
try {
  const data = await api.get('/users/123');
} catch (error) {
  if (isFetchError(error)) {
    if (hasStatus(error.response, 404)) {
      console.log('User not found');
    }
    if (hasStatus(error.response, 401)) {
      console.log('Unauthorized');
    }
  }
}
```

## Error Handlers

### handleFetchError

Handles errors based on error codes with type-safe handlers.

```typescript
function handleFetchError<T>(
  error: unknown,
  handlers: {
    [K in ErrorCodeType]?: (error: FetchError) => T;
  } & {
    default?: (error: unknown) => T;
  }
): T | null
```

<Tabs defaultValue="basic" className="w-full">
  <TabsList>
    <TabsTrigger value="basic">Basic Usage</TabsTrigger>
    <TabsTrigger value="comprehensive">Comprehensive</TabsTrigger>
  </TabsList>
  <TabsContent value="basic">
    ```typescript
    try {
      const data = await api.get('/users');
    } catch (error) {
      const message = handleFetchError(error, {
        [ErrorCode.NETWORK]: () => 'Please check your internet connection',
        [ErrorCode.TIMEOUT]: () => 'Request took too long, please try again',
        [ErrorCode.CANCELED]: () => 'Request was canceled',
        default: (err) => `Error: ${err.message}`
      });
      
      if (message) {
        showNotification(message);
      }
    }
    ```
  </TabsContent>
  <TabsContent value="comprehensive">
    ```typescript
    function ErrorDisplay({ error }: { error: unknown }) {
      const errorContent = handleFetchError(error, {
        [ErrorCode.NETWORK]: (err) => (
          <div>
            <h3>Network Error</h3>
            <p>Unable to connect to the server</p>
            <button onClick={retry}>Retry</button>
          </div>
        ),
        [ErrorCode.TIMEOUT]: (err) => (
          <div>
            <h3>Timeout</h3>
            <p>The request took too long</p>
            <p>URL: {err.config?.url}</p>
          </div>
        ),
        [ErrorCode.VALIDATION]: (err) => {
          const errors = getValidationErrors(err);
          return (
            <div>
              <h3>Validation Error</h3>
              <ul>
                {errors.map((e, i) => (
                  <li key={i}>{e.path.join('.')}: {e.message}</li>
                ))}
              </ul>
            </div>
          );
        },
        default: (err) => (
          <div>
            <h3>Unexpected Error</h3>
            <p>{err.message}</p>
          </div>
        )
      });

      return errorContent || null;
    }
    ```
  </TabsContent>
</Tabs>

### handleHttpError

Handles errors based on HTTP status codes.

```typescript
function handleHttpError<T>(
  error: unknown,
  handlers: {
    [status: number]: (error: FetchError) => T;
    default?: (error: FetchError) => T;
  }
): T | null
```

<Tabs defaultValue="basic" className="w-full">
  <TabsList>
    <TabsTrigger value="basic">Basic Usage</TabsTrigger>
    <TabsTrigger value="advanced">Advanced</TabsTrigger>
  </TabsList>
  <TabsContent value="basic">
    ```typescript
    try {
      const data = await api.post('/users', userData);
    } catch (error) {
      const message = handleHttpError(error, {
        400: () => 'Invalid request data',
        401: () => 'Please log in to continue',
        403: () => 'You don\'t have permission',
        404: () => 'Resource not found',
        422: () => 'Validation failed',
        429: () => 'Too many requests, please try later',
        500: () => 'Server error, please try again',
        default: () => 'An unexpected error occurred'
      });
      
      if (message) {
        toast.error(message);
      }
    }
    ```
  </TabsContent>
  <TabsContent value="advanced">
    ```typescript
    const mutation = useMutation({
      mutationFn: updateUser,
      onError: (error) => {
        const action = handleHttpError(error, {
          401: (err) => {
            // Redirect to login
            router.push('/login');
            return 'redirect';
          },
          403: (err) => {
            // Show permission dialog
            showPermissionDialog();
            return 'dialog';
          },
          409: (err) => {
            // Conflict - data was modified
            queryClient.invalidateQueries(['user']);
            return 'refresh';
          },
          422: (err) => {
            // Validation error
            const errors = err.response?.data?.errors;
            setFormErrors(errors);
            return 'form';
          },
          default: (err) => {
            // Generic error
            console.error('Update failed:', err);
            return 'log';
          }
        });
        
        analytics.track('error_handled', { 
          action, 
          status: error.response?.status 
        });
      },
    });
    ```
  </TabsContent>
</Tabs>

## Error Utilities

### getValidationErrors

Extracts validation errors from a validation error.

```typescript
function getValidationErrors(
  error: unknown
): Array<{
  path: string[];
  message: string;
}>
```

```typescript
try {
  const user = await api.post('/users', {
    email: 'invalid-email',
    age: 'not-a-number'
  });
} catch (error) {
  if (isValidationError(error)) {
    const validationErrors = getValidationErrors(error);
    
    validationErrors.forEach(({ path, message }) => {
      // path: ['email'], message: 'Invalid email'
      // path: ['age'], message: 'Expected number, received string'
      console.log(`${path.join('.')}: ${message}`);
    });
  }
}
```

### createError

Creates a FetchError instance with custom properties.

```typescript
function createError(
  message: string,
  config?: RequestConfig,
  code?: ErrorCodeType,
  request?: Request,
  response?: Response
): FetchError
```

```typescript
// Create custom error
const error = createError(
  'Custom validation failed',
  { url: '/api/users', method: 'POST' },
  ErrorCode.VALIDATION,
  request,
  response
);

// Use in custom logic
if (customValidation.failed) {
  throw createError(
    'Business rule validation failed',
    config,
    ErrorCode.BAD_RESPONSE
  );
}
```

### errorToResponse

Converts an error to a NextTypeResponse format.

```typescript
function errorToResponse<T = any>(
  error: FetchError,
  data?: T
): NextTypeResponse<T>
```

```typescript
// Convert error to response format
const errorResponse = errorToResponse(error, {
  error: true,
  message: error.message,
  code: error.code
});

// Use in error recovery
async function fetchWithFallback(url: string) {
  try {
    return await api.get(url);
  } catch (error) {
    if (isFetchError(error) && hasStatus(error.response, 404)) {
      // Return error as response
      return errorToResponse(error, { fallback: true });
    }
    throw error;
  }
}
```

## Error Handling Patterns

### Global Error Handler

```typescript
import { createQueryClientWithInterceptors } from '@my/next-unified-query/core';

const queryClient = createQueryClientWithInterceptors({
  interceptors: {
    error: [
      (error) => {
        // Log all errors
        console.error('API Error:', error);
        
        // Handle auth errors globally
        if (hasStatus(error.response, 401)) {
          auth.logout();
          router.push('/login');
        }
        
        // Track errors
        if (window.analytics) {
          window.analytics.track('api_error', {
            url: error.config?.url,
            status: error.response?.status,
            code: error.code,
          });
        }
        
        throw error;
      }
    ]
  }
});
```

### Component Error Boundary

```tsx
function QueryErrorBoundary({ 
  children, 
  fallback 
}: { 
  children: React.ReactNode;
  fallback?: (error: unknown, reset: () => void) => React.ReactNode;
}) {
  const queryClient = useQueryClient();
  
  return (
    <ErrorBoundary
      fallback={(error, reset) => {
        const errorElement = handleFetchError(error, {
          [ErrorCode.NETWORK]: () => (
            <NetworkErrorFallback onRetry={reset} />
          ),
          [ErrorCode.TIMEOUT]: () => (
            <TimeoutErrorFallback onRetry={reset} />
          ),
          default: () => fallback?.(error, reset) || (
            <GenericErrorFallback error={error} onRetry={reset} />
          )
        });
        
        return errorElement || null;
      }}
      onReset={() => {
        queryClient.invalidateQueries();
      }}
    >
      {children}
    </ErrorBoundary>
  );
}
```

### Retry Logic

```typescript
const { data, error, refetch } = useQuery({
  cacheKey: ['critical-data'],
  url: '/api/critical',
  retry: (failureCount, error) => {
    // Custom retry logic
    if (hasErrorCode(error, ErrorCode.NETWORK)) {
      return failureCount < 5; // Retry network errors up to 5 times
    }
    if (hasStatus(error.response, 500)) {
      return failureCount < 3; // Retry server errors up to 3 times
    }
    return false; // Don't retry other errors
  },
  retryDelay: (attemptIndex, error) => {
    if (hasStatus(error.response, 429)) {
      // Rate limited - use retry-after header
      const retryAfter = error.response?.headers?.['retry-after'];
      return retryAfter ? parseInt(retryAfter) * 1000 : 60000;
    }
    // Exponential backoff
    return Math.min(1000 * 2 ** attemptIndex, 30000);
  },
});
```

## Type Safety

All error handling utilities are fully type-safe:

```typescript
// Type-safe error handling in mutations
const updateUser = useMutation<User, UpdateUserData, FetchError>({
  mutationFn: async (data, fetcher) => {
    return fetcher.patch(`/api/users/${data.id}`, data);
  },
  onError: (error: FetchError) => {
    // error is typed as FetchError
    if (error.response?.status === 422) {
      const validationErrors = error.response.data as ValidationErrorResponse;
      // Handle validation errors
    }
  },
});

// Type-safe error handlers
type ErrorMessage = string | { title: string; description: string };

const message = handleFetchError<ErrorMessage>(error, {
  [ErrorCode.NETWORK]: () => ({
    title: 'Connection Error',
    description: 'Please check your internet connection'
  }),
  [ErrorCode.TIMEOUT]: () => 'Request timed out',
  default: () => 'An error occurred'
});
```

## Best Practices

1. **Use type guards for safety**
   ```typescript
   if (isFetchError(error)) {
     // Safely access FetchError properties
   }
   ```

2. **Handle specific error codes**
   ```typescript
   handleFetchError(error, {
     [ErrorCode.NETWORK]: handleNetworkError,
     [ErrorCode.TIMEOUT]: handleTimeoutError,
     // ...
   });
   ```

3. **Provide user-friendly messages**
   ```typescript
   const userMessage = handleHttpError(error, {
     404: () => 'The requested item was not found',
     500: () => 'Something went wrong on our end',
     // ...
   });
   ```

4. **Log errors for debugging**
   ```typescript
   onError: (error) => {
     console.error('Query failed:', {
       url: error.config?.url,
       status: error.response?.status,
       message: error.message,
     });
   }
   ```

## See Also

- [Troubleshooting Guide](/docs/troubleshooting) - Common error scenarios
- [Interceptors](/docs/advanced-features#interceptors) - Global error handling
- [Type Safety](/docs/type-safety/overview) - Type-safe error handling