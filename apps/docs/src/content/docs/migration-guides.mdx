---
title: Migration Guides
description: 다른 라이브러리에서 마이그레이션
---

import { Callout, Card, Cards, Code, Pre, Tabs } from '@/components/ui';

# Migration Guides

다른 데이터 페칭 라이브러리에서 `next-unified-query`로 마이그레이션하는 방법을 안내합니다.

## axios에서 마이그레이션

### 기본 요청 변환

#### axios 코드:
```typescript
// axios
import axios from 'axios';

const api = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// GET 요청
const getUser = async (id: string) => {
  const { data } = await api.get(`/users/${id}`);
  return data;
};

// POST 요청
const createUser = async (userData: CreateUserInput) => {
  const { data } = await api.post('/users', userData);
  return data;
};
```

#### next-unified-query 코드:
```typescript
// next-unified-query
import { NextTypeFetch, useQuery, useMutation } from 'next-unified-query';

const fetcher = new NextTypeFetch({
  baseURL: 'https://api.example.com',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// GET 요청 (React Hook)
const useUser = (id: string) => {
  return useQuery({
    cacheKey: ['user', id],
    url: `/users/${id}`,
    fetcher
  });
};

// POST 요청 (React Hook)
const useCreateUser = () => {
  return useMutation({
    mutationFn: async (userData: CreateUserInput) => {
      const response = await fetcher.post('/users', userData);
      return response.data;
    }
  });
};
```

### Interceptor 변환

#### axios interceptors:
```typescript
// axios
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

api.interceptors.response.use(
  (response) => {
    return response;
  },
  async (error) => {
    if (error.response?.status === 401) {
      await refreshToken();
      return api.request(error.config);
    }
    return Promise.reject(error);
  }
);
```

#### next-unified-query interceptors:
```typescript
// next-unified-query
const fetcher = new NextTypeFetch({
  baseURL: 'https://api.example.com',
  interceptors: {
    request: async (config) => {
      const token = localStorage.getItem('token');
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    },
    response: async (response, config, retryCount) => {
      if (response.status === 401 && retryCount === 0) {
        await refreshToken();
        // 자동으로 재시도됨
        return fetch(config.url!, config);
      }
      return response;
    }
  }
});
```

### 에러 처리 변환

#### axios 에러 처리:
```typescript
// axios
try {
  const { data } = await api.get('/users');
  return data;
} catch (error) {
  if (axios.isAxiosError(error)) {
    if (error.response?.status === 404) {
      console.error('Not found');
    } else if (error.response?.status === 500) {
      console.error('Server error');
    }
  }
  throw error;
}
```

#### next-unified-query 에러 처리:
```typescript
// next-unified-query
const { data, error, isError } = useQuery({
  cacheKey: ['users'],
  url: '/users',
  fetcher
});

if (isError) {
  if (error.status === 404) {
    return <div>사용자를 찾을 수 없습니다</div>;
  } else if (error.status === 500) {
    return <div>서버 오류가 발생했습니다</div>;
  }
}
```

### 취소 토큰 변환

#### axios 취소:
```typescript
// axios
const source = axios.CancelToken.source();

api.get('/users', {
  cancelToken: source.token
}).catch((error) => {
  if (axios.isCancel(error)) {
    console.log('Request canceled');
  }
});

// 요청 취소
source.cancel('Operation canceled by the user.');
```

#### next-unified-query 취소:
```typescript
// next-unified-query
const { data, refetch } = useQuery({
  cacheKey: ['users'],
  url: '/users',
  fetcher
});

// React Query가 자동으로 이전 요청을 취소하고 새 요청을 시작
refetch();

// 컴포넌트 언마운트 시 자동 취소
```

### 마이그레이션 체크리스트

<Callout type="info">
  **단계별 마이그레이션**
  
  1. ✅ axios 인스턴스를 NextTypeFetch로 교체
  2. ✅ Interceptor 로직 변환
  3. ✅ API 호출을 React Query 훅으로 변환
  4. ✅ 에러 처리 패턴 업데이트
  5. ✅ 타입 정의 업데이트
</Callout>

## fetch API에서 마이그레이션

### 기본 fetch 변환

#### 네이티브 fetch:
```typescript
// fetch API
async function getUser(id: string) {
  try {
    const response = await fetch(`https://api.example.com/users/${id}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
}
```

#### next-unified-query:
```typescript
// next-unified-query
const useUser = (id: string) => {
  return useQuery({
    cacheKey: ['user', id],
    url: `/users/${id}`,
    schema: UserSchema, // Zod 스키마로 자동 검증
    fetcher: new NextTypeFetch({
      baseURL: 'https://api.example.com',
      interceptors: {
        request: async (config) => {
          config.headers.Authorization = `Bearer ${token}`;
          return config;
        }
      }
    })
  });
};
```

### 재시도 로직 변환

#### fetch with retry:
```typescript
// fetch API with manual retry
async function fetchWithRetry(url: string, options: RequestInit, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.ok) return response;
      
      if (i === retries - 1) throw new Error('Max retries reached');
      
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
    } catch (error) {
      if (i === retries - 1) throw error;
    }
  }
}
```

#### next-unified-query with retry:
```typescript
// next-unified-query - 자동 재시도
const { data } = useQuery({
  cacheKey: ['data'],
  url: '/api/data',
  retry: 3,
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000)
});
```

### 캐싱 구현 변환

#### Manual caching:
```typescript
// fetch API with manual cache
const cache = new Map();

async function getCachedData(key: string) {
  if (cache.has(key)) {
    const { data, timestamp } = cache.get(key);
    if (Date.now() - timestamp < 5 * 60 * 1000) { // 5분
      return data;
    }
  }
  
  const response = await fetch(`/api/data/${key}`);
  const data = await response.json();
  
  cache.set(key, { data, timestamp: Date.now() });
  return data;
}
```

#### next-unified-query caching:
```typescript
// next-unified-query - 자동 캐싱
const { data } = useQuery({
  cacheKey: ['data', key],
  url: `/api/data/${key}`,
  staleTime: 5 * 60 * 1000, // 5분
  cacheTime: 10 * 60 * 1000 // 10분
});
```

### SSR 지원 변환

#### Next.js with fetch:
```typescript
// pages/users/[id].tsx
export async function getServerSideProps({ params }) {
  const response = await fetch(`https://api.example.com/users/${params.id}`);
  const user = await response.json();
  
  return {
    props: { user }
  };
}

function UserPage({ user }) {
  return <div>{user.name}</div>;
}
```

#### next-unified-query SSR:
```typescript
// app/users/[id]/page.tsx
import { ssrPrefetch } from 'next-unified-query';

export default async function UserPage({ params }) {
  const { id } = params;
  
  // SSR 프리페치
  const prefetchedData = await ssrPrefetch({
    cacheKey: ['user', id],
    url: `/users/${id}`,
    schema: UserSchema
  });
  
  return (
    <HydrationBoundary state={prefetchedData}>
      <UserProfile userId={id} />
    </HydrationBoundary>
  );
}

// 클라이언트 컴포넌트
function UserProfile({ userId }: { userId: string }) {
  const { data: user } = useQuery({
    cacheKey: ['user', userId],
    url: `/users/${userId}`,
    schema: UserSchema
  });
  
  return <div>{user.name}</div>;
}
```

## TanStack Query에서 마이그레이션

### 기본 쿼리 변환

#### TanStack Query:
```typescript
// TanStack Query
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

const useUser = (userId: string) => {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: async () => {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error('Failed to fetch');
      return response.json();
    },
    staleTime: 5 * 60 * 1000
  });
};
```

#### next-unified-query:
```typescript
// next-unified-query
import { useQuery } from 'next-unified-query';

const useUser = (userId: string) => {
  return useQuery({
    cacheKey: ['user', userId], // queryKey → cacheKey
    url: `/api/users/${userId}`, // URL 기반 페칭
    schema: UserSchema, // Zod 스키마 검증 추가
    staleTime: 5 * 60 * 1000
  });
};
```

### Mutation 변환

#### TanStack Query mutation:
```typescript
// TanStack Query
const useUpdateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ id, data }: UpdateUserParams) => {
      const response = await fetch(`/api/users/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      return response.json();
    },
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({ queryKey: ['user', variables.id] });
      queryClient.setQueryData(['user', variables.id], data);
    }
  });
};
```

#### next-unified-query mutation:
```typescript
// next-unified-query
const useUpdateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ id, data }: UpdateUserParams) => {
      const fetcher = new NextTypeFetch();
      const response = await fetcher.put(`/api/users/${id}`, data);
      return response.data;
    },
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({ queryKey: ['user', variables.id] });
      queryClient.setQueryData(['user', variables.id], data);
    }
  });
};
```

### 무한 쿼리 변환

#### TanStack Query infinite:
```typescript
// TanStack Query
const usePosts = () => {
  return useInfiniteQuery({
    queryKey: ['posts'],
    queryFn: async ({ pageParam = 0 }) => {
      const response = await fetch(`/api/posts?page=${pageParam}`);
      return response.json();
    },
    getNextPageParam: (lastPage, pages) => lastPage.nextPage,
    initialPageParam: 0
  });
};
```

#### next-unified-query infinite:
```typescript
// next-unified-query
const usePosts = () => {
  return useInfiniteQuery({
    queryKey: ['posts'],
    queryFn: async ({ pageParam = 0 }) => {
      const fetcher = new NextTypeFetch();
      const response = await fetcher.get(`/api/posts?page=${pageParam}`);
      return response.data;
    },
    getNextPageParam: (lastPage, pages) => lastPage.nextPage,
    initialPageParam: 0
  });
};
```

### Provider 설정 변환

#### TanStack Query Provider:
```typescript
// TanStack Query
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000,
      gcTime: 5 * 60 * 1000
    }
  }
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Component />
    </QueryClientProvider>
  );
}
```

#### next-unified-query Provider:
```typescript
// next-unified-query
import { QueryClient, NextUnifiedQueryProvider } from 'next-unified-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000,
      cacheTime: 5 * 60 * 1000 // gcTime → cacheTime
    }
  }
});

function App() {
  return (
    <NextUnifiedQueryProvider client={queryClient}>
      <Component />
    </NextUnifiedQueryProvider>
  );
}
```

### 주요 차이점 요약

<Cards>
  <Card title="API 차이점">
    - `queryKey` → `cacheKey`
    - `gcTime` → `cacheTime`
    - URL 기반 페칭 내장
    - Zod 스키마 검증 내장
  </Card>
  
  <Card title="새로운 기능">
    - Factory 패턴 지원
    - TypeScript 타입 추론 강화
    - 내장된 HTTP 메서드
    - 인터셉터 시스템
  </Card>
</Cards>

## 마이그레이션 도구

### 자동 마이그레이션 스크립트

```bash
# 설치
npm install -D @next-unified-query/migration-tool

# axios 마이그레이션 실행
npx next-unified-query-migrate from-axios

# TanStack Query 마이그레이션 실행
npx next-unified-query-migrate from-tanstack

# 특정 파일만 마이그레이션
npx next-unified-query-migrate from-axios --files="src/**/*.ts"
```

### 수동 마이그레이션 도우미

```typescript
// migration-helpers.ts
import { QueryKey } from 'next-unified-query';

// TanStack Query key를 next-unified-query key로 변환
export function migrateQueryKey(tanstackKey: unknown[]): QueryKey {
  return tanstackKey as QueryKey;
}

// axios config를 NextTypeFetch config로 변환
export function migrateAxiosConfig(axiosConfig: AxiosRequestConfig): NextTypeFetchConfig {
  return {
    baseURL: axiosConfig.baseURL,
    timeout: axiosConfig.timeout,
    headers: axiosConfig.headers as Record<string, string>,
    // 추가 변환 로직
  };
}
```

## 점진적 마이그레이션 전략

### 1단계: 공존 설정

```typescript
// 기존 코드와 새 코드를 함께 사용
import axios from 'axios';
import { NextTypeFetch } from 'next-unified-query';

// 기존 axios 인스턴스
const legacyApi = axios.create({ baseURL: '/api' });

// 새 fetcher 인스턴스
const newFetcher = new NextTypeFetch({ baseURL: '/api' });

// 점진적으로 교체
export const api = {
  // 새로운 엔드포인트는 next-unified-query 사용
  users: {
    get: (id: string) => newFetcher.get(`/users/${id}`),
    create: (data: any) => newFetcher.post('/users', data)
  },
  // 기존 엔드포인트는 axios 유지
  legacy: {
    getData: () => legacyApi.get('/legacy/data')
  }
};
```

### 2단계: 컴포넌트별 마이그레이션

```typescript
// 기능별로 점진적 마이그레이션
// UserList.tsx - 마이그레이션 완료 ✅
function UserList() {
  const { data: users } = useQuery({
    cacheKey: ['users'],
    url: '/users',
    schema: z.array(UserSchema)
  });
  
  return <>{/* ... */}</>;
}

// LegacyDashboard.tsx - 아직 마이그레이션 안 됨 ⏳
function LegacyDashboard() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    axios.get('/api/dashboard').then(res => setData(res.data));
  }, []);
  
  return <>{/* ... */}</>;
}
```

### 3단계: 테스트 및 검증

```typescript
// 마이그레이션 테스트
describe('Migration Tests', () => {
  it('새 API가 기존 API와 동일한 결과를 반환하는지 확인', async () => {
    // 기존 방식
    const axiosResult = await axios.get('/api/users/1');
    
    // 새 방식
    const newResult = await fetcher.get('/users/1');
    
    expect(newResult.data).toEqual(axiosResult.data);
  });
});
```

## 문제 해결

### 일반적인 마이그레이션 이슈

#### 1. 타입 불일치
```typescript
// 문제: TanStack Query의 unknown 타입
const { data } = useQuery({ queryKey: ['user'], queryFn: getUser });
// data는 unknown 타입

// 해결: next-unified-query의 스키마 사용
const { data } = useQuery({
  cacheKey: ['user'],
  url: '/user',
  schema: UserSchema
});
// data는 User 타입으로 추론됨
```

#### 2. 캐시 키 구조 차이
```typescript
// 문제: 복잡한 캐시 키
const queryKey = ['users', { filters: { role: 'admin' }, page: 1 }];

// 해결: 일관된 구조 사용
const cacheKey = ['users', 'list', { role: 'admin', page: 1 }] as const;
```

#### 3. 에러 처리 패턴
```typescript
// axios 에러 체크
if (axios.isAxiosError(error)) {
  // ...
}

// next-unified-query 에러 체크
if (error instanceof Error) {
  if ('status' in error) {
    // HTTP 에러
  }
}
```

## 마이그레이션 체크리스트

<Callout type="success">
  **마이그레이션 완료 기준**
  
  - [ ] 모든 API 호출이 next-unified-query로 변환됨
  - [ ] 타입 안전성이 보장됨
  - [ ] 테스트가 모두 통과함
  - [ ] 성능이 개선되거나 최소한 동일함
  - [ ] 에러 처리가 일관성 있게 구현됨
  - [ ] 캐싱 전략이 최적화됨
</Callout>

## 관련 문서

- [Getting Started](/docs/getting-started) - 시작하기
- [Best Practices](/docs/best-practices) - 모범 사례
- [API Reference](/docs/api-reference) - API 레퍼런스
- [Examples](/docs/examples) - 실전 예제