---
title: Advanced Features
description: Master interceptors, auth retry patterns, Zod validation, caching strategies, and other advanced features
---

# Advanced Features

This guide covers advanced features of next-unified-query including interceptors, authentication retry patterns, Zod schema validation, caching strategies, and performance optimizations.

## Interceptors

Interceptors allow you to transform requests and responses, add authentication headers, handle errors globally, and implement cross-cutting concerns.

### Request Interceptors

Transform outgoing requests before they are sent:

```typescript
import { createQueryClient } from 'next-unified-query/core';

const queryClient = createQueryClient({
  defaultOptions: {
    fetcher: {
      interceptors: {
        request: {
          use: (config) => {
            // Add auth token
            const token = localStorage.getItem('authToken');
            if (token) {
              config.headers = {
                ...config.headers,
                Authorization: `Bearer ${token}`
              };
            }
            
            // Add custom headers
            config.headers = {
              ...config.headers,
              'X-App-Version': '1.0.0',
              'X-Request-ID': crypto.randomUUID()
            };
            
            // Transform request data
            if (config.data && config.method === 'POST') {
              config.data = {
                ...config.data,
                timestamp: new Date().toISOString()
              };
            }
            
            return config;
          }
        }
      }
    }
  }
});
```

### Response Interceptors

Transform responses before they reach your application:

```typescript
queryClient.interceptors.response.use((response) => {
  // Log response for debugging
  console.log(`Response from ${response.config.url}:`, {
    status: response.status,
    duration: Date.now() - response.config._startTime
  });
  
  // Transform response data
  if (response.data && Array.isArray(response.data)) {
    // Add metadata to array responses
    return {
      ...response,
      data: {
        items: response.data,
        count: response.data.length,
        timestamp: new Date().toISOString()
      }
    };
  }
  
  // Extract nested data
  if (response.data?.result) {
    response.data = response.data.result;
  }
  
  return response;
});
```

### Error Interceptors

Handle errors globally and transform error responses:

```typescript
queryClient.interceptors.error.use(async (error) => {
  // Log errors
  console.error('API Error:', {
    url: error.config?.url,
    status: error.response?.status,
    message: error.message
  });
  
  // Transform error format
  if (error.response?.data) {
    error.message = error.response.data.message || 
                   error.response.data.error || 
                   'An error occurred';
  }
  
  // Handle specific error codes
  if (error.response?.status === 404) {
    // Transform to a successful empty response
    return {
      data: null,
      status: 200,
      statusText: 'OK',
      headers: error.response.headers,
      config: error.config,
      request: error.request
    };
  }
  
  // Re-throw for other errors
  throw error;
});
```

### Advanced Interceptor Management

Use unique symbols to manage and replace interceptors by type:

```typescript
// Create typed interceptor symbols
const AUTH_INTERCEPTOR = Symbol('auth');
const LOGGING_INTERCEPTOR = Symbol('logging');
const RETRY_INTERCEPTOR = Symbol('retry');

// Add interceptors with types
const authHandle = queryClient.interceptors.request.use(
  (config) => {
    // Auth logic
    return config;
  },
  AUTH_INTERCEPTOR
);

// Replace interceptor by type
queryClient.interceptors.request.clearByType(AUTH_INTERCEPTOR);
queryClient.interceptors.request.use(
  (config) => {
    // New auth logic
    return config;
  },
  AUTH_INTERCEPTOR
);

// Remove specific interceptor
authHandle.remove();

// Clear all interceptors
queryClient.interceptors.request.clear();
```

## Authentication Retry Pattern

Automatically retry failed requests after refreshing authentication tokens:

```typescript
import { createQueryClient, isFetchError } from 'next-unified-query/core';
import type { AuthRetryOption } from 'next-unified-query/core';

// Token refresh logic
let refreshPromise: Promise<boolean> | null = null;

async function refreshAuthToken(): Promise<boolean> {
  try {
    const response = await fetch('/api/auth/refresh', {
      method: 'POST',
      credentials: 'include'
    });
    
    if (response.ok) {
      const { accessToken } = await response.json();
      localStorage.setItem('authToken', accessToken);
      return true;
    }
    
    return false;
  } catch {
    return false;
  }
}

// Auth retry configuration
const authRetryConfig: AuthRetryOption = {
  limit: 1,
  statusCodes: [401],
  handler: async (error, config) => {
    // Prevent concurrent refresh attempts
    if (!refreshPromise) {
      refreshPromise = refreshAuthToken();
    }
    
    const success = await refreshPromise;
    refreshPromise = null;
    
    if (success) {
      // Update config with new token
      const newToken = localStorage.getItem('authToken');
      config.headers = {
        ...config.headers,
        Authorization: `Bearer ${newToken}`
      };
      return true; // Retry the request
    }
    
    // Redirect to login on refresh failure
    window.location.href = '/login';
    return false;
  },
  shouldRetry: (error, config) => {
    // Don't retry login/refresh endpoints
    const isAuthEndpoint = config.url?.includes('/auth/');
    return !isAuthEndpoint;
  }
};

// Apply to query client
const queryClient = createQueryClient({
  defaultOptions: {
    fetcher: {
      authRetry: authRetryConfig
    }
  }
});
```

### Using Auth Retry with Interceptors

Combine auth retry with interceptors for complete auth handling:

```typescript
// Add initial auth token
queryClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('authToken');
  if (token) {
    config.headers = {
      ...config.headers,
      Authorization: `Bearer ${token}`
    };
  }
  return config;
});

// Handle auth errors
queryClient.interceptors.error.use(async (error) => {
  if (error.response?.status === 401) {
    const refreshed = await refreshAuthToken();
    
    if (refreshed) {
      // Retry original request with new token
      const newToken = localStorage.getItem('authToken');
      error.config.headers = {
        ...error.config.headers,
        Authorization: `Bearer ${newToken}`
      };
      
      // Use the fetcher to retry
      return queryClient.request(error.config);
    }
  }
  
  throw error;
});
```

## Zod Schema Validation

Use Zod schemas for runtime type validation and automatic TypeScript type inference:

```typescript
import { z } from 'zod';
import { createQueryFactory, createMutationFactory } from 'next-unified-query/core';

// Define complex nested schema
const userSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email(),
  profile: z.object({
    bio: z.string().optional(),
    avatar: z.string().url().optional(),
    settings: z.object({
      notifications: z.boolean(),
      theme: z.enum(['light', 'dark', 'system'])
    })
  }),
  roles: z.array(z.enum(['user', 'admin', 'moderator'])),
  createdAt: z.string().datetime(),
  metadata: z.record(z.unknown()).optional()
});

// Type is automatically inferred
type User = z.infer<typeof userSchema>;

// Create factory with schema validation
const getUserFactory = createQueryFactory({
  queryFn: (id: number, fetcher) => 
    fetcher.get(`/api/users/${id}`),
  schema: userSchema
});

// Use in component
function UserProfile({ userId }: { userId: number }) {
  const { data, error } = useQuery(getUserFactory, {
    params: userId
  });
  
  if (error && isValidationError(error)) {
    const validationErrors = getValidationErrors(error);
    return (
      <div>
        <h3>Invalid data received:</h3>
        {validationErrors.map(({ path, message }) => (
          <p key={path}>{path}: {message}</p>
        ))}
      </div>
    );
  }
  
  // data is fully typed as User
  return <div>{data?.name}</div>;
}
```

### Schema Composition and Transformation

```typescript
// Base schemas
const baseUserSchema = z.object({
  id: z.number(),
  name: z.string()
});

const timestampSchema = z.object({
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime()
});

// Compose schemas
const fullUserSchema = baseUserSchema
  .merge(timestampSchema)
  .extend({
    email: z.string().email(),
    age: z.number().min(0).max(150)
  });

// Transform data during validation
const transformedUserSchema = fullUserSchema.transform((user) => ({
  ...user,
  // Convert timestamps to Date objects
  createdAt: new Date(user.createdAt),
  updatedAt: new Date(user.updatedAt),
  // Add computed properties
  isAdult: user.age >= 18
}));

// Request/Response validation
const createUserMutation = createMutationFactory({
  mutationFn: (data: unknown, fetcher) =>
    fetcher.post('/api/users', data),
  // Validate request data
  requestSchema: z.object({
    name: z.string().min(1),
    email: z.string().email(),
    password: z.string().min(8)
  }),
  // Validate response
  schema: fullUserSchema
});
```

## Structural Sharing

Optimize React re-renders by preserving object references when data hasn't changed:

```typescript
// Structural sharing is enabled by default
const { data } = useQuery({
  cacheKey: ['user', userId],
  url: `/api/users/${userId}`,
  // Disable if not needed
  structuralSharing: false
});

// Structural sharing works internally by comparing 
// previous and new data to preserve references when possible.
// This optimization reduces unnecessary React re-renders.
```

### Custom Structural Sharing

Implement custom comparison logic:

```typescript
const { data } = useQuery({
  cacheKey: ['items'],
  url: '/api/items',
  structuralSharing: (oldData, newData) => {
    // Custom comparison logic
    if (!oldData || !newData) return newData;
    
    // Only share structure if IDs match
    if (oldData.id === newData.id && 
        oldData.version === newData.version) {
      return oldData; // Keep old reference
    }
    
    return newData;
  }
});
```

## Advanced Caching Strategies

### Global Cache Configuration

Configure cache behavior at the global level:

```typescript
import { createQueryClient } from 'next-unified-query/core';

const queryClient = createQueryClient({
  defaultOptions: {
    queries: {
      // Data considered stale after 5 minutes
      staleTime: 5 * 60 * 1000,
      
      // Cache entries garbage collected after 10 minutes
      cacheTime: 10 * 60 * 1000,
      
      // Retry failed queries 3 times
      retry: 3,
      
      // Exponential backoff for retries
      retryDelay: (attemptIndex) => 
        Math.min(1000 * 2 ** attemptIndex, 30000),
      
      // Refetch when window regains focus
      refetchOnWindowFocus: true,
      
      // Refetch when reconnecting to network
      refetchOnReconnect: true,
      
      // Don't refetch on mount if data exists
      refetchOnMount: true
    }
  }
});
```

### Per-Query Cache Control

Override global settings for specific queries:

```typescript
// Never refetch automatically
const { data: staticData } = useQuery({
  cacheKey: ['static-content'],
  url: '/api/static',
  staleTime: Infinity,
  cacheTime: Infinity,
  refetchOnWindowFocus: false,
  refetchOnReconnect: false
});

// Always fresh data
const { data: liveData } = useQuery({
  cacheKey: ['live-data'],
  url: '/api/live',
  staleTime: 0, // Always stale
  refetchInterval: 1000 // Poll every second
});

// Background refetch
const { data: backgroundData } = useQuery({
  cacheKey: ['background'],
  url: '/api/data',
  staleTime: 60 * 1000, // Stale after 1 minute
  // Refetch in background when stale
  refetchOnMount: 'always',
  refetchOnWindowFocus: 'always'
});
```

### Cache Invalidation Patterns

```typescript
const queryClient = useQueryClient();

// Invalidate specific query
queryClient.invalidateQueries(['user', userId]);

// Invalidate by prefix
queryClient.invalidateQueries(['users']);

// Invalidate with predicate
queryClient.invalidateQueries({
  predicate: (query) => 
    query.cacheKey[0] === 'posts' && 
    query.state.dataUpdatedAt < Date.now() - 60000
});

// Remove from cache
queryClient.removeQueries(['old-data']);

// Reset to initial state
queryClient.resetQueries(['user']);

// Set query data directly
queryClient.setQueryData(['user', userId], newUserData);

// Update query data
queryClient.setQueryData(['user', userId], (oldData) => ({
  ...oldData,
  name: 'Updated Name'
}));
```

### Optimistic Updates

```typescript
const updateUser = useMutation({
  mutationFn: (data, fetcher) => 
    fetcher.put(`/api/users/${data.id}`, data),
  onMutate: async (newData) => {
    // Cancel in-flight queries
    await queryClient.cancelQueries(['user', newData.id]);
    
    // Snapshot previous value
    const previousUser = queryClient.getQueryData(['user', newData.id]);
    
    // Optimistically update
    queryClient.setQueryData(['user', newData.id], newData);
    
    // Return context for rollback
    return { previousUser };
  },
  onError: (err, newData, context) => {
    // Rollback on error
    queryClient.setQueryData(
      ['user', newData.id], 
      context.previousUser
    );
  },
  onSettled: (data, error, variables) => {
    // Refetch to ensure consistency
    queryClient.invalidateQueries(['user', variables.id]);
  }
});
```

## Performance Optimizations

### Memory Management

The library uses LRU (Least Recently Used) cache for memory efficiency:

```typescript
// Configure cache size
const queryClient = createQueryClient({
  defaultOptions: {
    queries: {
      // Maximum number of cache entries
      maxCacheSize: 100,
      
      // Custom cache implementation
      cache: new Map(), // or any Map-like interface
      
      // Garbage collection interval
      gcInterval: 5 * 60 * 1000 // 5 minutes
    }
  }
});

// Monitor cache size
const cache = queryClient.getQueryCache();
const stats = cache.getStats();
console.log('Cache size:', stats.cacheSize);
console.log('Active timers:', stats.activeGcTimersCount);
```

### Request Deduplication

Automatic deduplication prevents duplicate in-flight requests:

```typescript
// These will share the same network request
const query1 = useQuery({
  cacheKey: ['user', 1],
  url: '/api/users/1'
});

const query2 = useQuery({
  cacheKey: ['user', 1],
  url: '/api/users/1'
});

// Force separate request
const query3 = useQuery({
  cacheKey: ['user', 1, 'forced'],
  url: '/api/users/1',
  meta: {
    requestId: crypto.randomUUID()
  }
});
```

### Bundle Size Optimization

The library uses es-toolkit for smaller bundle size:

```typescript
// Optimized imports
import { debounce, throttle } from 'es-toolkit';

// Use with queries
const SearchComponent = () => {
  const [query, setQuery] = useState('');
  
  const debouncedSearch = useMemo(
    () => debounce((q: string) => {
      queryClient.invalidateQueries(['search', q]);
    }, 300),
    [queryClient]
  );
  
  useEffect(() => {
    debouncedSearch(query);
  }, [query, debouncedSearch]);
  
  const { data } = useQuery({
    cacheKey: ['search', query],
    url: '/api/search',
    params: { q: query },
    enabled: query.length > 2
  });
  
  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
    />
  );
};
```

## Network Modes

Configure how queries behave with network connectivity:

```typescript
// Online only (default)
const onlineQuery = useQuery({
  cacheKey: ['online-only'],
  url: '/api/data',
  networkMode: 'online'
});

// Offline first
const offlineQuery = useQuery({
  cacheKey: ['offline-first'],
  url: '/api/data',
  networkMode: 'offlineFirst'
});

// Always fetch regardless of network
const alwaysQuery = useQuery({
  cacheKey: ['always'],
  url: '/api/data',
  networkMode: 'always'
});

// Global network mode
const queryClient = createQueryClient({
  defaultOptions: {
    queries: {
      networkMode: 'offlineFirst'
    }
  }
});
```

## React Suspense Integration

Enable Suspense mode for queries:

```typescript
// Enable suspense for specific query
const { data } = useQuery({
  cacheKey: ['user', userId],
  url: `/api/users/${userId}`,
  suspense: true
});

// Global suspense configuration
const queryClient = createQueryClient({
  defaultOptions: {
    queries: {
      suspense: true
    }
  }
});

// Usage with Suspense boundary
function App() {
  return (
    <ErrorBoundary fallback={<ErrorFallback />}>
      <Suspense fallback={<Loading />}>
        <UserProfile userId={1} />
      </Suspense>
    </ErrorBoundary>
  );
}

function UserProfile({ userId }: { userId: number }) {
  // Will suspend while loading
  const { data } = useQuery({
    cacheKey: ['user', userId],
    url: `/api/users/${userId}`,
    suspense: true
  });
  
  // data is guaranteed to be defined here
  return <div>{data.name}</div>;
}
```

## Debugging Tools

### Query Inspector

```typescript
function QueryInspector() {
  const queryClient = useQueryClient();
  const [queries, setQueries] = useState([]);
  
  useEffect(() => {
    const interval = setInterval(() => {
      const cache = queryClient.getQueryCache();
      const allQueries = cache.getAll();
      
      setQueries(allQueries.map(query => ({
        key: query.cacheKey,
        status: query.state.status,
        dataUpdatedAt: query.state.dataUpdatedAt,
        errorUpdatedAt: query.state.errorUpdatedAt,
        isStale: query.isStale(),
        observerCount: query.getObserverCount()
      })));
    }, 1000);
    
    return () => clearInterval(interval);
  }, [queryClient]);
  
  return (
    <div>
      <h3>Active Queries</h3>
      {queries.map((query, i) => (
        <div key={i}>
          <strong>{JSON.stringify(query.key)}</strong>
          <pre>{JSON.stringify(query, null, 2)}</pre>
        </div>
      ))}
    </div>
  );
}
```

### Performance Monitoring

```typescript
// Add performance tracking
queryClient.interceptors.request.use((config) => {
  config._metrics = {
    startTime: performance.now()
  };
  return config;
});

queryClient.interceptors.response.use((response) => {
  const duration = performance.now() - response.config._metrics.startTime;
  
  // Log slow queries
  if (duration > 1000) {
    console.warn(`Slow query detected: ${response.config.url} took ${duration}ms`);
  }
  
  // Track metrics
  if (window.analytics) {
    window.analytics.track('api_request', {
      url: response.config.url,
      duration,
      status: response.status,
      cacheHit: response.config._fromCache || false
    });
  }
  
  return response;
});
```

## Best Practices

1. **Use Interceptors Wisely**: Keep interceptor logic simple and fast
2. **Configure Stale Time**: Set appropriate stale times based on data volatility
3. **Leverage TypeScript**: Use schema validation for type safety
4. **Optimize Bundle Size**: Import only what you need
5. **Monitor Performance**: Use debugging tools in development
6. **Handle Errors Gracefully**: Implement proper error boundaries
7. **Test Advanced Features**: Write tests for interceptors and retry logic

## Next Steps

- Explore [SSR Documentation](/docs/ssr) for server-side rendering patterns
- Read [Performance Optimization](/docs/performance) for more optimization techniques
- Check [Best Practices](/docs/best-practices) for recommended patterns