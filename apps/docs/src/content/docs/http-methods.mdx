---
title: HTTP Methods & Request API
description: Complete API reference for HTTP method functions - get, post, put, patch, delete, head, options
---

# HTTP Methods & Request API

next-unified-query provides type-safe HTTP method functions with built-in request/response handling, interceptors, and automatic content negotiation.

## Overview

The library enforces HTTP method safety at the type level:
- **QueryFetcher**: Only GET/HEAD methods for data fetching (used in useQuery)
- **NextTypeFetch**: All HTTP methods for mutations (used in useMutation)

This design prevents cache pollution and ensures proper separation of concerns.

## Core Types

### HTTP Method Type

```typescript
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD" | "OPTIONS";
```

### Request Configuration

```typescript
interface RequestConfig extends FetchConfig {
  url: string;
  method: HttpMethod;
  params?: Record<string, any>;     // URL parameters
  data?: any;                       // Request body
  headers?: Record<string, string>; // Request headers
  signal?: AbortSignal;             // Cancellation signal
  // ... other axios-compatible options
}

interface FetchConfig {
  baseURL?: string;
  timeout?: number;
  headers?: Record<string, string>;
  params?: Record<string, any>;
  data?: any;
  withCredentials?: boolean;
  responseType?: ResponseType;
  responseEncoding?: string;
  xsrfCookieName?: string;
  xsrfHeaderName?: string;
  maxContentLength?: number;
  maxBodyLength?: number;
  maxRedirects?: number;
  proxy?: ProxyConfig | false;
  decompress?: boolean;
  signal?: AbortSignal;
  schema?: ZodType;  // Response validation schema
}
```

### Response Types

```typescript
interface NextTypeResponse<T = any> {
  data: T;
  status: number;
  statusText: string;
  headers: Record<string, string>;
  config: RequestConfig;
  request?: any;
}

interface CancelablePromise<T> extends Promise<T> {
  cancel: (reason?: string) => void;
}
```

## HTTP Method Functions

### GET

Retrieve data from the server.

```typescript
function get<T = any>(
  url: string, 
  config?: FetchConfig
): CancelablePromise<NextTypeResponse<T>>
```

#### Usage Examples

```typescript
import { get } from 'next-unified-query/core';

// Simple GET request
const response = await get('/api/users');
console.log(response.data); // Array of users

// With query parameters
const filtered = await get('/api/users', {
  params: { role: 'admin', active: true }
});
// Requests: /api/users?role=admin&active=true

// With custom headers
const authenticated = await get('/api/profile', {
  headers: {
    'Authorization': 'Bearer token123'
  }
});

// With response schema validation
import { z } from 'zod';

const userSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email()
});

const user = await get<z.infer<typeof userSchema>>('/api/users/1', {
  schema: userSchema // Validates response data
});
```

### POST

Create new resources on the server.

```typescript
function post<T = any>(
  url: string, 
  data?: any,
  config?: FetchConfig
): CancelablePromise<NextTypeResponse<T>>
```

#### Usage Examples

```typescript
import { post } from 'next-unified-query/core';

// Create a new user
const response = await post('/api/users', {
  name: 'John Doe',
  email: 'john@example.com'
});

// File upload
const formData = new FormData();
formData.append('file', fileInput.files[0]);
formData.append('description', 'Profile photo');

const upload = await post('/api/upload', formData, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
});

// With request validation
const createUserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  role: z.enum(['user', 'admin'])
});

const newUser = await post('/api/users', 
  { name: 'Jane', email: 'jane@example.com', role: 'user' },
  { schema: createUserSchema }
);
```

### PUT

Replace entire resources on the server.

```typescript
function put<T = any>(
  url: string, 
  data?: any,
  config?: FetchConfig
): CancelablePromise<NextTypeResponse<T>>
```

#### Usage Examples

```typescript
import { put } from 'next-unified-query/core';

// Replace entire user object
const response = await put('/api/users/123', {
  id: 123,
  name: 'John Updated',
  email: 'john.updated@example.com',
  role: 'admin',
  active: true
});

// Bulk update
const bulkUpdate = await put('/api/users/bulk', {
  ids: [1, 2, 3],
  updates: { status: 'active' }
});
```

### PATCH

Partially update resources on the server.

```typescript
function patch<T = any>(
  url: string, 
  data?: any,
  config?: FetchConfig
): CancelablePromise<NextTypeResponse<T>>
```

#### Usage Examples

```typescript
import { patch } from 'next-unified-query/core';

// Update specific fields only
const response = await patch('/api/users/123', {
  email: 'newemail@example.com'
});

// Toggle boolean field
const toggleStatus = await patch('/api/posts/456', {
  published: true
});

// JSON Patch format (RFC 6902)
const jsonPatch = await patch('/api/users/123', [
  { op: 'replace', path: '/email', value: 'new@example.com' },
  { op: 'add', path: '/tags/0', value: 'vip' }
], {
  headers: {
    'Content-Type': 'application/json-patch+json'
  }
});
```

### DELETE

Remove resources from the server.

```typescript
function delete<T = any>(
  url: string, 
  config?: FetchConfig
): CancelablePromise<NextTypeResponse<T>>
```

#### Usage Examples

```typescript
import { del } from 'next-unified-query/core'; // Note: 'del' alias to avoid reserved word

// Delete a single resource
const response = await del('/api/users/123');

// Delete with confirmation
const deleteWithConfirm = await del('/api/posts/456', {
  headers: {
    'X-Confirm-Delete': 'true'
  }
});

// Bulk delete
const bulkDelete = await del('/api/users', {
  params: { ids: [1, 2, 3] }
});
```

### HEAD

Retrieve metadata about resources without the body.

```typescript
function head<T = any>(
  url: string, 
  config?: FetchConfig
): CancelablePromise<NextTypeResponse<T>>
```

#### Usage Examples

```typescript
import { head } from 'next-unified-query/core';

// Check if resource exists
try {
  const response = await head('/api/users/123');
  console.log('User exists:', response.status === 200);
} catch (error) {
  if (error.response?.status === 404) {
    console.log('User not found');
  }
}

// Get file metadata
const fileInfo = await head('/api/files/document.pdf');
console.log('File size:', fileInfo.headers['content-length']);
console.log('Last modified:', fileInfo.headers['last-modified']);
```

### OPTIONS

Retrieve allowed methods and CORS information.

```typescript
function options<T = any>(
  url: string, 
  config?: FetchConfig
): CancelablePromise<NextTypeResponse<T>>
```

#### Usage Examples

```typescript
import { options } from 'next-unified-query/core';

// Check allowed methods
const response = await options('/api/users');
console.log('Allowed methods:', response.headers['allow']);
// Output: "GET, POST, PUT, DELETE, OPTIONS"

// CORS preflight check
const cors = await options('/api/external', {
  headers: {
    'Origin': 'https://myapp.com',
    'Access-Control-Request-Method': 'POST'
  }
});
```

## Request Patterns

### RESTful API Patterns

```typescript
// Resource collection
const users = await get('/api/users');
const newUser = await post('/api/users', userData);

// Single resource
const user = await get('/api/users/123');
const updated = await put('/api/users/123', fullUserData);
const patched = await patch('/api/users/123', { name: 'New Name' });
const deleted = await del('/api/users/123');

// Nested resources
const posts = await get('/api/users/123/posts');
const newPost = await post('/api/users/123/posts', postData);

// Actions on resources
const published = await post('/api/posts/456/publish');
const archived = await post('/api/posts/456/archive');
```

### Authentication Patterns

```typescript
// Login
const session = await post('/api/auth/login', {
  username: 'user@example.com',
  password: 'password123'
});

// Authenticated requests
const profile = await get('/api/profile', {
  headers: {
    'Authorization': `Bearer ${session.data.token}`
  }
});

// Logout
await post('/api/auth/logout');
```

### File Operations

```typescript
// Upload single file
const formData = new FormData();
formData.append('file', file);

const uploaded = await post('/api/upload', formData);

// Upload multiple files
const multiForm = new FormData();
files.forEach((file, index) => {
  multiForm.append(`files[${index}]`, file);
});

const multiUploaded = await post('/api/upload/multiple', multiForm);

// Download file
const fileData = await get('/api/files/123/download', {
  responseType: 'blob'
});

// Create download link
const url = URL.createObjectURL(fileData.data);
const a = document.createElement('a');
a.href = url;
a.download = 'file.pdf';
a.click();
```

### Error Handling

```typescript
import { isFetchError, hasStatus } from 'next-unified-query/core';

try {
  const response = await post('/api/users', userData);
  console.log('User created:', response.data);
} catch (error) {
  if (isFetchError(error)) {
    if (hasStatus(error, 400)) {
      console.error('Validation error:', error.response?.data);
    } else if (hasStatus(error, 401)) {
      console.error('Unauthorized');
      // Redirect to login
    } else if (hasStatus(error, 409)) {
      console.error('Conflict: User already exists');
    } else if (hasStatus(error, 500)) {
      console.error('Server error');
    }
  } else {
    console.error('Network error:', error);
  }
}
```

### Request Cancellation

```typescript
// Create cancelable request
const request = get('/api/large-data');

// Cancel after 5 seconds
setTimeout(() => {
  request.cancel('Request took too long');
}, 5000);

try {
  const response = await request;
  console.log('Data received:', response.data);
} catch (error) {
  if (error.code === 'ERR_CANCELED') {
    console.log('Request was cancelled');
  }
}

// Using AbortController
const controller = new AbortController();

const request = get('/api/data', {
  signal: controller.signal
});

// Cancel when component unmounts
useEffect(() => {
  return () => controller.abort();
}, []);
```

## Content Types

### JSON (Default)

```typescript
// Automatically serialized/parsed
const response = await post('/api/data', {
  name: 'John',
  age: 30
});
// Content-Type: application/json
```

### Form Data

```typescript
// URL-encoded form
const response = await post('/api/form', 
  new URLSearchParams({
    name: 'John',
    email: 'john@example.com'
  }),
  {
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    }
  }
);

// Multipart form
const formData = new FormData();
formData.append('name', 'John');
formData.append('avatar', fileInput.files[0]);

const response = await post('/api/profile', formData);
// Content-Type: multipart/form-data (set automatically)
```

### Binary Data

```typescript
// Upload binary
const buffer = new ArrayBuffer(1024);
const response = await post('/api/binary', buffer, {
  headers: {
    'Content-Type': 'application/octet-stream'
  }
});

// Download binary
const download = await get('/api/file.pdf', {
  responseType: 'arraybuffer'
});
```

## Performance Tips

### 1. Use Appropriate Methods

```typescript
// ✅ Good: Use PATCH for partial updates
await patch('/api/users/123', { email: 'new@example.com' });

// ❌ Avoid: Using PUT for partial updates
await put('/api/users/123', { email: 'new@example.com' }); // Might delete other fields
```

### 2. Leverage HEAD for Existence Checks

```typescript
// ✅ Good: Check existence without downloading data
const exists = await head('/api/users/123')
  .then(() => true)
  .catch(() => false);

// ❌ Avoid: Downloading full data just to check existence
const exists = await get('/api/users/123')
  .then(() => true)
  .catch(() => false);
```

### 3. Cancel Unnecessary Requests

```typescript
function SearchComponent() {
  const [query, setQuery] = useState('');
  const controllerRef = useRef<AbortController>();

  const search = async (q: string) => {
    // Cancel previous search
    controllerRef.current?.abort();
    controllerRef.current = new AbortController();

    try {
      const response = await get('/api/search', {
        params: { q },
        signal: controllerRef.current.signal
      });
      // Handle results
    } catch (error) {
      if (error.code !== 'ERR_CANCELED') {
        // Handle real errors
      }
    }
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => controllerRef.current?.abort();
  }, []);
}
```

## Best Practices

1. **Use Semantic Methods**: Choose the HTTP method that best represents your intention
2. **Handle Errors Gracefully**: Always handle both network and HTTP errors
3. **Validate Responses**: Use Zod schemas to ensure type safety
4. **Cancel When Appropriate**: Cancel requests when components unmount or user navigates away
5. **Set Proper Headers**: Ensure correct Content-Type for your requests
6. **Use Interceptors**: Centralize common logic like authentication

## Next Steps

- Learn about [Type Safety](/docs/type-safety) features
- Explore [Error Handling](/docs/error-handling) patterns
- Read about [Interceptors](/docs/interceptors) for request/response transformation