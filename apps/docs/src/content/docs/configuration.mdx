---
title: Configuration & Setup
description: Complete guide to configuring next-unified-query with setDefaultQueryClientOptions and Provider setup
---

# Configuration & Setup

Learn how to configure next-unified-query for your application with global settings and provider setup.

## Global Configuration

### setDefaultQueryClientOptions

Set default options for all QueryClient instances in your application.

```typescript
import { setDefaultQueryClientOptions } from 'next-unified-query/core';

// Call once at app initialization
setDefaultQueryClientOptions({
  // Cache configuration
  queryCache: {
    maxQueries: 200,        // Maximum cached queries (default: 100)
    defaultStaleTime: 60000, // 1 minute (default: 0)
    defaultGcTime: 300000   // 5 minutes (default: 300000)
  },
  
  // Fetch configuration
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json'
  },
  
  // Interceptor setup
  setupInterceptors: (fetcher) => {
    // Request interceptor
    fetcher.interceptors.request.use(
      (config) => {
        const token = getAuthToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // Response interceptor
    fetcher.interceptors.response.use(
      (response) => response,
      async (error) => {
        if (error.response?.status === 401) {
          await refreshToken();
          return fetcher.request(error.config);
        }
        return Promise.reject(error);
      }
    );
  }
});
```

### Configuration Options

```typescript
interface QueryClientOptionsWithInterceptors {
  // Cache configuration
  queryCache?: {
    /**
     * Maximum number of queries to cache
     * @default 100
     */
    maxQueries?: number;
    
    /**
     * Default time in ms before data is considered stale
     * @default 0
     */
    defaultStaleTime?: number;
    
    /**
     * Default time in ms before inactive queries are garbage collected
     * @default 300000 (5 minutes)
     */
    defaultGcTime?: number;
  };
  
  // Fetch configuration (from axios)
  baseURL?: string;
  timeout?: number;
  headers?: Record<string, string>;
  withCredentials?: boolean;
  responseType?: ResponseType;
  responseEncoding?: string;
  xsrfCookieName?: string;
  xsrfHeaderName?: string;
  maxContentLength?: number;
  maxBodyLength?: number;
  maxRedirects?: number;
  httpAgent?: any;
  httpsAgent?: any;
  proxy?: ProxyConfig | false;
  decompress?: boolean;
  
  // Interceptor setup function
  setupInterceptors?: (fetcher: NextTypeFetch) => void;
}
```

## Provider Setup

### Next.js App Router

```typescript
// app/providers.tsx
'use client';

import { QueryClientProvider } from 'next-unified-query/react';
import { ReactNode } from 'react';

export function Providers({ children }: { children: ReactNode }) {
  return (
    <QueryClientProvider>
      {children}
    </QueryClientProvider>
  );
}

// app/layout.tsx
import { Providers } from './providers';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

### Next.js Pages Router

```typescript
// pages/_app.tsx
import { QueryClientProvider } from 'next-unified-query/react';
import type { AppProps } from 'next/app';

export default function MyApp({ Component, pageProps }: AppProps) {
  return (
    <QueryClientProvider>
      <Component {...pageProps} />
    </QueryClientProvider>
  );
}
```

### Custom QueryClient Instance

```typescript
import { 
  QueryClientProvider, 
  createQueryClientWithInterceptors 
} from 'next-unified-query/react';

const queryClient = createQueryClientWithInterceptors(
  {
    // QueryClient options
    queryCache: {
      maxQueries: 300,
      defaultStaleTime: 60000
    },
    baseURL: 'https://api.example.com',
    timeout: 30000
  },
  // Interceptor setup function
  (fetcher) => {
    fetcher.interceptors.request.use((config) => {
      // Add auth token
      const token = localStorage.getItem('token');
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
    
    fetcher.interceptors.response.use(
      (response) => response,
      async (error) => {
        // Handle 401 errors
        if (error.response?.status === 401) {
          // Refresh token logic
          const newToken = await refreshAuthToken();
          if (newToken) {
            error.config.headers.Authorization = `Bearer ${newToken}`;
            return fetcher.request(error.config);
          }
        }
        return Promise.reject(error);
      }
    );
  }
);

export function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* Your app */}
    </QueryClientProvider>
  );
}
```

## Environment-Specific Configuration

### Development vs Production

```typescript
// config/query-client.ts
import { setDefaultQueryClientOptions } from 'next-unified-query/core';

const isDevelopment = process.env.NODE_ENV === 'development';

setDefaultQueryClientOptions({
  queryCache: {
    // Longer cache in production
    defaultStaleTime: isDevelopment ? 0 : 60000,
    defaultGcTime: isDevelopment ? 60000 : 300000,
    // More queries in production
    maxQueries: isDevelopment ? 50 : 200
  },
  
  // Different timeouts
  timeout: isDevelopment ? 10000 : 30000,
  
  setupInterceptors: (fetcher) => {
    if (isDevelopment) {
      // Log all requests in development
      fetcher.interceptors.request.use((config) => {
        console.log(`[${config.method?.toUpperCase()}] ${config.url}`);
        return config;
      });
      
      // Log response times
      fetcher.interceptors.response.use((response) => {
        const duration = Date.now() - response.config.metadata?.startTime;
        console.log(`[${response.status}] ${response.config.url} (${duration}ms)`);
        return response;
      });
    }
  }
});
```

### Multiple Environments

```typescript
// config/environments.ts
type Environment = 'development' | 'staging' | 'production';

const configs: Record<Environment, QueryClientOptionsWithInterceptors> = {
  development: {
    baseURL: 'http://localhost:3001',
    queryCache: {
      defaultStaleTime: 0,
      maxQueries: 50
    }
  },
  staging: {
    baseURL: 'https://staging-api.example.com',
    queryCache: {
      defaultStaleTime: 30000,
      maxQueries: 100
    }
  },
  production: {
    baseURL: 'https://api.example.com',
    queryCache: {
      defaultStaleTime: 60000,
      maxQueries: 200
    }
  }
};

const env = (process.env.NEXT_PUBLIC_ENV || 'development') as Environment;

setDefaultQueryClientOptions({
  ...configs[env],
  setupInterceptors: (fetcher) => {
    // Common interceptors for all environments
    setupAuthInterceptors(fetcher);
    
    // Environment-specific interceptors
    if (env === 'development') {
      setupLoggingInterceptors(fetcher);
    }
    
    if (env === 'production') {
      setupMonitoringInterceptors(fetcher);
    }
  }
});
```

## Common Interceptor Patterns

### Authentication

```typescript
function setupAuthInterceptors(fetcher: NextTypeFetch) {
  // Add auth token to requests
  fetcher.interceptors.request.use((config) => {
    const token = getAuthToken();
    if (token && !config.headers.Authorization) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  });
  
  // Handle token refresh
  fetcher.interceptors.response.use(
    (response) => response,
    async (error) => {
      const originalRequest = error.config;
      
      if (error.response?.status === 401 && !originalRequest._retry) {
        originalRequest._retry = true;
        
        try {
          const newToken = await refreshAuthToken();
          originalRequest.headers.Authorization = `Bearer ${newToken}`;
          return fetcher.request(originalRequest);
        } catch (refreshError) {
          // Redirect to login
          window.location.href = '/login';
          return Promise.reject(refreshError);
        }
      }
      
      return Promise.reject(error);
    }
  );
}
```

### Request/Response Logging

```typescript
function setupLoggingInterceptors(fetcher: NextTypeFetch) {
  // Request logging
  fetcher.interceptors.request.use((config) => {
    config.metadata = { startTime: Date.now() };
    console.group(`🚀 ${config.method?.toUpperCase()} ${config.url}`);
    console.log('Headers:', config.headers);
    if (config.data) console.log('Body:', config.data);
    console.groupEnd();
    return config;
  });
  
  // Response logging
  fetcher.interceptors.response.use(
    (response) => {
      const duration = Date.now() - (response.config.metadata?.startTime || 0);
      console.group(`✅ ${response.status} ${response.config.url} (${duration}ms)`);
      console.log('Response:', response.data);
      console.groupEnd();
      return response;
    },
    (error) => {
      const duration = Date.now() - (error.config?.metadata?.startTime || 0);
      console.group(`❌ ${error.response?.status || 'Network Error'} ${error.config?.url} (${duration}ms)`);
      console.error('Error:', error.message);
      if (error.response?.data) console.error('Response:', error.response.data);
      console.groupEnd();
      return Promise.reject(error);
    }
  );
}
```

### Error Monitoring

```typescript
function setupMonitoringInterceptors(fetcher: NextTypeFetch) {
  fetcher.interceptors.response.use(
    (response) => response,
    (error) => {
      // Send error to monitoring service
      if (typeof window !== 'undefined' && window.Sentry) {
        window.Sentry.captureException(error, {
          extra: {
            url: error.config?.url,
            method: error.config?.method,
            status: error.response?.status,
            data: error.response?.data
          }
        });
      }
      
      return Promise.reject(error);
    }
  );
}
```

## Advanced Configuration

### Dynamic Configuration Updates

```typescript
import { setDefaultQueryClientOptions, resetQueryClient } from 'next-unified-query/core';

// Update configuration at runtime
function updateApiEndpoint(newEndpoint: string) {
  setDefaultQueryClientOptions({
    baseURL: newEndpoint,
    // Other options remain the same
  });
  
  // Reset client to apply new configuration
  resetQueryClient();
}

// Example: Switch between environments
function switchEnvironment(env: 'production' | 'staging') {
  const endpoints = {
    production: 'https://api.example.com',
    staging: 'https://staging-api.example.com'
  };
  
  updateApiEndpoint(endpoints[env]);
}
```

### Per-Request Configuration Override

```typescript
// Global configuration
setDefaultQueryClientOptions({
  timeout: 30000,
  baseURL: 'https://api.example.com'
});

// Override for specific requests
const { data } = useQuery({
  cacheKey: ['large-file'],
  url: '/download/large-file',
  fetchConfig: {
    timeout: 120000, // 2 minutes for large file
    responseType: 'blob'
  }
});
```

### Integration with Other Libraries

```typescript
// Integration with state management (Zustand example)
import { create } from 'zustand';

const useAuthStore = create((set) => ({
  token: null,
  setToken: (token: string | null) => set({ token })
}));

setDefaultQueryClientOptions({
  setupInterceptors: (fetcher) => {
    fetcher.interceptors.request.use((config) => {
      const token = useAuthStore.getState().token;
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
  }
});
```

## Troubleshooting

### Common Issues

#### Configuration Not Applied

```typescript
// ❌ Wrong: Setting options after QueryClient creation
const queryClient = getQueryClient();
setDefaultQueryClientOptions({ baseURL: 'https://api.example.com' });

// ✅ Correct: Set options before creating QueryClient
setDefaultQueryClientOptions({ baseURL: 'https://api.example.com' });
const queryClient = getQueryClient();
```

#### Interceptors Not Working

```typescript
// ❌ Wrong: Returning nothing from interceptor
fetcher.interceptors.request.use((config) => {
  config.headers.Authorization = 'Bearer token';
  // Missing return statement
});

// ✅ Correct: Always return config
fetcher.interceptors.request.use((config) => {
  config.headers.Authorization = 'Bearer token';
  return config; // Must return config
});
```

#### TypeScript Errors

```typescript
// ❌ Wrong: Incorrect type for setupInterceptors
setDefaultQueryClientOptions({
  setupInterceptors: async (fetcher) => { // async not allowed
    // ...
  }
});

// ✅ Correct: Synchronous function
setDefaultQueryClientOptions({
  setupInterceptors: (fetcher) => {
    // Can use async inside interceptors
    fetcher.interceptors.response.use(
      (response) => response,
      async (error) => {
        // Async operations allowed here
        await someAsyncOperation();
        return Promise.reject(error);
      }
    );
  }
});
```

## Best Practices

1. **Initialize Early**: Call `setDefaultQueryClientOptions` before any component renders
2. **Centralize Configuration**: Keep all configuration in a single file
3. **Environment Variables**: Use environment variables for API endpoints
4. **Type Safety**: Use TypeScript for interceptor functions
5. **Error Boundaries**: Implement error boundaries for network failures
6. **Security**: Never log sensitive data in development interceptors
7. **Performance**: Avoid heavy operations in request interceptors

## Next Steps

- Learn about [Core Hooks](/docs/core-hooks) for data fetching
- Explore [Factory Patterns](/docs/factory-patterns) for type-safe queries
- Read about [Error Handling](/docs/error-handling) strategies