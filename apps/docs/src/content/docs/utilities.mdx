---
title: Utility Functions
description: Comprehensive guide to utility functions provided by next-unified-query
---

import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Badge } from '@/components/ui/badge';

# Utility Functions

next-unified-query provides a comprehensive set of utility functions to simplify common tasks when working with HTTP requests, responses, and data transformations.

## Response Utilities

next-unified-query provides utilities to work with response objects and extract data safely.

### Data Extraction

Extract data from NextTypeResponse objects easily:

```typescript
import { unwrap, getStatus, getHeaders } from '@my/next-unified-query/core';

const response = await api.get('/api/users');

// Extract data
const data = unwrap(response);

// Get status code
const status = getStatus(response);

// Get headers
const headers = getHeaders(response);

// Check specific status
if (hasStatus(response, 200)) {
  console.log('Success!');
}
```

### Response Creation

Create standardized response objects:

```typescript
import { createError, errorToResponse } from '@my/next-unified-query/core';

// Create a FetchError
const error = createError(
  'Resource not found',
  config,
  'ERR_NOT_FOUND',
  response,
  { detail: 'User with ID 123 not found' }
);

// Convert error to response format
const errorResponse = errorToResponse(error, {
  error: true,
  message: error.message
});
```

## Error Handling

### Type Guards

Check error types safely with TypeScript type guards:

```typescript
import { isFetchError, isValidationError } from '@my/next-unified-query/core';

try {
  const response = await api.post('/api/users', userData);
} catch (error) {
  if (isFetchError(error)) {
    console.error('API error:', error.code, error.response?.status);
    
    if (isValidationError(error)) {
      const errors = getValidationErrors(error);
      // Handle validation errors
    }
  }
}
```

### Error Code Handling

Handle errors based on predefined error codes:

<Tabs defaultValue="codes" className="w-full">
  <TabsList>
    <TabsTrigger value="codes">Error Codes</TabsTrigger>
    <TabsTrigger value="handling">Error Handling</TabsTrigger>
  </TabsList>
  <TabsContent value="codes">
    ```typescript
    import { ErrorCode } from '@my/next-unified-query/core';

    // Available error codes
    const ErrorCode = {
      NETWORK: "ERR_NETWORK",        // Network connectivity issues
      CANCELED: "ERR_CANCELED",      // Request was canceled
      TIMEOUT: "ERR_TIMEOUT",        // Request timeout
      BAD_RESPONSE: "ERR_BAD_RESPONSE", // Invalid response format
      VALIDATION: "ERR_VALIDATION",  // Schema validation failed
      VALIDATION_UNKNOWN: "ERR_VALIDATION_UNKNOWN", // Unknown validation error
      UNKNOWN: "ERR_UNKNOWN"         // Unknown error
    } as const;
    ```
  </TabsContent>
  <TabsContent value="handling">
    ```typescript
    import { handleFetchError, hasErrorCode, ErrorCode } from '@my/next-unified-query/core';

    // Check specific error code
    if (hasErrorCode(error, ErrorCode.TIMEOUT)) {
      console.log('Request timed out');
    }

    // Handle multiple error codes
    const message = handleFetchError(error, {
      [ErrorCode.NETWORK]: () => 'Check your internet connection',
      [ErrorCode.TIMEOUT]: () => 'Request took too long',
      [ErrorCode.CANCELED]: () => 'Request was canceled',
      default: (err) => `Error: ${err.message}`
    });
    ```
  </TabsContent>
</Tabs>

### HTTP Status Handling

Handle errors based on HTTP status codes:

```typescript
import { handleHttpError } from '@my/next-unified-query/core';

const message = handleHttpError(error, {
  400: () => 'Invalid request data',
  401: () => 'Please log in to continue',
  403: () => 'You don\'t have permission',
  404: () => 'Resource not found',
  429: () => 'Too many requests',
  500: () => 'Server error, please try again',
  default: () => 'An unexpected error occurred'
});
```

### Validation Error Handling

Extract and handle validation errors from Zod schemas:

```typescript
import { getValidationErrors } from '@my/next-unified-query/core';

try {
  const response = await api.post('/api/users', userData);
} catch (error) {
  if (isValidationError(error)) {
    const validationErrors = getValidationErrors(error);
    // Returns: Array<{ path: string[], message: string }>
    
    validationErrors.forEach(({ path, message }) => {
      console.error(`Field ${path.join('.')}: ${message}`);
    });
  }
}
```


## Cache Key Management

### Query Key Generation

Generate consistent cache keys for queries:

```typescript
import { createQueryFactory } from '@my/next-unified-query/react';

// Factory automatically generates cache keys
const userQueries = createQueryFactory({
  baseURL: '/api/users',
  defaultOptions: {
    staleTime: 1000 * 60 * 5, // 5 minutes
  }
});

// Cache key is generated based on:
// 1. Base URL
// 2. Path parameters
// 3. Query parameters
const query = userQueries.query({ id: '123' }, { 
  params: { include: 'posts' } 
});
// Generated cache key: ['/api/users', { id: '123' }, { include: 'posts' }]
```

### Manual Cache Key Construction

For custom queries, construct cache keys manually:

```typescript
import { useQuery } from '@my/next-unified-query/react';

// Simple cache key
const { data } = useQuery({
  cacheKey: ['users', userId],
  url: `/api/users/${userId}`,
  schema: UserSchema
});

// Complex cache key with filters
const { data: filteredUsers } = useQuery({
  cacheKey: ['users', 'list', { role, status, page }],
  url: '/api/users',
  params: { role, status, page },
  schema: UsersSchema
});

// Hierarchical cache keys for invalidation
const { data: userPosts } = useQuery({
  cacheKey: ['users', userId, 'posts', { sort, limit }],
  url: `/api/users/${userId}/posts`,
  params: { sort, limit },
  schema: PostsSchema
});
```

## Type Extraction Utilities

Extract types from factory configurations:

```typescript
import type { 
  ExtractParams, 
  ExtractQueryData,
  ExtractMutationVariables,
  ExtractMutationData,
  ExtractMutationError
} from '@my/next-unified-query/react';

// Query types
type UserParams = ExtractParams<typeof userQueries.get>;
type UserData = ExtractQueryData<typeof userQueries.get>;

// Mutation types
type CreateUserVars = ExtractMutationVariables<typeof userMutations.create>;
type CreateUserData = ExtractMutationData<typeof userMutations.create>;
type CreateUserError = ExtractMutationError<typeof userMutations.create>;

// Use extracted types in components
function UserProfile({ userId }: { userId: string }) {
  const { data } = useQuery(userQueries.get, {
    params: { id: userId } satisfies UserParams
  });
  
  // data is typed as UserData
  return <div>{data?.name}</div>;
}
```

## Debugging Utilities

### Query Observer Debug

Debug query state and lifecycle:

```typescript
import { QueryObserver } from '@my/next-unified-query/core';

// Create observer with debug logging
const observer = new QueryObserver(queryClient, {
  cacheKey: ['debug', 'test'],
  url: '/api/test',
  enabled: true
});

// Subscribe to state changes
const unsubscribe = observer.subscribe((result) => {
  console.log('Query State:', {
    status: result.status,
    data: result.data,
    error: result.error,
    isLoading: result.isLoading,
    isFetching: result.isFetching,
    isStale: result.isStale
  });
});

// Check current state
const currentResult = observer.getResult();
console.log('Current:', currentResult);

// Clean up
unsubscribe();
```

### Request/Response Logging

Log all HTTP requests and responses:

```typescript
import { createQueryClientWithInterceptors } from '@my/next-unified-query/core';

const queryClient = createQueryClientWithInterceptors({
  interceptors: {
    request: [
      (config) => {
        console.log('ðŸš€ Request:', {
          url: config.url,
          method: config.method,
          headers: config.headers,
          params: config.params
        });
        return config;
      }
    ],
    response: [
      (response) => {
        console.log('âœ… Response:', {
          status: response.status,
          data: response.data,
          headers: response.headers
        });
        return response;
      }
    ],
    error: [
      (error) => {
        console.error('âŒ Error:', {
          message: error.message,
          code: error.code,
          response: error.response
        });
        throw error;
      }
    ]
  }
});
```

## Interceptor Utilities

### Interceptor Types

Access the available interceptor type symbols:

```typescript
import { interceptorTypes } from '@my/next-unified-query/core';

// Available interceptor types
console.log('Types:', interceptorTypes);
// â†’ { request: Symbol(request), response: Symbol(response), error: Symbol(error) }

// Use with createQueryClientWithInterceptors
const queryClient = createQueryClientWithInterceptors({
  interceptors: {
    [interceptorTypes.request]: [(config) => config],
    [interceptorTypes.response]: [(response) => response],
    [interceptorTypes.error]: [(error) => { throw error; }]
  }
});
```

### Global Interceptors (Legacy)

For backward compatibility, global interceptors are available:

```typescript
import { interceptors } from '@my/next-unified-query/core';

// Register interceptors globally (not recommended for new code)
const requestId = interceptors.request.use(
  (config) => {
    config.headers = {
      ...config.headers,
      'Authorization': `Bearer ${getToken()}`
    };
    return config;
  }
);

// Remove when done
interceptors.request.eject(requestId);

// Prefer createQueryClientWithInterceptors for new applications
```

### Interceptor Context Sharing

Share data between interceptors:

```typescript
import { createQueryClientWithInterceptors } from '@my/next-unified-query/core';

const queryClient = createQueryClientWithInterceptors({
  interceptors: {
    request: [
      (config) => {
        // Add request timestamp
        config.metadata = {
          ...config.metadata,
          startTime: Date.now()
        };
        return config;
      }
    ],
    response: [
      (response) => {
        // Calculate request duration
        const startTime = response.config?.metadata?.startTime;
        if (startTime) {
          const duration = Date.now() - startTime;
          console.log(`Request took ${duration}ms`);
        }
        return response;
      }
    ]
  }
});
```

## Practical Examples

### Complete Error Handling Flow

```typescript
import { 
  appendQueryParams,
  handleFetchError,
  handleHttpError,
  isFetchError,
  ErrorCode
} from '@my/next-unified-query/core';

async function fetchUserData(userId: string) {
  try {
    const url = appendQueryParams('/api/users', { id: userId });
    const response = await api.get(url);
    
    return unwrap(response);
  } catch (error) {
    if (isFetchError(error)) {
      // Handle by error code
      const codeMessage = handleFetchError(error, {
        [ErrorCode.NETWORK]: () => 'No internet connection',
        [ErrorCode.TIMEOUT]: () => 'Request timed out',
        default: null
      });
      
      if (codeMessage) return { error: codeMessage };
      
      // Handle by HTTP status
      const statusMessage = handleHttpError(error, {
        404: () => 'User not found',
        401: () => 'Authentication required',
        default: () => 'Server error'
      });
      
      return { error: statusMessage };
    }
    
    throw error;
  }
}
```

### Building Type-Safe API Clients

```typescript
import { 
  combineURLs, 
  appendQueryParams,
  mergeConfigs
} from '@my/next-unified-query/core';

class APIClient {
  private baseURL: string;
  private defaultConfig: RequestConfig;
  
  constructor(baseURL: string, config?: RequestConfig) {
    this.baseURL = baseURL;
    this.defaultConfig = config || {};
  }
  
  async request<T>(
    endpoint: string, 
    options?: RequestConfig
  ): Promise<T> {
    const url = combineURLs(this.baseURL, endpoint);
    const config = mergeConfigs(this.defaultConfig, options);
    
    if (config.params) {
      const fullUrl = appendQueryParams(url, config.params);
      delete config.params;
      
      return fetch(fullUrl, config);
    }
    
    return fetch(url, config);
  }
}
```

## QueryClient Utilities

### Creating QueryClient with Interceptors

Create a QueryClient instance with built-in interceptors:

```typescript
import { createQueryClientWithInterceptors } from '@my/next-unified-query/core';

const queryClient = createQueryClientWithInterceptors({
  interceptors: {
    request: [
      (config) => {
        // Add auth header
        config.headers = {
          ...config.headers,
          'Authorization': `Bearer ${getToken()}`
        };
        return config;
      }
    ],
    response: [
      (response) => {
        // Log successful responses
        console.log('Response:', response.status);
        return response;
      }
    ],
    error: [
      (error) => {
        // Handle errors globally
        if (error.response?.status === 401) {
          // Redirect to login
          window.location.href = '/login';
        }
        throw error;
      }
    ]
  }
});
```

### Managing QueryClient Instance

Get and reset the global QueryClient instance:

```typescript
import { getQueryClient, resetQueryClient } from '@my/next-unified-query/core';

// Get the current QueryClient instance
const queryClient = getQueryClient();

// Reset the QueryClient (useful for testing or logout)
resetQueryClient();
```

### SSR Prefetching

Prefetch data on the server for hydration:

```typescript
import { ssrPrefetch } from '@my/next-unified-query/core';
import { z } from '@my/next-unified-query/core';

// In your server component or getServerSideProps
await ssrPrefetch({
  cacheKey: ['user', userId],
  url: `/api/users/${userId}`,
  schema: z.object({
    id: z.string(),
    name: z.string(),
    email: z.string().email()
  })
});
```

## Best Practices

<div className="grid gap-4 mt-6">
  <div className="p-4 border rounded-lg">
    <h3 className="font-semibold mb-2">Use Type Guards</h3>
    <p className="text-sm text-muted-foreground">
      Always use type guards like `isFetchError` before accessing error properties
    </p>
  </div>
  
  <div className="p-4 border rounded-lg">
    <h3 className="font-semibold mb-2">Handle All Error Cases</h3>
    <p className="text-sm text-muted-foreground">
      Provide handlers for common error codes and HTTP statuses with meaningful messages
    </p>
  </div>
  
  <div className="p-4 border rounded-lg">
    <h3 className="font-semibold mb-2">Leverage Structural Sharing</h3>
    <p className="text-sm text-muted-foreground">
      Use `replaceEqualDeep` for large data structures to optimize React performance
    </p>
  </div>
  
  <div className="p-4 border rounded-lg">
    <h3 className="font-semibold mb-2">Validate Early</h3>
    <p className="text-sm text-muted-foreground">
      Use validation utilities to catch and handle schema errors at the boundary
    </p>
  </div>
  
  <div className="p-4 border rounded-lg">
    <h3 className="font-semibold mb-2">Optimize Cache Keys</h3>
    <p className="text-sm text-muted-foreground">
      Design hierarchical cache keys for efficient invalidation and query matching
    </p>
  </div>
  
  <div className="p-4 border rounded-lg">
    <h3 className="font-semibold mb-2">Debug in Development</h3>
    <p className="text-sm text-muted-foreground">
      Use debugging utilities and interceptors to monitor and troubleshoot API calls
    </p>
  </div>
</div>

## Legacy HTTP Method Utilities

For backward compatibility, individual HTTP method functions are available:

```typescript
import { get, post, put, del, patch, head, options } from '@my/next-unified-query/core';

// GET request
const userData = await get('/api/users/123');

// POST request with data
const newUser = await post('/api/users', {
  data: { name: 'John', email: 'john@example.com' }
});

// PUT request
const updated = await put('/api/users/123', {
  data: { name: 'John Doe' }
});

// DELETE request
await del('/api/users/123');

// PATCH request
const patched = await patch('/api/users/123', {
  data: { status: 'active' }
});

// HEAD request
const headers = await head('/api/users/123');

// OPTIONS request
const allowed = await options('/api/users');
```

**Note**: These are legacy APIs. For new applications, use `createQueryFactory` and `createMutationFactory` instead.

## See Also

- [Error Handling Guide](/docs/error-handling) - Comprehensive error handling patterns
- [Configuration Reference](/docs/configuration-reference) - Global configuration options
- [TypeScript Guide](/docs/type-safety/overview) - Type safety features
- [Performance Optimization](/docs/performance) - Using utilities for performance
- [Factory Patterns](/docs/factory-patterns) - Modern API for creating type-safe queries