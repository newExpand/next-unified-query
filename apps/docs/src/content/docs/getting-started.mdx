# Getting Started

Start fetching data with next-unified-query. This guide will walk you through the basic setup and creating your first query.

## Installation

```bash
npm install next-unified-query
# or
yarn add next-unified-query
# or
pnpm add next-unified-query
```

‚ú® **Includes built-in libraries**:
- **Zod v4** for schema validation (no separate install needed!)
- **es-toolkit** for high-performance utility functions
- **quick-lru** for optimized caching

## Import Structure

Next Unified Query provides two import paths for different environments:

```typescript
// üåê Server & Client Safe - Core functionality (no React context)
import { 
  createQueryFactory, 
  createMutationFactory, 
  z,  // Zod is re-exported!
  QueryClient,
  ssrPrefetch,
  configureQueryClient
} from 'next-unified-query';

// ‚öõÔ∏è Client Only - React hooks and components (uses React context)
import { 
  useQuery, 
  useMutation, 
  QueryClientProvider, 
  HydrationBoundary 
} from 'next-unified-query/react';
```

## Project Setup

### Step 1: Create Shared Configuration

Define your configuration once and use it everywhere - SSR, client, and global functions.

```typescript
// app/query-config.ts - Shared configuration file
import type { QueryClientOptions } from 'next-unified-query';

export const queryConfig: QueryClientOptions = {
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'https://jsonplaceholder.typicode.com',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
  
  // Common interceptors (run in all environments)
  interceptors: {
    request: (config) => {
      config.headers = config.headers || {};
      config.headers['X-App-Version'] = '1.0.0';
      return config;
    },
    response: (response) => {
      console.log(`[${response.config?.method}] ${response.config?.url} - ${response.status}`);
      return response;
    }
  },
  
  // Client-only interceptors (browser environment)
  clientInterceptors: {
    request: (config) => {
      // Direct access to browser APIs - no typeof checks!
      const token = localStorage.getItem('token');
      if (token) {
        config.headers = config.headers || {};
        config.headers['Authorization'] = `Bearer ${token}`;
      }
      return config;
    },
    error: (error) => {
      if (error.response?.status === 401) {
        localStorage.removeItem('token');
        window.location.href = '/login';
      }
      return Promise.reject(error);
    }
  },
  
  // Server-only interceptors (Node.js environment)  
  serverInterceptors: {
    request: (config) => {
      config.headers = config.headers || {};
      config.headers['X-Server-Region'] = process.env.REGION || 'us-east-1';
      return config;
    }
  }
};
```

### Step 2: Configure in Layout (SSR Support)

```typescript
// app/layout.tsx (Next.js App Router)
import { configureQueryClient } from 'next-unified-query';
import { queryConfig } from './query-config';
import { Providers } from './providers';

// üåü Configure for both SSR and client environments
configureQueryClient(queryConfig);

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

### Step 3: Create Client Provider

```typescript
// app/providers.tsx (Client Component)
'use client';

import { QueryClientProvider } from 'next-unified-query/react';
import { queryConfig } from './query-config';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider config={queryConfig}>
      {children}
    </QueryClientProvider>
  );
}
```

## Creating Your First Query

Now all request methods automatically use the same configuration:

```tsx
// app/users/page.tsx
'use client';

import { useQuery, useMutation } from 'next-unified-query/react';
import { get, post } from 'next-unified-query';

interface User {
  id: number;
  name: string;
  email: string;
}

export default function UsersPage() {
  // ‚úÖ useQuery - baseURL automatically applied
  const { data, isLoading, error } = useQuery<User[]>({
    cacheKey: ['users'],
    url: '/users'  // ‚Üí https://jsonplaceholder.typicode.com/users
  });

  // ‚úÖ useMutation - baseURL automatically applied
  // NEW in v0.2.0+: TVariables ‚Üí TData ‚Üí TError (natural flow)
  const createUser = useMutation<{ name: string; email: string }, User>({
    url: '/users',     // ‚Üí https://jsonplaceholder.typicode.com/users
    method: 'POST',
    onSuccess: (newUser) => {
      console.log('User created:', newUser);
    }
  });

  // ‚úÖ Global functions also use the same config
  const handleExport = async () => {
    const response = await get('/users/export');  // ‚Üí same baseURL!
    console.log('Export data:', response.data);
  };

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return (
    <div>
      <h1>Users ({data?.length || 0})</h1>
      {data?.map(user => (
        <div key={user.id}>
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      ))}
      <button onClick={() => createUser.mutate({ 
        name: 'New User',
        email: 'user@example.com'
      })}>
        Add User
      </button>
      <button onClick={handleExport}>
        Export Users
      </button>
    </div>
  );
}
```

## Advanced Features

### Factory Pattern for Type-Safe APIs

Create reusable, type-safe API definitions:

```typescript
// app/lib/api.ts
import { createQueryFactory, createMutationFactory, z } from 'next-unified-query';

// Define schemas with Zod (included!)
const userSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email(),
});

// Create query factory
export const userQueries = createQueryFactory({
  list: {
    cacheKey: () => ['users'] as const,
    url: () => '/users',
    schema: z.array(userSchema) // Automatic TypeScript inference!
  },
  get: {
    cacheKey: (id: number) => ['users', id] as const,
    url: (id: number) => `/users/${id}`,
    schema: userSchema
  }
});

// Create mutation factory  
export const userMutations = createMutationFactory({
  create: {
    url: () => '/users',
    method: 'POST',
    requestSchema: z.object({
      name: z.string(),
      email: z.string().email()
    }),
    responseSchema: userSchema
  }
});

// Use with perfect TypeScript support
const { data } = useQuery(userQueries.list);        // data is User[] ‚ú®
const { data: user } = useQuery(userQueries.get, { 
  params: 1  // Pass params directly (matches factory parameter type)
}); // user is User ‚ú®
const createMutation = useMutation(userMutations.create);
```

### Server-Side Rendering (SSR)

Next Unified Query provides first-class SSR support:

```tsx
// app/users/[id]/page.tsx - Next.js App Router
import { ssrPrefetch } from 'next-unified-query';
import { HydrationBoundary } from 'next-unified-query/react';
import { userQueries } from '@/lib/api';

export default async function UserPage({ params }: { params: { id: string } }) {
  // ‚úÖ Server-side prefetching uses config from configureQueryClient()
  // No need to pass config - it's already configured globally!
  const dehydratedState = await ssrPrefetch([
    [userQueries.get, Number(params.id)]  // Pass params directly (not wrapped in object)
  ]);

  return (
    <HydrationBoundary state={dehydratedState}>
      <UserDetail userId={Number(params.id)} />
    </HydrationBoundary>
  );
}

'use client';

function UserDetail({ userId }: { userId: number }) {
  // ‚úÖ Uses prefetched data immediately, no loading state!
  const { data } = useQuery(userQueries.get, { 
    params: userId  // Pass params directly
  });
  
  return <div>Welcome, {data?.name}!</div>; // Instant render! ‚ö°
}
```

## Key Features

### üõ°Ô∏è Compile-Time HTTP Method Safety

```tsx
// ‚úÖ Type-safe by design
const { data } = useQuery({
  cacheKey: ['users'],
  url: '/users'  // ‚úÖ Only GET/HEAD allowed - perfect for data fetching
});

// Type parameters follow natural flow: input ‚Üí output
const createUser = useMutation<CreateUserInput, User>({
  url: '/users',
  method: 'POST'  // ‚úÖ POST/PUT/DELETE/PATCH allowed - perfect for mutations
});

// ‚ùå This won't even compile!
const badQuery = useQuery({
  url: '/users',
  method: 'POST'  // üö® TypeScript Error: useQuery doesn't allow POST
});
```

### ‚ö° Performance Optimizations

```tsx
// Selective subscriptions for optimal performance
function UserProfile({ userId }: { userId: number }) {
  const { data: userName } = useQuery({
    cacheKey: ['user', userId],
    url: `/users/${userId}`,
    select: (user) => user.name  // ‚ú® Only re-render on name changes
  });

  return <h1>{userName}</h1>;
}
```

### üîÑ Global Functions for Direct API Calls

```tsx
import { get, post } from 'next-unified-query';

// Perfect for event handlers and utilities
async function exportUserData() {
  try {
    const users = await get('/users');           // Same config as hooks!
    const csv = await post('/export', {          // Same interceptors!
      data: users.data,
      format: 'csv'
    });
    
    downloadFile(csv.data);
  } catch (error) {
    console.error('Export failed:', error);
  }
}
```

## Advanced Options

### Suspense & Error Boundaries

```tsx
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary'; // or your error boundary

// Enable Suspense mode for cleaner loading states
function UserList() {
  const { data } = useQuery({
    cacheKey: ['users'],
    url: '/users',
    suspense: true  // Enable Suspense mode
  });

  // No loading state needed!
  return (
    <ul>
      {data.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Wrap with Suspense and ErrorBoundary
export default function UsersPage() {
  return (
    <ErrorBoundary fallback={<div>Something went wrong</div>}>
      <Suspense fallback={<div>Loading...</div>}>
        <UserList />
      </Suspense>
    </ErrorBoundary>
  );
}
```

### Optimistic Updates

```tsx
import { getQueryClient } from 'next-unified-query';

function UpdateUserForm({ user }) {
  const queryClient = getQueryClient();
  
  const updateUser = useMutation<UpdateUserInput, User>({
    url: (data) => `/users/${data.id}`,
    method: 'PUT',
    onSuccess: (updatedUser) => {
      // Update cache with server response
      queryClient.setQueryData(['users', updatedUser.id], updatedUser);
      
      // Optionally update users list if needed
      queryClient.setQueryData(['users'], (old: User[] | undefined) => {
        if (!old) return [updatedUser];
        return old.map(u => u.id === updatedUser.id ? updatedUser : u);
      });
    },
    onError: (error) => {
      console.error('Failed to update user:', error);
      // Optionally show error notification
    }
  });

  return (
    // Form UI here
    <form onSubmit={(e) => {
      e.preventDefault();
      updateUser.mutate(formData);
    }}>
      {/* Form fields */}
    </form>
  );
}
```

## Common Patterns

### Dependent Queries

```tsx
function UserPosts({ userId }: { userId: number }) {
  const { data: user } = useQuery({
    cacheKey: ['user', userId],
    url: `/users/${userId}`
  });

  const { data: posts } = useQuery({
    cacheKey: ['posts', userId],
    url: `/users/${userId}/posts`,
    enabled: !!user  // Only fetch posts after user is loaded
  });

  return (
    <div>
      <h2>{user?.name}'s Posts</h2>
      {posts?.map(post => (
        <article key={post.id}>{post.title}</article>
      ))}
    </div>
  );
}
```

### Manual Refetch

```tsx
function Dashboard() {
  const { data, refetch, isFetching } = useQuery({
    cacheKey: ['dashboard'],
    url: '/dashboard'
  });

  return (
    <div>
      <DashboardView data={data} />
      <button 
        onClick={() => refetch()}
        disabled={isFetching}
      >
        Refresh Data
      </button>
    </div>
  );
}
```

### Pagination

```tsx
import { useState } from 'react';

function PaginatedList() {
  const [page, setPage] = useState(1);

  const { data, isFetching } = useQuery({
    cacheKey: ['items', page],
    url: `/items?page=${page}&limit=20`,
    placeholderData: (previousData) => previousData, // Keep previous data while fetching
  });

  return (
    <div>
      {data?.items.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
      <div>
        <button 
          onClick={() => setPage(p => Math.max(1, p - 1))}
          disabled={page === 1 || isFetching}
        >
          Previous
        </button>
        <span>Page {page}</span>
        <button 
          onClick={() => setPage(p => p + 1)}
          disabled={isFetching || !data?.hasMore}
        >
          Next
        </button>
      </div>
    </div>
  );
}
```

## Performance Tips

1. **Use `select` for granular subscriptions** - Only re-render when specific data changes
2. **Set appropriate `staleTime`** - Avoid unnecessary refetches
3. **Use `placeholderData`** - Show immediate UI while fetching
4. **Enable `suspense`** - Cleaner loading states with React Suspense
5. **Implement proper cache keys** - Hierarchical and predictable

## Next Steps

- üìñ [API Reference](/docs/api) - Complete API documentation
- üéì [User Guide](/docs/guide) - In-depth tutorials and patterns
- üè≠ [Factory Patterns](/docs/factory) - Advanced type-safe patterns
- üåê [SSR Guide](/docs/ssr) - Server-side rendering best practices
- ‚ö° [Performance Guide](/docs/performance) - Optimization techniques

## Need Help?

- üí¨ [GitHub Issues](https://github.com/newExpand/next-unified-query/issues) - Report bugs or request features
- üìö [Examples](https://github.com/newExpand/next-unified-query/tree/main/apps/example) - See real-world usage
- ‚≠ê [Star on GitHub](https://github.com/newExpand/next-unified-query) - Support the project!