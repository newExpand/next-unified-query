---
title: Best Practices
description: 권장 사용 패턴과 개발 가이드라인
---

import { Callout, Card, Cards, Code, Pre, Tabs } from '@/components/ui';

# Best Practices

`next-unified-query`를 효과적으로 사용하기 위한 모범 사례와 권장 패턴을 소개합니다.

## Query/Mutation 패턴

### Query 사용 가이드

#### 1. Factory 패턴 활용

Factory 패턴을 사용하면 타입 안전성과 재사용성을 모두 확보할 수 있습니다:

```typescript
// ✅ 권장: Factory 패턴 사용
const getUserFactory = createQueryFactory({
  schema: UserSchema,
  handler: async ({ params }: { params: { id: string } }) => {
    const response = await fetch(`/api/users/${params.id}`);
    return response.json();
  }
});

// 컴포넌트에서 사용
const { data } = useQuery(getUserFactory.query, {
  params: { id: userId }
});
```

```typescript
// ❌ 비권장: 인라인 구성
const { data } = useQuery({
  cacheKey: ['user', userId],
  url: `/api/users/${userId}`,
  schema: UserSchema
});
```

#### 2. 캐시 키 전략

일관된 캐시 키 명명 규칙을 사용하세요:

```typescript
// ✅ 권장: 계층적 캐시 키 구조
const cacheKey = {
  all: ['users'] as const,
  lists: () => [...cacheKey.all, 'list'] as const,
  list: (filters: UserFilters) => [...cacheKey.lists(), { filters }] as const,
  details: () => [...cacheKey.all, 'detail'] as const,
  detail: (id: string) => [...cacheKey.details(), id] as const,
};

// 사용 예시
const { data } = useQuery({
  cacheKey: cacheKey.detail(userId),
  url: `/api/users/${userId}`,
  schema: UserSchema
});
```

#### 3. 조건부 쿼리

불필요한 API 호출을 방지하려면 `enabled` 옵션을 활용하세요:

```typescript
const { data: user } = useQuery({
  cacheKey: ['user', userId],
  url: `/api/users/${userId}`,
  schema: UserSchema,
  enabled: !!userId // userId가 있을 때만 실행
});

const { data: permissions } = useQuery({
  cacheKey: ['permissions', user?.id],
  url: `/api/permissions/${user?.id}`,
  schema: PermissionsSchema,
  enabled: !!user?.id // user 데이터가 로드된 후 실행
});
```

### Mutation 사용 가이드

#### 1. Optimistic Updates

사용자 경험을 개선하기 위해 낙관적 업데이트를 구현하세요:

```typescript
const updateUserMutation = useMutation({
  mutationFn: async (data: UpdateUserInput) => {
    const response = await fetch(`/api/users/${data.id}`, {
      method: 'PUT',
      body: JSON.stringify(data)
    });
    return response.json();
  },
  onMutate: async (newData) => {
    // 이전 데이터 백업
    await queryClient.cancelQueries({ queryKey: ['user', newData.id] });
    const previousUser = queryClient.getQueryData(['user', newData.id]);
    
    // 낙관적 업데이트
    queryClient.setQueryData(['user', newData.id], newData);
    
    return { previousUser };
  },
  onError: (err, newData, context) => {
    // 에러 시 롤백
    if (context?.previousUser) {
      queryClient.setQueryData(['user', newData.id], context.previousUser);
    }
  },
  onSettled: (data, error, variables) => {
    // 성공/실패 관계없이 쿼리 무효화
    queryClient.invalidateQueries({ queryKey: ['user', variables.id] });
  }
});
```

#### 2. 관련 쿼리 무효화

mutation 후 관련된 모든 쿼리를 적절히 무효화하세요:

```typescript
const createPostMutation = useMutation({
  mutationFn: createPost,
  onSuccess: (newPost) => {
    // 특정 쿼리 무효화
    queryClient.invalidateQueries({ queryKey: ['posts'] });
    queryClient.invalidateQueries({ queryKey: ['user', newPost.authorId, 'posts'] });
    
    // 새 데이터로 캐시 업데이트
    queryClient.setQueryData(['post', newPost.id], newPost);
  }
});
```

## TypeScript 사용 가이드라인

### 타입 추론 활용

#### 1. Factory 타입 추론

Factory 패턴은 자동 타입 추론을 제공합니다:

```typescript
// 타입이 자동으로 추론됨
const userFactory = createQueryFactory({
  schema: z.object({
    id: z.string(),
    name: z.string(),
    email: z.string().email()
  }),
  handler: async ({ params }: { params: { id: string } }) => {
    // ...
  }
});

// 컴포넌트에서 타입 안전하게 사용
const { data } = useQuery(userFactory.query, {
  params: { id: '123' } // 타입 체크됨
});

// data의 타입이 자동으로 추론됨
if (data) {
  console.log(data.name); // string
  console.log(data.email); // string
}
```

#### 2. 유틸리티 타입 활용

제공되는 유틸리티 타입을 활용하여 타입을 추출하세요:

```typescript
// Factory에서 파라미터 타입 추출
type UserParams = ExtractParams<typeof userFactory.query>;

// Factory에서 응답 데이터 타입 추출
type UserData = ExtractQueryData<typeof userFactory.query>;

// 커스텀 훅에서 활용
function useUserDetails(params: UserParams) {
  const { data, isLoading } = useQuery(userFactory.query, { params });
  
  return {
    user: data as UserData | undefined,
    isLoading
  };
}
```

### 엄격한 타입 체크

#### 1. Strict Mode 활용

TypeScript strict mode를 활성화하여 타입 안전성을 높이세요:

```json
{
  "compilerOptions": {
    "strict": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitAny": true
  }
}
```

#### 2. 타입 가드 사용

응답 데이터를 안전하게 처리하기 위해 타입 가드를 사용하세요:

```typescript
// 타입 가드 함수
function isValidUser(data: unknown): data is User {
  return (
    typeof data === 'object' &&
    data !== null &&
    'id' in data &&
    'name' in data
  );
}

// 사용 예시
const { data } = useQuery({
  cacheKey: ['user', userId],
  url: `/api/users/${userId}`,
  schema: UserSchema
});

if (isValidUser(data)) {
  // 타입이 좁혀짐
  console.log(data.name);
}
```

## 에러 처리 모범 사례

### 전역 에러 처리

#### 1. 에러 바운더리 설정

React Error Boundary를 사용하여 전역 에러를 처리하세요:

```tsx
import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div className="error-fallback">
      <h2>오류가 발생했습니다</h2>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>다시 시도</button>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <NextUnifiedQueryProvider>
        <YourApp />
      </NextUnifiedQueryProvider>
    </ErrorBoundary>
  );
}
```

#### 2. 쿼리별 에러 처리

개별 쿼리의 에러를 적절히 처리하세요:

```typescript
const { data, error, isError, refetch } = useQuery({
  cacheKey: ['user', userId],
  url: `/api/users/${userId}`,
  schema: UserSchema,
  retry: 3,
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000)
});

if (isError) {
  if (error instanceof z.ZodError) {
    // 스키마 검증 에러
    return <div>데이터 형식이 올바르지 않습니다</div>;
  }
  
  if (error.status === 404) {
    // Not Found
    return <div>사용자를 찾을 수 없습니다</div>;
  }
  
  // 기타 에러
  return (
    <div>
      <p>오류가 발생했습니다: {error.message}</p>
      <button onClick={() => refetch()}>다시 시도</button>
    </div>
  );
}
```

### 에러 리포팅

#### 1. 에러 로깅

프로덕션 환경에서 에러를 추적하세요:

```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      onError: (error) => {
        // Sentry 등의 에러 추적 서비스로 전송
        console.error('Query error:', error);
        
        if (process.env.NODE_ENV === 'production') {
          // Sentry.captureException(error);
        }
      }
    },
    mutations: {
      onError: (error) => {
        console.error('Mutation error:', error);
        
        if (process.env.NODE_ENV === 'production') {
          // Sentry.captureException(error);
        }
      }
    }
  }
});
```

## 캐싱 전략

### 캐시 구성

#### 1. 캐시 시간 설정

데이터 특성에 따라 적절한 캐시 시간을 설정하세요:

```typescript
// 자주 변경되지 않는 데이터
const { data: userProfile } = useQuery({
  cacheKey: ['user', userId],
  url: `/api/users/${userId}`,
  schema: UserSchema,
  staleTime: 5 * 60 * 1000, // 5분
  cacheTime: 10 * 60 * 1000 // 10분
});

// 실시간성이 중요한 데이터
const { data: notifications } = useQuery({
  cacheKey: ['notifications'],
  url: '/api/notifications',
  schema: NotificationsSchema,
  staleTime: 0, // 항상 fresh
  refetchInterval: 10000 // 10초마다 갱신
});
```

#### 2. 캐시 무효화 전략

효율적인 캐시 무효화를 구현하세요:

```typescript
// 선택적 무효화
const invalidateUserQueries = (userId: string) => {
  // 특정 사용자 쿼리만 무효화
  queryClient.invalidateQueries({ 
    queryKey: ['user', userId],
    exact: true 
  });
  
  // 사용자 관련 모든 쿼리 무효화
  queryClient.invalidateQueries({ 
    queryKey: ['user', userId],
    exact: false 
  });
};

// 스마트 무효화
const smartInvalidate = (resource: string, id?: string) => {
  if (id) {
    // 특정 항목만 무효화
    queryClient.invalidateQueries({ queryKey: [resource, id] });
  } else {
    // 전체 리스트 무효화
    queryClient.invalidateQueries({ queryKey: [resource, 'list'] });
  }
};
```

### 프리페칭

사용자 경험을 개선하기 위해 데이터를 미리 로드하세요:

```typescript
// 링크 호버 시 프리페칭
function UserLink({ userId }: { userId: string }) {
  const prefetchUser = () => {
    queryClient.prefetchQuery({
      queryKey: ['user', userId],
      queryFn: () => fetchUser(userId),
      staleTime: 10 * 1000 // 10초
    });
  };
  
  return (
    <Link 
      href={`/users/${userId}`}
      onMouseEnter={prefetchUser}
    >
      사용자 프로필
    </Link>
  );
}

// 라우트 진입 전 프리페칭
async function prefetchDashboardData() {
  await Promise.all([
    queryClient.prefetchQuery({
      queryKey: ['dashboard-stats'],
      queryFn: fetchDashboardStats
    }),
    queryClient.prefetchQuery({
      queryKey: ['recent-activities'],
      queryFn: fetchRecentActivities
    })
  ]);
}
```

## 성능 최적화

### 번들 크기 최적화

#### 1. Tree Shaking

사용하지 않는 코드를 제거하세요:

```typescript
// ✅ 권장: 필요한 것만 import
import { useQuery, useMutation } from 'next-unified-query';

// ❌ 비권장: 전체 import
import * as NextQuery from 'next-unified-query';
```

#### 2. 동적 import

큰 스키마나 유틸리티는 동적으로 로드하세요:

```typescript
// 스키마를 동적으로 로드
const UserSchema = lazy(() => import('./schemas/user'));

// 컴포넌트에서 사용
const { data } = useQuery({
  cacheKey: ['user', userId],
  url: `/api/users/${userId}`,
  schema: UserSchema,
  suspense: true // Suspense와 함께 사용
});
```

### 메모리 관리

#### 1. 쿼리 가비지 컬렉션

사용하지 않는 쿼리를 정리하세요:

```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      cacheTime: 5 * 60 * 1000, // 5분 후 가비지 컬렉션
      staleTime: 1 * 60 * 1000  // 1분 후 stale
    }
  }
});

// 수동으로 캐시 정리
queryClient.removeQueries({
  queryKey: ['old-data'],
  exact: false
});
```

#### 2. 무한 쿼리 최적화

무한 스크롤 구현 시 메모리를 효율적으로 관리하세요:

```typescript
const {
  data,
  fetchNextPage,
  hasNextPage,
  isFetchingNextPage
} = useInfiniteQuery({
  queryKey: ['posts'],
  queryFn: ({ pageParam = 0 }) => fetchPosts({ page: pageParam }),
  getNextPageParam: (lastPage, pages) => lastPage.nextPage,
  // 메모리 절약을 위한 페이지 제한
  maxPages: 3,
  // 오래된 페이지 데이터 제거
  getPreviousPageParam: (firstPage, pages) => firstPage.prevPage
});
```

## 프로젝트 구조

### 권장 디렉토리 구조

```
src/
├── queries/              # 쿼리 팩토리 정의
│   ├── users.ts
│   ├── posts.ts
│   └── index.ts
├── hooks/               # 커스텀 훅
│   ├── useUser.ts
│   ├── usePosts.ts
│   └── index.ts
├── schemas/             # Zod 스키마 정의
│   ├── user.schema.ts
│   ├── post.schema.ts
│   └── index.ts
├── types/               # TypeScript 타입 정의
│   ├── api.types.ts
│   └── index.ts
└── utils/               # 유틸리티 함수
    ├── query-utils.ts
    └── index.ts
```

### 모듈화 예시

```typescript
// queries/users.ts
export const userQueries = {
  all: () => ['users'] as const,
  lists: () => [...userQueries.all(), 'list'] as const,
  list: (filters: UserFilters) => 
    [...userQueries.lists(), { filters }] as const,
  details: () => [...userQueries.all(), 'detail'] as const,
  detail: (id: string) => [...userQueries.details(), id] as const,
};

export const getUserFactory = createQueryFactory({
  schema: UserSchema,
  handler: async ({ params }: { params: { id: string } }) => {
    const response = await fetch(`/api/users/${params.id}`);
    return response.json();
  }
});

// hooks/useUser.ts
export function useUser(userId: string) {
  return useQuery(getUserFactory.query, {
    params: { id: userId },
    enabled: !!userId
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: updateUser,
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({
        queryKey: userQueries.detail(variables.id)
      });
    }
  });
}
```

## 보안 모범 사례

### API 인증

#### 1. 인터셉터를 통한 토큰 관리

```typescript
const fetcher = new NextTypeFetch({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  interceptors: {
    request: async (config) => {
      const token = await getAuthToken();
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    },
    response: async (response) => {
      if (response.status === 401) {
        await refreshToken();
        // 요청 재시도
      }
      return response;
    }
  }
});
```

#### 2. 민감한 데이터 처리

```typescript
// 민감한 데이터는 클라이언트 캐시에서 제외
const { data: sensitiveData } = useQuery({
  cacheKey: ['sensitive-data'],
  url: '/api/sensitive',
  schema: SensitiveDataSchema,
  cacheTime: 0, // 캐시하지 않음
  staleTime: 0, // 항상 fresh
  refetchOnWindowFocus: false // 포커스 시 재요청 방지
});
```

### 입력 검증

#### 1. 스키마를 통한 검증

```typescript
const CreateUserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8).regex(/[A-Z]/).regex(/[0-9]/),
  name: z.string().min(2).max(50)
});

const createUserMutation = useMutation({
  mutationFn: async (data: unknown) => {
    // 클라이언트 측 검증
    const validatedData = CreateUserSchema.parse(data);
    
    const response = await fetch('/api/users', {
      method: 'POST',
      body: JSON.stringify(validatedData)
    });
    
    return response.json();
  }
});
```

## 테스팅 가이드

### 쿼리 테스트

```typescript
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from 'next-unified-query';

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false }
    }
  });
  
  return ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('useUser', () => {
  it('사용자 데이터를 가져온다', async () => {
    const { result } = renderHook(() => useUser('123'), {
      wrapper: createWrapper()
    });
    
    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });
    
    expect(result.current.data).toEqual({
      id: '123',
      name: 'John Doe'
    });
  });
});
```

### Mutation 테스트

```typescript
describe('useUpdateUser', () => {
  it('사용자 정보를 업데이트한다', async () => {
    const { result } = renderHook(() => useUpdateUser(), {
      wrapper: createWrapper()
    });
    
    act(() => {
      result.current.mutate({
        id: '123',
        name: 'Jane Doe'
      });
    });
    
    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });
    
    expect(result.current.data).toEqual({
      id: '123',
      name: 'Jane Doe'
    });
  });
});
```

## 디버깅 팁

### React Query Devtools 활용

```tsx
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

function App() {
  return (
    <NextUnifiedQueryProvider>
      <YourApp />
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools initialIsOpen={false} />
      )}
    </NextUnifiedQueryProvider>
  );
}
```

### 로깅 설정

```typescript
const queryClient = new QueryClient({
  logger: {
    log: console.log,
    warn: console.warn,
    error: console.error,
  },
  defaultOptions: {
    queries: {
      onError: (error) => {
        console.error('Query error:', {
          error,
          stack: error.stack,
          timestamp: new Date().toISOString()
        });
      }
    }
  }
});
```

## 마이그레이션 가이드

다른 데이터 페칭 라이브러리에서 마이그레이션하는 방법은 [마이그레이션 가이드](/docs/migration-guides)를 참조하세요.

## 관련 문서

- [Factory 패턴](/docs/factory-patterns) - Factory 패턴 상세 가이드
- [TypeScript 타입 정의](/docs/api/types) - 타입 시스템 레퍼런스
- [성능 최적화](/docs/performance) - 성능 최적화 가이드
- [문제 해결](/docs/troubleshooting) - 일반적인 문제 해결 방법