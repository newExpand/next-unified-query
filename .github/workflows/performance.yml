name: Performance Monitoring

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    # ë§¤ì¼ ì˜¤ì „ 9ì‹œ (KST)
    - cron: '0 0 * * *'
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '9'

jobs:
  # 1. ë²ˆë“¤ í¬ê¸° ë¶„ì„
  bundle-analysis:
    name: Bundle Size Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build packages
        run: pnpm build

      - name: Analyze bundle size
        run: |
          # Create size report
          npx bundle-buddy packages/*/dist/**/*.js --json > bundle-report.json
          
          # Check size limits
          npx size-limit --json > size-limit-report.json

      - name: Upload bundle analysis
        uses: actions/upload-artifact@v3
        with:
          name: bundle-analysis
          path: |
            bundle-report.json
            size-limit-report.json
          retention-days: 30

      - name: Comment PR with size changes
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const sizeReport = JSON.parse(fs.readFileSync('size-limit-report.json', 'utf8'));
            
            let comment = '## ðŸ“¦ Bundle Size Report\n\n';
            comment += '| Package | Size | Limit | Status |\n';
            comment += '|---------|------|-------|--------|\n';
            
            for (const item of sizeReport) {
              const status = item.passed ? 'âœ…' : 'âŒ';
              comment += `| ${item.name} | ${item.size} | ${item.limit} | ${status} |\n`;
            }
            
            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Bundle Size Report')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

  # 2. ëŸ°íƒ€ìž„ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
  benchmark:
    name: Performance Benchmark
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build packages
        run: pnpm build

      - name: Run benchmarks
        run: |
          # Create benchmark script if not exists
          cat > benchmark.js << 'EOF'
          const { performance } = require('perf_hooks');
          const fs = require('fs');
          
          // Import packages
          const { QueryFetcher } = require('./packages/core/dist/index.js');
          const { createQueryFactory } = require('./packages/react/dist/index.js');
          
          // Benchmark results
          const results = {
            timestamp: new Date().toISOString(),
            benchmarks: []
          };
          
          // Benchmark 1: QueryFetcher instantiation
          {
            const iterations = 10000;
            const start = performance.now();
            for (let i = 0; i < iterations; i++) {
              new QueryFetcher();
            }
            const end = performance.now();
            results.benchmarks.push({
              name: 'QueryFetcher instantiation',
              iterations,
              totalTime: end - start,
              avgTime: (end - start) / iterations
            });
          }
          
          // Benchmark 2: Factory creation
          {
            const iterations = 10000;
            const start = performance.now();
            for (let i = 0; i < iterations; i++) {
              createQueryFactory(() => ({ data: 'test' }));
            }
            const end = performance.now();
            results.benchmarks.push({
              name: 'Factory creation',
              iterations,
              totalTime: end - start,
              avgTime: (end - start) / iterations
            });
          }
          
          // Save results
          fs.writeFileSync('benchmark-results.json', JSON.stringify(results, null, 2));
          console.log('Benchmark complete:', results);
          EOF
          
          node benchmark.js

      - name: Upload benchmark results
        uses: actions/upload-artifact@v3
        with:
          name: benchmark-results
          path: benchmark-results.json
          retention-days: 30

      - name: Store benchmark results
        uses: benchmark-action/github-action-benchmark@v1
        with:
          tool: 'customSmallerIsBetter'
          output-file-path: benchmark-results.json
          github-token: ${{ secrets.GITHUB_TOKEN }}
          auto-push: true
          comment-on-alert: true
          alert-threshold: '150%'
          fail-on-alert: true

  # 3. ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§
  memory-profile:
    name: Memory Profiling
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build packages
        run: pnpm build

      - name: Run memory profiling
        run: |
          # Create memory profile script
          cat > memory-profile.js << 'EOF'
          const v8 = require('v8');
          const fs = require('fs');
          
          // Force garbage collection if available
          if (global.gc) {
            global.gc();
          }
          
          // Get initial heap stats
          const initialHeap = v8.getHeapStatistics();
          
          // Import and use packages
          const { QueryFetcher } = require('./packages/core/dist/index.js');
          const { createQueryFactory } = require('./packages/react/dist/index.js');
          
          // Create many instances to test memory usage
          const instances = [];
          for (let i = 0; i < 1000; i++) {
            instances.push(new QueryFetcher());
            instances.push(createQueryFactory(() => ({ data: i })));
          }
          
          // Get heap stats after creating instances
          const afterCreationHeap = v8.getHeapStatistics();
          
          // Clear references
          instances.length = 0;
          
          // Force garbage collection if available
          if (global.gc) {
            global.gc();
          }
          
          // Get final heap stats
          const finalHeap = v8.getHeapStatistics();
          
          // Calculate memory usage
          const results = {
            timestamp: new Date().toISOString(),
            memory: {
              initial: {
                heapUsed: initialHeap.used_heap_size,
                heapTotal: initialHeap.total_heap_size
              },
              afterCreation: {
                heapUsed: afterCreationHeap.used_heap_size,
                heapTotal: afterCreationHeap.total_heap_size
              },
              final: {
                heapUsed: finalHeap.used_heap_size,
                heapTotal: finalHeap.total_heap_size
              },
              leaked: finalHeap.used_heap_size - initialHeap.used_heap_size
            }
          };
          
          fs.writeFileSync('memory-profile.json', JSON.stringify(results, null, 2));
          console.log('Memory profile complete:', results);
          
          // Check for memory leaks
          const leakThreshold = 1024 * 1024; // 1MB
          if (results.memory.leaked > leakThreshold) {
            console.error(`Memory leak detected: ${results.memory.leaked} bytes`);
            process.exit(1);
          }
          EOF
          
          node --expose-gc memory-profile.js

      - name: Upload memory profile
        uses: actions/upload-artifact@v3
        with:
          name: memory-profile
          path: memory-profile.json
          retention-days: 30

  # 4. Lighthouse CI
  lighthouse:
    name: Lighthouse Performance Test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build docs
        run: pnpm build:docs

      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v12
        with:
          configPath: './.lighthouserc.js'
          uploadArtifacts: true
          temporaryPublicStorage: true