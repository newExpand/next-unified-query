{"version":3,"sources":["../src/react.ts","../src/hooks/use-query.ts","../src/query-client-provider.tsx","../src/hooks/use-mutation.ts"],"sourcesContent":["// React Hooks\nexport { useQuery } from \"./hooks/use-query\";\nexport { useMutation } from \"./hooks/use-mutation\";\n\n// React Components & Context\nexport {\n  QueryClientProvider,\n  HydrationBoundary,\n  useQueryClient,\n} from \"./query-client-provider\";\n","import { useEffect, useRef, useSyncExternalStore, useCallback } from \"react\";\nimport type { ZodType } from \"zod/v4\";\nimport type { FetchConfig } from \"next-unified-query-core\";\nimport { isObject, has, isFunction } from \"es-toolkit/compat\";\nimport { useQueryClient } from \"../query-client-provider\";\nimport type { QueryConfig, ExtractParams } from \"next-unified-query-core\";\nimport { validateQueryConfig } from \"next-unified-query-core\";\nimport {\n  QueryObserver,\n  type QueryObserverOptions,\n  type QueryObserverResult,\n} from \"next-unified-query-core\";\n\n/**\n * 기본 UseQuery 옵션 (공통 속성)\n */\ninterface BaseUseQueryOptions<T = any> {\n  cacheKey: readonly unknown[];\n  params?: Record<string, any>;\n  schema?: ZodType;\n  fetchConfig?: Omit<FetchConfig, \"url\" | \"method\" | \"params\" | \"data\">;\n  enabled?: boolean;\n  staleTime?: number;\n  select?: (data: T) => any;\n  /**\n   * placeholderData: fetch 전 임시 데이터 또는 이전 데이터 유지\n   * 값 또는 함수(prevData, prevQuery) 모두 지원\n   * ReactNode(JSX)도 허용\n   */\n  placeholderData?:\n    | T\n    | React.ReactNode\n    | ((\n        prevData: T | React.ReactNode | undefined,\n        prevQuery?: any\n      ) => T | React.ReactNode);\n  /**\n   * gcTime: 쿼리 데이터가 사용되지 않을 때(구독자가 0이 될 때) 가비지 컬렉션까지의 시간(ms)\n   * 이는 생명주기 관리 전략으로, maxQueries(메모리 보호)와는 별개로 동작합니다.\n   * @default 300000 (5분)\n   */\n  gcTime?: number;\n}\n\n/**\n * URL 기반 UseQuery 옵션\n */\ninterface UrlBasedUseQueryOptions<T = any> extends BaseUseQueryOptions<T> {\n  /**\n   * API 요청 URL\n   */\n  url: string;\n\n  /**\n   * queryFn이 있으면 안됨 (상호 배제)\n   */\n  queryFn?: never;\n}\n\n/**\n * Custom Function 기반 UseQuery 옵션\n */\ninterface FunctionBasedUseQueryOptions<T = any> extends BaseUseQueryOptions<T> {\n  /**\n   * Custom query function for complex requests\n   */\n  queryFn: (params: any, fetcher: any) => Promise<any>;\n\n  /**\n   * url이 있으면 안됨 (상호 배제)\n   */\n  url?: never;\n}\n\n/**\n * UseQuery 옵션\n * URL 방식 또는 Custom Function 방식 중 하나를 선택할 수 있음\n */\nexport type UseQueryOptions<T = any> =\n  | UrlBasedUseQueryOptions<T>\n  | FunctionBasedUseQueryOptions<T>;\n\ntype UseQueryFactoryOptions<P, T> = Omit<\n  UseQueryOptions<T>,\n  \"cacheKey\" | \"url\" | \"queryFn\" | \"params\" | \"schema\" | \"fetchConfig\"\n> &\n  (P extends void\n    ? { params?: P }\n    : keyof P extends never\n    ? { params?: P }\n    : { params: P });\n\n// 1. Factory-based: useQuery<T>(query, options)\nexport function useQuery<T = unknown, E = unknown>(\n  query: QueryConfig<any, any>,\n  options: UseQueryFactoryOptions<ExtractParams<typeof query>, T>\n): QueryObserverResult<T, E>;\n\n// 2. Options-based: useQuery<T>(options)\nexport function useQuery<T = unknown, E = unknown>(\n  options: UseQueryOptions<T>\n): QueryObserverResult<T, E>;\n\n// Implementation\nexport function useQuery(arg1: any, arg2?: any): any {\n  // QueryConfig 기반\n  if (\n    isObject(arg1) &&\n    has(arg1, \"cacheKey\") &&\n    isFunction((arg1 as QueryConfig<any, any>).cacheKey)\n  ) {\n    const query = arg1 as QueryConfig<any, any>;\n\n    // QueryConfig 런타임 검증\n    validateQueryConfig(query);\n\n    const options = arg2 ?? {};\n    const params = options.params;\n    const cacheKey = query.cacheKey?.(params);\n    const url = query.url?.(params);\n    const queryFn = query.queryFn;\n    const schema = query.schema;\n    const placeholderData = options.placeholderData ?? query.placeholderData;\n    const fetchConfig = options.fetchConfig ?? query.fetchConfig;\n    const select = options.select ?? query.select;\n    const enabled = has(options, \"enabled\")\n      ? options.enabled // 명시적으로 전달된 경우 해당 값 사용\n      : isFunction(query.enabled)\n      ? query.enabled(params) // Factory의 enabled 함수 호출\n      : query.enabled; // Factory의 enabled 불린 값 사용\n\n    return _useQueryObserver({\n      ...query,\n      ...options,\n      enabled,\n      cacheKey,\n      url,\n      queryFn,\n      params,\n      schema,\n      placeholderData,\n      fetchConfig,\n      select,\n    });\n  }\n  // 명시적 타입 지정 방식\n  return _useQueryObserver({\n    ...arg1,\n  });\n}\n\nfunction _useQueryObserver<T = unknown, E = unknown>(\n  options: UseQueryOptions<T>\n): QueryObserverResult<T, E> {\n  // UseQueryOptions 런타임 검증 (factory의 validateQueryConfig 사용)\n  validateQueryConfig(options);\n\n  const queryClient = useQueryClient();\n  const observerRef = useRef<QueryObserver<T, E> | undefined>(undefined);\n  const optionsHashRef = useRef<string>(\"\");\n\n  // 기본 결과 객체를 캐싱하여 안정적인 참조 제공\n  const defaultResultRef = useRef<QueryObserverResult<T, E>>({\n    data: undefined,\n    error: undefined,\n    isLoading: true,\n    isFetching: true,\n    isError: false,\n    isSuccess: false,\n    isStale: true,\n    isPlaceholderData: false,\n    refetch: () => {},\n  });\n\n  // 옵션을 해시로 변환 (함수 제외)\n  const createOptionsHash = (opts: UseQueryOptions<T>): string => {\n    const hashableOptions = {\n      cacheKey: opts.cacheKey,\n      url: opts.url,\n      params: opts.params,\n      enabled: opts.enabled,\n      staleTime: opts.staleTime,\n      gcTime: opts.gcTime,\n      // queryFn, select, placeholderData 등 함수들은 해시에서 제외 (항상 새로 생성되므로)\n    };\n    return JSON.stringify(hashableOptions);\n  };\n\n  const currentHash = createOptionsHash(options);\n  const shouldUpdate =\n    !observerRef.current || optionsHashRef.current !== currentHash;\n\n  // Observer 생성 또는 옵션 업데이트 (렌더링 중 직접 처리)\n  if (!observerRef.current) {\n    observerRef.current = new QueryObserver<T, E>(queryClient, {\n      ...options,\n      key: options.cacheKey,\n    } as QueryObserverOptions<T>);\n    optionsHashRef.current = currentHash;\n  } else if (shouldUpdate) {\n    // 렌더링 중에 직접 업데이트\n    observerRef.current.setOptions({\n      ...options,\n      key: options.cacheKey,\n    } as QueryObserverOptions<T>);\n    optionsHashRef.current = currentHash;\n  }\n\n  // 안정적인 subscribe 함수\n  const subscribe = useCallback((callback: () => void) => {\n    return observerRef.current!.subscribe(callback);\n  }, []);\n\n  // 최적화된 getSnapshot 함수\n  const getSnapshot = useCallback(() => {\n    if (!observerRef.current) {\n      // Observer가 없는 경우 캐시된 기본 결과 반환\n      return defaultResultRef.current;\n    }\n\n    // QueryObserver에서 이미 Tracked Properties와 Structural Sharing이 처리됨\n    // 추가적인 비교 없이 결과를 그대로 반환\n    return observerRef.current.getCurrentResult();\n  }, []);\n\n  // useSyncExternalStore로 Observer 구독\n  const result = useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getSnapshot // getServerSnapshot도 동일하게\n  );\n\n  // 컴포넌트 언마운트 시 Observer 정리\n  useEffect(() => {\n    return () => {\n      observerRef.current?.destroy();\n    };\n  }, []);\n\n  return result;\n}\n","import React, { createContext, useContext, useRef } from \"react\";\nimport type { ReactNode } from \"react\";\nimport type { QueryClient, QueryState, QueryClientOptionsWithInterceptors, InterceptorSetupFunction } from \"next-unified-query-core\";\nimport { getQueryClient } from \"next-unified-query-core\";\n\nconst QueryClientContext = createContext<QueryClient | null>(null);\n\nexport function HydrationBoundary({\n  state,\n  children,\n}: {\n  state?: Record<string, QueryState>;\n  children: ReactNode;\n}) {\n  const client = useQueryClient();\n  const hydratedRef = useRef(false);\n\n  // 한 번만 hydration 수행\n  if (state && !hydratedRef.current) {\n    client.hydrate(state);\n    hydratedRef.current = true;\n  }\n\n  return <>{children}</>;\n}\n\nexport interface QueryClientProviderProps {\n  /**\n   * QueryClient 인스턴스 (선택사항)\n   * 제공하지 않으면 자동으로 환경에 맞는 인스턴스를 생성합니다.\n   */\n  client?: QueryClient;\n  /**\n   * QueryClient 옵션 (client가 제공되지 않은 경우에만 사용)\n   */\n  options?: QueryClientOptionsWithInterceptors;\n  /**\n   * 인터셉터 설정 함수 (client가 제공되지 않은 경우에만 사용)\n   * options.setupInterceptors보다 우선순위가 높습니다.\n   */\n  setupInterceptors?: InterceptorSetupFunction;\n  children: ReactNode;\n}\n\nexport function QueryClientProvider({\n  client,\n  options,\n  setupInterceptors,\n  children,\n}: QueryClientProviderProps) {\n  // client가 제공되지 않으면 자동으로 생성\n  const queryClient =\n    client ||\n    getQueryClient({\n      ...options,\n      setupInterceptors: setupInterceptors || options?.setupInterceptors,\n    });\n\n  return (\n    <QueryClientContext.Provider value={queryClient}>\n      {children}\n    </QueryClientContext.Provider>\n  );\n}\n\nexport function useQueryClient(): QueryClient {\n  const ctx = useContext(QueryClientContext);\n  if (!ctx)\n    throw new Error(\n      \"You must wrap your component tree with <QueryClientProvider>.\"\n    );\n  return ctx;\n}\n","import { useReducer, useCallback, useRef } from \"react\";\nimport type {\n  FetchError,\n  HttpMethod,\n  RequestConfig,\n  QueryKey,\n  NextTypeFetch,\n} from \"next-unified-query-core\";\nimport { useQueryClient } from \"../query-client-provider\";\nimport type {\n  MutationConfig,\n  ExtractMutationVariables,\n  ExtractMutationData,\n  ExtractMutationError,\n} from \"next-unified-query-core\";\nimport { validateMutationConfig } from \"next-unified-query-core\";\nimport { z, ZodType } from \"zod/v4\";\nimport { merge, isArray, isFunction } from \"es-toolkit/compat\";\n\nexport interface MutationState<\n  TData = unknown,\n  TError = FetchError,\n  TVariables = void\n> {\n  data: TData | undefined;\n  error: TError | null;\n  isPending: boolean;\n  isSuccess: boolean;\n  isError: boolean;\n}\n\nexport interface UseMutationOptions<\n  TData = unknown,\n  TError = FetchError,\n  TVariables = void,\n  TContext = unknown\n> {\n  mutationFn: (variables: TVariables, fetcher: NextTypeFetch) => Promise<TData>; // fetcher를 두 번째 인자로 제공\n  cacheKey?: QueryKey;\n  onMutate?: (\n    variables: TVariables\n  ) => Promise<TContext | void> | TContext | void;\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext | undefined\n  ) => Promise<void> | void;\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined\n  ) => Promise<void> | void;\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined\n  ) => Promise<void> | void;\n  invalidateQueries?:\n    | QueryKey[]\n    | ((\n        data: TData,\n        variables: TVariables,\n        context: TContext | undefined\n      ) => QueryKey[]);\n  // 추가적인 fetchConfig 등은 MutationConfig에서 올 수 있음\n  fetchConfig?: Omit<\n    RequestConfig,\n    \"url\" | \"method\" | \"params\" | \"data\" | \"schema\"\n  >;\n  requestSchema?: ZodType;\n  responseSchema?: ZodType;\n}\n\nexport interface UseMutationResult<\n  TData = unknown,\n  TError = FetchError,\n  TVariables = void\n  // TContext = unknown, // Result에서는 TContext가 직접적으로 노출될 필요는 없을 수 있음\n> extends MutationState<TData, TError, TVariables> {\n  mutate: (\n    variables: TVariables,\n    options?: {\n      onSuccess?: (data: TData, variables: TVariables, context: any) => void; // TContext를 any로 단순화 또는 제거 고려\n      onError?: (error: TError, variables: TVariables, context: any) => void;\n      onSettled?: (\n        data: TData | undefined,\n        error: TError | null,\n        variables: TVariables,\n        context: any\n      ) => void;\n    }\n  ) => void;\n  mutateAsync: (\n    variables: TVariables,\n    options?: {\n      onSuccess?: (data: TData, variables: TVariables, context: any) => void;\n      onError?: (error: TError, variables: TVariables, context: any) => void;\n      onSettled?: (\n        data: TData | undefined,\n        error: TError | null,\n        variables: TVariables,\n        context: any\n      ) => void;\n    }\n  ) => Promise<TData>;\n  reset: () => void;\n}\n\ntype MutationAction<TData, TError, TVariables> =\n  | { type: \"MUTATE\"; variables: TVariables }\n  | { type: \"SUCCESS\"; data: TData }\n  | { type: \"ERROR\"; error: TError }\n  | { type: \"RESET\" };\n\nconst getInitialState = <TData, TError, TVariables>(): MutationState<\n  TData,\n  TError,\n  TVariables\n> => ({\n  data: undefined,\n  error: null,\n  isPending: false,\n  isSuccess: false,\n  isError: false,\n});\n\n/**\n * 옵션 기반 사용법인지 확인하는 타입 가드\n */\nfunction isOptionsBasedUsage(\n  arg: any\n): arg is UseMutationOptions<any, any, any, any> {\n  return isFunction(arg.mutationFn) && !arg.url && !arg.method;\n}\n\n/**\n * 팩토리 설정의 유효성을 검증 (factory의 validateMutationConfig 사용)\n */\nfunction validateFactoryConfig(\n  config: MutationConfig<any, any, any, any, any, any>\n): void {\n  validateMutationConfig(config);\n}\n\n/**\n * 요청 데이터의 스키마 검증을 수행\n */\nfunction validateRequestData(data: any, schema?: ZodType): any {\n  if (!schema) return data;\n\n  try {\n    return schema.parse(data);\n  } catch (e) {\n    if (e instanceof z.ZodError) {\n      const zodErr = e as z.ZodError;\n      const validationError = new Error(\n        `Request validation failed: ${zodErr.issues\n          .map((issue) => issue.message)\n          .join(\", \")}`\n      ) as any;\n      validationError.isValidationError = true;\n      validationError.details = zodErr.issues;\n      throw validationError;\n    }\n    throw e;\n  }\n}\n\n/**\n * URL + Method 기반의 자동 mutation 함수 생성\n */\nfunction createUrlBasedMutationFn(\n  config: MutationConfig<any, any, any, any, any, any>\n): (variables: any, fetcher: NextTypeFetch) => Promise<any> {\n  return async (variables: any, fetcher: NextTypeFetch) => {\n    const url = isFunction(config.url) ? config.url(variables) : config.url;\n    const method = config.method;\n\n    const dataForRequest = validateRequestData(variables, config.requestSchema);\n\n    const requestConfig: RequestConfig = merge(\n      { schema: config.responseSchema },\n      config.fetchConfig || {},\n      {\n        url,\n        method: method as HttpMethod,\n        data: dataForRequest,\n      }\n    );\n\n    const response = await fetcher.request(requestConfig);\n    return response.data;\n  };\n}\n\n/**\n * 팩토리 설정에서 mutation 함수 추출\n */\nfunction extractMutationFnFromFactory(\n  config: MutationConfig<any, any, any, any, any, any>\n): (variables: any, fetcher: NextTypeFetch) => Promise<any> {\n  validateFactoryConfig(config);\n\n  if (isFunction(config.mutationFn)) {\n    return config.mutationFn;\n  }\n\n  return createUrlBasedMutationFn(config);\n}\n\n/**\n * 팩토리 기반 설정을 UseMutationOptions로 변환\n */\nfunction convertFactoryToOptions(\n  factoryConfig: MutationConfig<any, any, any, any, any, any>,\n  overrideOptions: any = {}\n): UseMutationOptions<any, any, any, any> {\n  const mutationFn = extractMutationFnFromFactory(factoryConfig);\n\n  return merge({}, factoryConfig, overrideOptions, {\n    mutationFn,\n  });\n}\n\n/**\n * 쿼리 무효화 처리\n */\nasync function handleInvalidateQueries(\n  invalidateQueriesOption: any,\n  data: any,\n  variables: any,\n  context: any,\n  queryClient: ReturnType<typeof useQueryClient>\n): Promise<void> {\n  if (!invalidateQueriesOption) return;\n\n  let keysToInvalidate: QueryKey[];\n\n  if (isFunction(invalidateQueriesOption)) {\n    keysToInvalidate = invalidateQueriesOption(\n      data,\n      variables,\n      context\n    ) as QueryKey[];\n  } else {\n    keysToInvalidate = invalidateQueriesOption as QueryKey[];\n  }\n\n  if (isArray(keysToInvalidate)) {\n    keysToInvalidate.forEach((queryKey) => {\n      queryClient.invalidateQueries(queryKey);\n    });\n  }\n}\n\n/**\n * Success 시 콜백들을 실행\n */\nasync function executeSuccessCallbacks<TData, TVariables, TContext>(\n  data: TData,\n  variables: TVariables,\n  context: TContext | undefined,\n  options: {\n    hookOnSuccess?: (\n      data: TData,\n      variables: TVariables,\n      context: TContext | undefined\n    ) => Promise<void> | void;\n    localOnSuccess?: (\n      data: TData,\n      variables: TVariables,\n      context: TContext | undefined\n    ) => void;\n  }\n): Promise<void> {\n  if (options.hookOnSuccess) {\n    await options.hookOnSuccess(data, variables, context);\n  }\n  if (options.localOnSuccess) {\n    options.localOnSuccess(data, variables, context);\n  }\n}\n\n/**\n * Error 시 콜백들을 실행\n */\nasync function executeErrorCallbacks<TError, TVariables, TContext>(\n  error: TError,\n  variables: TVariables,\n  context: TContext | undefined,\n  options: {\n    hookOnError?: (\n      error: TError,\n      variables: TVariables,\n      context: TContext | undefined\n    ) => Promise<void> | void;\n    localOnError?: (\n      error: TError,\n      variables: TVariables,\n      context: TContext | undefined\n    ) => void;\n  }\n): Promise<void> {\n  if (options.hookOnError) {\n    await options.hookOnError(error, variables, context);\n  }\n  if (options.localOnError) {\n    options.localOnError(error, variables, context);\n  }\n}\n\n/**\n * Settled 시 콜백들을 실행\n */\nasync function executeSettledCallbacks<TData, TError, TVariables, TContext>(\n  data: TData | undefined,\n  error: TError | null,\n  variables: TVariables,\n  context: TContext | undefined,\n  options: {\n    hookOnSettled?: (\n      data: TData | undefined,\n      error: TError | null,\n      variables: TVariables,\n      context: TContext | undefined\n    ) => Promise<void> | void;\n    localOnSettled?: (\n      data: TData | undefined,\n      error: TError | null,\n      variables: TVariables,\n      context: TContext | undefined\n    ) => void;\n  }\n): Promise<void> {\n  if (options.hookOnSettled) {\n    await options.hookOnSettled(data, error, variables, context);\n  }\n  if (options.localOnSettled) {\n    options.localOnSettled(data, error, variables, context);\n  }\n}\n\n// 팩토리 기반 오버로드\nexport function useMutation<\n  MC extends MutationConfig<any, any, any, any, any, any>,\n  TVariables = ExtractMutationVariables<MC>,\n  TData = ExtractMutationData<MC>,\n  TError = ExtractMutationError<MC>,\n  TContext = MC extends MutationConfig<any, any, any, infer C, any, any>\n    ? C\n    : unknown\n>(\n  mutationConfig: MC,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    | \"mutationFn\"\n    | \"cacheKey\"\n    | \"fetchConfig\"\n    | \"requestSchema\"\n    | \"responseSchema\"\n  >\n): UseMutationResult<TData, TError, TVariables>;\n\n// 옵션 객체 기반 오버로드\nexport function useMutation<\n  TData = unknown,\n  TError = FetchError,\n  TVariables = void,\n  TContext = unknown\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>\n): UseMutationResult<TData, TError, TVariables>;\n\n// 실제 구현\nexport function useMutation(\n  arg1: any, // MutationConfig | UseMutationOptions\n  arg2?: any // UseMutationOptions (팩토리 사용 시)\n): UseMutationResult<any, any, any> {\n  const queryClient = useQueryClient();\n\n  let combinedOptions: UseMutationOptions<any, any, any, any>;\n\n  if (isOptionsBasedUsage(arg1)) {\n    // 옵션 객체 기반 시나리오\n    combinedOptions = arg1;\n  } else {\n    // 팩토리 기반 시나리오\n    combinedOptions = convertFactoryToOptions(arg1, arg2);\n  }\n\n  return _useMutationInternal(combinedOptions, queryClient);\n}\n\n// 내부 구현 함수\nfunction _useMutationInternal<\n  TData = unknown,\n  TError = FetchError,\n  TVariables = void,\n  TContext = unknown\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient: ReturnType<typeof useQueryClient>\n): UseMutationResult<TData, TError, TVariables> {\n  const fetcher = queryClient.getFetcher();\n\n  const [state, dispatch] = useReducer(\n    (\n      prevState: MutationState<TData, TError, TVariables>,\n      action: MutationAction<TData, TError, TVariables>\n    ): MutationState<TData, TError, TVariables> => {\n      switch (action.type) {\n        case \"MUTATE\":\n          return {\n            ...prevState,\n            isPending: true,\n            isSuccess: false,\n            isError: false,\n            error: null,\n          };\n        case \"SUCCESS\":\n          return {\n            ...prevState,\n            isPending: false,\n            isSuccess: true,\n            isError: false,\n            data: action.data,\n            error: null,\n          };\n        case \"ERROR\":\n          return {\n            ...prevState,\n            isPending: false,\n            isSuccess: false,\n            isError: true,\n            error: action.error,\n          };\n        case \"RESET\":\n          return getInitialState();\n        default:\n          return prevState;\n      }\n    },\n    getInitialState<TData, TError, TVariables>()\n  );\n\n  const latestOptions = useRef(options);\n  latestOptions.current = options;\n\n  const mutateCallback = useCallback(\n    async (\n      variables: TVariables,\n      mutateLocalOptions?: {\n        onSuccess?: (\n          data: TData,\n          variables: TVariables,\n          context: TContext | undefined\n        ) => void;\n        onError?: (\n          error: TError,\n          variables: TVariables,\n          context: TContext | undefined\n        ) => void;\n        onSettled?: (\n          data: TData | undefined,\n          error: TError | null,\n          variables: TVariables,\n          context: TContext | undefined\n        ) => void;\n      }\n    ): Promise<TData> => {\n      dispatch({ type: \"MUTATE\", variables });\n      let context: TContext | void | undefined;\n\n      try {\n        // onMutate 콜백\n        const onMutateCb = latestOptions.current.onMutate;\n        if (onMutateCb) {\n          context = await onMutateCb(variables);\n        }\n\n        // 실제 mutation 함수 실행 - fetcher를 두 번째 인자로 전달\n        const data = await latestOptions.current.mutationFn(variables, fetcher);\n        dispatch({ type: \"SUCCESS\", data });\n\n        // onSuccess 콜백 (둘 다 실행: 훅 → mutate 옵션)\n        await executeSuccessCallbacks(data, variables, context as TContext, {\n          hookOnSuccess: latestOptions.current.onSuccess,\n          localOnSuccess: mutateLocalOptions?.onSuccess,\n        });\n\n        // invalidateQueries 처리\n        await handleInvalidateQueries(\n          latestOptions.current.invalidateQueries,\n          data,\n          variables,\n          context as TContext,\n          queryClient\n        );\n\n        // onSettled 콜백 (둘 다 실행: 훅 → mutate 옵션)\n        await executeSettledCallbacks(\n          data,\n          null,\n          variables,\n          context as TContext,\n          {\n            hookOnSettled: latestOptions.current.onSettled,\n            localOnSettled: mutateLocalOptions?.onSettled,\n          }\n        );\n\n        return data;\n      } catch (err) {\n        const error = err as TError;\n        dispatch({ type: \"ERROR\", error });\n\n        // onError 콜백 (둘 다 실행: 훅 → mutate 옵션)\n        await executeErrorCallbacks(error, variables, context as TContext, {\n          hookOnError: latestOptions.current.onError,\n          localOnError: mutateLocalOptions?.onError,\n        });\n\n        // onSettled 콜백 (둘 다 실행: 훅 → mutate 옵션)\n        await executeSettledCallbacks(\n          undefined,\n          error,\n          variables,\n          context as TContext,\n          {\n            hookOnSettled: latestOptions.current.onSettled,\n            localOnSettled: mutateLocalOptions?.onSettled,\n          }\n        );\n\n        throw error;\n      }\n    },\n    [queryClient, fetcher]\n  );\n\n  const mutate = (\n    variables: TVariables,\n    options?: {\n      onSuccess?: (\n        data: TData,\n        variables: TVariables,\n        context: TContext | undefined\n      ) => void;\n      onError?: (\n        error: TError,\n        variables: TVariables,\n        context: TContext | undefined\n      ) => void;\n      onSettled?: (\n        data: TData | undefined,\n        error: TError | null,\n        variables: TVariables,\n        context: TContext | undefined\n      ) => void;\n    }\n  ) => {\n    mutateCallback(variables, options).catch(() => {\n      // mutateAsync에서 에러를 처리하므로, 여기서는 특별한 처리를 하지 않음\n    });\n  };\n\n  const mutateAsync = useCallback(\n    (\n      variables: TVariables,\n      options?: {\n        onSuccess?: (\n          data: TData,\n          variables: TVariables,\n          context: TContext | undefined\n        ) => void;\n        onError?: (\n          error: TError,\n          variables: TVariables,\n          context: TContext | undefined\n        ) => void;\n        onSettled?: (\n          data: TData | undefined,\n          error: TError | null,\n          variables: TVariables,\n          context: TContext | undefined\n        ) => void;\n      }\n    ): Promise<TData> => {\n      return mutateCallback(variables, options);\n    },\n    [mutateCallback]\n  );\n\n  const reset = useCallback(() => {\n    dispatch({ type: \"RESET\" });\n  }, []);\n\n  return { ...state, mutate, mutateAsync, reset };\n}\n"],"mappings":"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","names":["import_react","React","import_next_unified_query_core","import_react","import_next_unified_query_core","import_compat","options"]}