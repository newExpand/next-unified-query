{"version":3,"sources":["../src/index.ts","../../../node_modules/.pnpm/quick-lru@7.0.1/node_modules/quick-lru/index.js","../../core/src/types/index.ts","../../core/src/interceptors.ts","../../core/src/utils/url.ts","../../core/src/utils/config.ts","../../core/src/utils/data.ts","../../core/src/utils/timeout.ts","../../core/src/utils/response.ts","../../core/src/utils/error.ts","../../core/src/core/request.ts","../../core/src/methods/index.ts","../../core/src/core/client.ts","../../core/src/fetch.ts","../../core/src/query/factories/query-factory.ts","../../core/src/query/factories/mutation-factory.ts","../../core/src/query/cache/query-cache.ts","../../core/src/query/client/query-client.ts","../../core/src/query/client/query-client-manager.ts","../../core/src/query/observer/utils/structural-sharing.ts","../../core/src/query/observer/utils/tracked-result.ts","../../core/src/query/observer/managers/fetch-manager.ts","../../core/src/query/observer/managers/options-manager.ts","../../core/src/query/observer/managers/placeholder-manager.ts","../../core/src/query/observer/managers/result-computer.ts","../../core/src/query/observer/query-observer.ts","../../core/src/query/ssr/ssr-prefetch.ts"],"sourcesContent":["// Default export - Server-safe exports from core\nexport * from \"next-unified-query-core\";","export default class QuickLRU extends Map {\n\t#size = 0;\n\t#cache = new Map();\n\t#oldCache = new Map();\n\t#maxSize;\n\t#maxAge;\n\t#onEviction;\n\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\tthis.#maxSize = options.maxSize;\n\t\tthis.#maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.#onEviction = options.onEviction;\n\t}\n\n\t// For tests.\n\tget __oldCache() {\n\t\treturn this.#oldCache;\n\t}\n\n\t#emitEvictions(cache) {\n\t\tif (typeof this.#onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.#onEviction(key, item.value);\n\t\t}\n\t}\n\n\t#deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.#onEviction === 'function') {\n\t\t\t\tthis.#onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t#getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this.#deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t#getItemValue(key, item) {\n\t\treturn item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t#peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this.#getItemValue(key, item);\n\t}\n\n\t#set(key, value) {\n\t\tthis.#cache.set(key, value);\n\t\tthis.#size++;\n\n\t\tif (this.#size >= this.#maxSize) {\n\t\t\tthis.#size = 0;\n\t\t\tthis.#emitEvictions(this.#oldCache);\n\t\t\tthis.#oldCache = this.#cache;\n\t\t\tthis.#cache = new Map();\n\t\t}\n\t}\n\n\t#moveToRecent(key, item) {\n\t\tthis.#oldCache.delete(key);\n\t\tthis.#set(key, item);\n\t}\n\n\t* #entriesAscending() {\n\t\tfor (const item of this.#oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.#cache.has(key)) {\n\t\t\t\tconst deleted = this.#deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.#cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this.#deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.#cache.has(key)) {\n\t\t\tconst item = this.#cache.get(key);\n\t\t\treturn this.#getItemValue(key, item);\n\t\t}\n\n\t\tif (this.#oldCache.has(key)) {\n\t\t\tconst item = this.#oldCache.get(key);\n\t\t\tif (this.#deleteIfExpired(key, item) === false) {\n\t\t\t\tthis.#moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.#maxAge} = {}) {\n\t\tconst expiry = typeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY\n\t\t\t? (Date.now() + maxAge)\n\t\t\t: undefined;\n\n\t\tif (this.#cache.has(key)) {\n\t\t\tthis.#cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry,\n\t\t\t});\n\t\t} else {\n\t\t\tthis.#set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.#cache.has(key)) {\n\t\t\treturn !this.#deleteIfExpired(key, this.#cache.get(key));\n\t\t}\n\n\t\tif (this.#oldCache.has(key)) {\n\t\t\treturn !this.#deleteIfExpired(key, this.#oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.#cache.has(key)) {\n\t\t\treturn this.#peek(key, this.#cache);\n\t\t}\n\n\t\tif (this.#oldCache.has(key)) {\n\t\t\treturn this.#peek(key, this.#oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.#cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis.#size--;\n\t\t}\n\n\t\treturn this.#oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.#cache.clear();\n\t\tthis.#oldCache.clear();\n\t\tthis.#size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this.#entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.#cache = new Map(items);\n\t\t\tthis.#oldCache = new Map();\n\t\t\tthis.#size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis.#emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.#oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.#cache = new Map();\n\t\t\tthis.#size = 0;\n\t\t}\n\n\t\tthis.#maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.#cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this.#deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.#oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.#cache.has(key)) {\n\t\t\t\tconst deleted = this.#deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.#cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this.#deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.#oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.#cache.has(key)) {\n\t\t\t\tconst deleted = this.#deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this.#entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this.#size) {\n\t\t\treturn this.#oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.#oldCache.keys()) {\n\t\t\tif (!this.#cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this.#size + oldCacheSize, this.#maxSize);\n\t}\n\n\tget maxSize() {\n\t\treturn this.#maxSize;\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'QuickLRU';\n\t}\n\n\ttoString() {\n\t\treturn `QuickLRU(${this.size}/${this.maxSize})`;\n\t}\n\n\t[Symbol.for('nodejs.util.inspect.custom')]() {\n\t\treturn this.toString();\n\t}\n}\n","import type { z } from \"zod/v4\";\n\n/**\n * 컨텐츠 타입 열거형\n */\nexport enum ContentType {\n  /**\n   * JSON 데이터 (application/json)\n   */\n  JSON = \"application/json\",\n\n  /**\n   * URL 인코딩된 폼 데이터 (application/x-www-form-urlencoded)\n   */\n  FORM = \"application/x-www-form-urlencoded\",\n\n  /**\n   * 일반 텍스트 (text/plain)\n   */\n  TEXT = \"text/plain\",\n\n  /**\n   * 바이너리 데이터 (application/octet-stream)\n   */\n  BLOB = \"application/octet-stream\",\n\n  /**\n   * 멀티파트 폼 데이터 (multipart/form-data)\n   */\n  MULTIPART = \"multipart/form-data\",\n\n  /**\n   * XML 문서 (application/xml)\n   */\n  XML = \"application/xml\",\n\n  /**\n   * HTML 문서 (text/html)\n   */\n  HTML = \"text/html\",\n}\n\n/**\n * 응답 타입 열거형\n */\nexport enum ResponseType {\n  /**\n   * JSON 응답 (자동 파싱)\n   */\n  JSON = \"json\",\n\n  /**\n   * 텍스트 응답 (text/plain, HTML, XML 등)\n   */\n  TEXT = \"text\",\n\n  /**\n   * Blob 응답 (이미지, 파일 등 바이너리 데이터)\n   */\n  BLOB = \"blob\",\n\n  /**\n   * ArrayBuffer 응답 (바이너리 데이터)\n   */\n  ARRAY_BUFFER = \"arraybuffer\",\n\n  /**\n   * 원시 응답 (Response 객체 그대로 반환)\n   */\n  RAW = \"raw\",\n}\n\n/**\n * HTTP 메서드 타입\n */\nexport type HttpMethod =\n  | \"GET\"\n  | \"POST\"\n  | \"PUT\"\n  | \"DELETE\"\n  | \"PATCH\"\n  | \"HEAD\"\n  | \"OPTIONS\";\n\n/**\n * HTTP 에러 클래스\n */\nexport class FetchError extends Error {\n  /**\n   * 에러 이름\n   */\n  name = \"FetchError\";\n\n  /**\n   * 에러 코드\n   */\n  code?: string;\n\n  /**\n   * 응답 정보 (HTTP 에러인 경우)\n   */\n  response?: {\n    data: unknown;\n    status: number;\n    statusText: string;\n    headers: Headers;\n  };\n\n  /**\n   * 요청 객체\n   */\n  request?: Request;\n\n  /**\n   * 요청 설정\n   */\n  config: RequestConfig;\n\n  /**\n   * FetchError 생성자\n   * @param message 에러 메시지\n   * @param config 요청 설정\n   * @param code 에러 코드\n   * @param request 요청 객체\n   * @param response 응답 객체\n   * @param responseData 응답 데이터\n   */\n  constructor(\n    message: string,\n    config: RequestConfig,\n    code?: string,\n    request?: Request,\n    response?: Response,\n    responseData?: unknown\n  ) {\n    super(message);\n    this.config = config;\n    this.code = code;\n    this.request = request;\n\n    if (response) {\n      this.response = {\n        data: responseData,\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n      };\n    }\n  }\n}\n\n/**\n * 401 인증 오류 자동 재시도 옵션\n */\nexport interface AuthRetryOption {\n  /**\n   * 최대 재시도 횟수 (기본값: 1)\n   */\n  limit?: number;\n  /**\n   * 재시도할 HTTP 상태 코드 목록 (기본값: [401])\n   * 커스텀 상태 코드(예: 401004 등)도 지정 가능\n   */\n  statusCodes?: number[];\n  /**\n   * 재시도 전 실행할 핸들러 (true 반환 시 재시도)\n   */\n  handler: (error: FetchError, config: RequestConfig) => Promise<boolean>;\n  /**\n   * 커스텀 재시도 조건 함수 (true 반환 시 handler 실행)\n   * 상태코드 외에 추가 조건이 필요할 때 사용\n   */\n  shouldRetry?: (error: FetchError, config: RequestConfig) => boolean;\n}\n\n/**\n * 기본 설정 옵션 인터페이스\n */\nexport interface FetchConfig\n  extends Omit<RequestInit, \"signal\" | \"headers\" | \"body\" | \"method\"> {\n  /**\n   * 기본 URL\n   */\n  baseURL?: string;\n\n  /**\n   * 요청 타임아웃 (ms)\n   */\n  timeout?: number;\n\n  /**\n   * 요청 헤더\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * 요청 쿼리 파라미터\n   */\n  params?: Record<string, string | number | boolean | undefined | null>;\n\n  /**\n   * 자동 재시도 설정\n   */\n  retry?:\n    | number\n    | {\n        limit: number; // 최대 재시도 횟수\n        statusCodes?: number[]; // 재시도할 상태 코드\n        backoff?: \"linear\" | \"exponential\" | ((retryCount: number) => number);\n      };\n\n  /**\n   * 응답을 JSON으로 파싱 여부\n   * @deprecated responseType을 사용하세요\n   */\n  parseJSON?: boolean;\n\n  /**\n   * 응답 데이터 검증을 위한 Zod 스키마\n   */\n  schema?: z.ZodType;\n\n  /**\n   * Next.js fetch 옵션\n   */\n  next?: {\n    /**\n     * 재검증 시간(초)\n     */\n    revalidate?: number | false;\n    /**\n     * 태그 기반 재검증을 위한 태그 배열\n     */\n    tags?: string[];\n  };\n\n  /**\n   * 요청 취소를 위한 AbortSignal\n   * 외부에서 AbortController를 통해 요청을 취소할 수 있습니다.\n   */\n  signal?: AbortSignal;\n\n  /**\n   * 컨텐츠 타입 설정\n   * 요청 본문의 Content-Type을 지정합니다.\n   */\n  contentType?: ContentType | string;\n\n  /**\n   * 응답 타입 설정\n   * 서버 응답을 어떻게 파싱할지 지정합니다.\n   */\n  responseType?: ResponseType;\n\n  /**\n   * 401 인증 오류 자동 재시도 옵션\n   */\n  authRetry?: AuthRetryOption;\n}\n\n/**\n * 특정 요청에 대한 설정 인터페이스\n */\nexport interface RequestConfig extends FetchConfig {\n  /**\n   * 요청 URL\n   */\n  url?: string;\n\n  /**\n   * HTTP 메서드\n   */\n  method?: HttpMethod;\n\n  /**\n   * 요청 본문\n   */\n  data?: unknown;\n\n  /**\n   * 내부용: 401 재시도 카운트\n   */\n  _authRetryCount?: number;\n}\n\n/**\n * 응답 객체 인터페이스\n */\nexport interface NextTypeResponse<T = unknown> {\n  /**\n   * 서버 응답 데이터\n   */\n  data: T;\n\n  /**\n   * HTTP 상태 코드\n   */\n  status: number;\n\n  /**\n   * HTTP 상태 메시지\n   */\n  statusText: string;\n\n  /**\n   * 응답 헤더\n   */\n  headers: Headers;\n\n  /**\n   * 요청 설정\n   */\n  config: RequestConfig;\n\n  /**\n   * 요청 객체\n   */\n  request?: Request;\n}\n\n/**\n * 인터셉터 핸들러 타입\n */\nexport type RequestInterceptor = (\n  config: RequestConfig\n) => Promise<RequestConfig> | RequestConfig;\n\nexport type ResponseInterceptor = (\n  response: NextTypeResponse\n) => Promise<NextTypeResponse> | NextTypeResponse;\n\nexport type ErrorInterceptor = (\n  error: FetchError\n) => Promise<NextTypeResponse | FetchError> | NextTypeResponse | FetchError;\n\n/**\n * 쿼리 키 타입\n * 일반적으로 문자열 또는 문자열/숫자/불리언 등으로 구성된 배열입니다.\n */\nexport type QueryKey = string | readonly unknown[];\n\n/**\n * 인터셉터 핸들러와 제거 함수를 함께 반환하는 타입\n */\nexport interface InterceptorHandle {\n  /**\n   * 인터셉터 제거 함수\n   */\n  remove: () => void;\n}\n\n/**\n * 인터셉터 인터페이스\n */\nexport interface Interceptors {\n  request: {\n    use: (interceptor: RequestInterceptor) => InterceptorHandle;\n    eject: (id: number) => void;\n    clearByType: (type: symbol) => void;\n    clear: () => void;\n  };\n  response: {\n    use: (onFulfilled: ResponseInterceptor) => InterceptorHandle;\n    eject: (id: number) => void;\n    clearByType: (type: symbol) => void;\n    clear: () => void;\n  };\n  error: {\n    use: (onRejected: ErrorInterceptor) => InterceptorHandle;\n    eject: (id: number) => void;\n    clearByType: (type: symbol) => void;\n    clear: () => void;\n  };\n}\n\n/**\n * 취소 가능한 요청 타입\n */\nexport interface CancelablePromise<T> extends Promise<T> {\n  /**\n   * 요청 취소 메서드\n   */\n  cancel: () => void;\n\n  /**\n   * 요청 취소 여부 확인\n   */\n  isCanceled: () => boolean;\n}\n\n/**\n * Next Type Fetch 인스턴스 인터페이스\n */\nexport interface NextTypeFetch {\n  /**\n   * 전역 설정\n   */\n  defaults: FetchConfig;\n\n  /**\n   * 인터셉터\n   */\n  interceptors: Interceptors;\n\n  /**\n   * GET 요청\n   */\n  get: <T = unknown>(\n    url: string,\n    config?: FetchConfig\n  ) => CancelablePromise<NextTypeResponse<T>>;\n\n  /**\n   * POST 요청\n   */\n  post: <T = unknown>(\n    url: string,\n    data?: unknown,\n    config?: FetchConfig\n  ) => CancelablePromise<NextTypeResponse<T>>;\n\n  /**\n   * PUT 요청\n   */\n  put: <T = unknown>(\n    url: string,\n    data?: unknown,\n    config?: FetchConfig\n  ) => CancelablePromise<NextTypeResponse<T>>;\n\n  /**\n   * DELETE 요청\n   */\n  delete: <T = unknown>(\n    url: string,\n    config?: FetchConfig\n  ) => CancelablePromise<NextTypeResponse<T>>;\n\n  /**\n   * PATCH 요청\n   */\n  patch: <T = unknown>(\n    url: string,\n    data?: unknown,\n    config?: FetchConfig\n  ) => CancelablePromise<NextTypeResponse<T>>;\n\n  /**\n   * HEAD 요청\n   */\n  head: <T = unknown>(\n    url: string,\n    config?: FetchConfig\n  ) => CancelablePromise<NextTypeResponse<T>>;\n\n  /**\n   * OPTIONS 요청\n   */\n  options: <T = unknown>(\n    url: string,\n    config?: FetchConfig\n  ) => CancelablePromise<NextTypeResponse<T>>;\n\n  /**\n   * 기본 요청 메서드\n   */\n  request: <T = unknown>(\n    config: RequestConfig\n  ) => CancelablePromise<NextTypeResponse<T>>;\n}\n","import type {\n  ErrorInterceptor,\n  RequestInterceptor,\n  RequestConfig,\n  ResponseInterceptor,\n  FetchError,\n  NextTypeResponse,\n} from \"./types\";\n\n/**\n * 인터셉터 핸들러와 제거 함수를 함께 반환하는 타입\n */\nexport interface InterceptorHandle {\n  /**\n   * 인터셉터 제거 함수\n   */\n  remove: () => void;\n}\n\n/**\n * 인터셉터 유형을 식별하는 심볼 매핑\n * 유니크한 식별자를 통해 인터셉터 그룹 지정 가능\n */\nconst interceptorTypeSymbols = {\n  // 기본 인터셉터 유형\n  default: Symbol(\"default-interceptor\"),\n  // 인증 관련 인터셉터 - 자동 교체 설정 가능\n  auth: Symbol(\"auth-interceptor\"),\n  // 로깅 관련 인터셉터 - 자동 교체 설정 가능\n  logging: Symbol(\"logging-interceptor\"),\n  // 에러 처리 인터셉터 - 자동 교체 설정 가능\n  errorHandler: Symbol(\"error-handler-interceptor\"),\n};\n\n/**\n * 인터셉터 등록 옵션 (내부용)\n * @internal\n */\ninterface InterceptorOptions {\n  /**\n   * 인터셉터 유형 - 같은 유형의 기존 인터셉터를 교체할지 결정\n   */\n  type?: symbol;\n\n  /**\n   * 인터셉터 식별 태그 - 로깅 및 디버깅용\n   */\n  tag?: string;\n}\n\n/**\n * 인터셉터 매니저 클래스\n */\nexport class InterceptorManager<\n  T extends RequestInterceptor | ResponseInterceptor | ErrorInterceptor\n> {\n  private handlers: Array<{\n    id: number;\n    handler: T;\n    type?: symbol;\n    tag?: string;\n  } | null> = [];\n\n  private idCounter = 0;\n\n  /**\n   * 인터셉터 추가\n   * @param handler 인터셉터 핸들러 함수\n   * @param options 인터셉터 등록 옵션\n   * @returns 제거 함수가 포함된 핸들 객체\n   * @note 여러 번 use를 호출하면 등록한 모든 인터셉터가 순차적으로 실행됩니다. (Axios 등과 동일)\n   */\n  use(handler: T, options?: InterceptorOptions): InterceptorHandle {\n    const id = this.idCounter++;\n    const type = options?.type || interceptorTypeSymbols.default;\n    const tag = options?.tag || \"unnamed-interceptor\";\n\n    this.handlers.push({\n      id,\n      handler,\n      type,\n      tag,\n    });\n\n    return {\n      remove: () => this.eject(id),\n    };\n  }\n\n  /**\n   * 인터셉터 제거\n   * @param id 제거할 인터셉터 ID\n   */\n  eject(id: number): void {\n    const index = this.handlers.findIndex((h) => h !== null && h.id === id);\n    if (index !== -1) {\n      this.handlers[index] = null;\n    }\n  }\n\n  /**\n   * 특정 유형의 인터셉터 모두 제거\n   * @param type 제거할 인터셉터 유형\n   */\n  ejectByType(type: symbol): void {\n    this.handlers.forEach((item, index) => {\n      if (item !== null && item.type === type) {\n        this.handlers[index] = null;\n      }\n    });\n  }\n\n  /**\n   * 모든 인터셉터 제거\n   */\n  clear(): void {\n    this.handlers = [];\n  }\n\n  /**\n   * 모든 인터셉터 실행\n   * @param value 인터셉터에 전달할 값\n   * @returns 처리된 값\n   */\n  async forEach<V>(value: V): Promise<V> {\n    let result = value;\n\n    for (const handler of this.handlers) {\n      if (handler !== null) {\n        // 핸들러 실행 - T와 V 타입이 항상 일치하지 않으므로 타입 검사 우회\n        result = (await (\n          handler.handler as (arg: unknown) => unknown | Promise<unknown>\n        )(result)) as V;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * 디버깅 용도로 현재 등록된 인터셉터 정보 반환\n   */\n  getRegisteredInterceptors() {\n    return this.handlers\n      .filter((h) => h !== null)\n      .map((h) => ({\n        id: h?.id,\n        tag: h?.tag || \"(unnamed)\",\n        type: h?.type?.description || \"default\",\n      }));\n  }\n}\n\n/**\n * 요청 인터셉터 매니저 클래스\n */\nexport class RequestInterceptorManager {\n  private manager = new InterceptorManager<RequestInterceptor>();\n\n  /**\n   * 요청 인터셉터 추가\n   * @param interceptor 요청 인터셉터 함수\n   * @param type 인터셉터 유형 - 기본값은 auth 타입 (자동 교체됨)\n   * @returns 제거 함수가 포함된 핸들 객체\n   */\n  use(\n    interceptor: RequestInterceptor,\n    type = interceptorTypeSymbols.auth\n  ): InterceptorHandle {\n    return this.manager.use(interceptor, { type, tag: \"request-interceptor\" });\n  }\n\n  /**\n   * 모든 요청 인터셉터 제거\n   */\n  clear(): void {\n    this.manager.clear();\n  }\n\n  /**\n   * 특정 유형의 인터셉터 모두 제거\n   * @param type 제거할 인터셉터 유형\n   */\n  clearByType(type: symbol): void {\n    this.manager.ejectByType(type);\n  }\n\n  /**\n   * 요청 인터셉터 실행\n   */\n  async run(config: RequestConfig): Promise<RequestConfig> {\n    return this.manager.forEach<RequestConfig>(config);\n  }\n\n  /**\n   * 디버깅 용도로 현재 등록된 인터셉터 정보 반환\n   */\n  getRegisteredInterceptors() {\n    return this.manager.getRegisteredInterceptors();\n  }\n}\n\n/**\n * 응답 인터셉터 매니저 클래스\n */\nexport class ResponseInterceptorManager {\n  private manager = new InterceptorManager<ResponseInterceptor>();\n\n  /**\n   * 응답 인터셉터 추가\n   * @param interceptor 응답 인터셉터 함수\n   * @param type 인터셉터 유형 - 기본값은 auth 타입 (자동 교체됨)\n   * @returns 제거 함수가 포함된 핸들 객체\n   */\n  use(\n    interceptor: ResponseInterceptor,\n    type = interceptorTypeSymbols.auth\n  ): InterceptorHandle {\n    return this.manager.use(interceptor, { type, tag: \"response-interceptor\" });\n  }\n\n  /**\n   * 모든 응답 인터셉터 제거\n   */\n  clear(): void {\n    this.manager.clear();\n  }\n\n  /**\n   * 특정 유형의 인터셉터 제거\n   * @param type 제거할 인터셉터 유형\n   */\n  clearByType(type: symbol): void {\n    this.manager.ejectByType(type);\n  }\n\n  /**\n   * 응답 인터셉터 실행 (내부용)\n   */\n  async run<T>(response: NextTypeResponse<T>): Promise<NextTypeResponse<T>> {\n    return this.manager.forEach<NextTypeResponse<T>>(response);\n  }\n\n  /**\n   * 디버깅 용도로 현재 등록된 인터셉터 정보 반환\n   */\n  getRegisteredInterceptors() {\n    return this.manager.getRegisteredInterceptors();\n  }\n}\n\n/**\n * 에러 인터셉터 매니저 클래스\n */\nexport class ErrorInterceptorManager {\n  private manager = new InterceptorManager<ErrorInterceptor>();\n\n  /**\n   * 에러 인터셉터 추가\n   * @param interceptor 에러 인터셉터 함수\n   * @param type 인터셉터 유형 - 기본값은 errorHandler 타입 (자동 교체됨)\n   * @returns 제거 함수가 포함된 핸들 객체\n   */\n  use(\n    interceptor: ErrorInterceptor,\n    type = interceptorTypeSymbols.errorHandler\n  ): InterceptorHandle {\n    return this.manager.use(interceptor, { type, tag: \"error-interceptor\" });\n  }\n\n  /**\n   * 모든 에러 인터셉터 제거\n   */\n  clear(): void {\n    this.manager.clear();\n  }\n\n  /**\n   * 특정 유형의 인터셉터 제거\n   * @param type 제거할 인터셉터 유형\n   */\n  clearByType(type: symbol): void {\n    this.manager.ejectByType(type);\n  }\n\n  /**\n   * 에러 인터셉터 실행 (내부용)\n   */\n  async run(\n    error: FetchError\n  ): Promise<NextTypeResponse<unknown> | FetchError> {\n    return this.manager.forEach<FetchError>(error);\n  }\n\n  /**\n   * 디버깅 용도로 현재 등록된 인터셉터 정보 반환\n   */\n  getRegisteredInterceptors() {\n    return this.manager.getRegisteredInterceptors();\n  }\n}\n\n/**\n * 요청/응답 인터셉터 생성\n */\nexport function createInterceptors() {\n  const requestInterceptors = new RequestInterceptorManager();\n  const responseInterceptors = new ResponseInterceptorManager();\n  const errorInterceptors = new ErrorInterceptorManager();\n\n  return {\n    request: {\n      /**\n       * 요청 인터셉터 추가 - 자동으로 같은 유형의 이전 인터셉터 교체\n       * @param interceptor 요청 처리 함수\n       * @returns 제거 함수가 포함된 핸들\n       * @example\n       * ```typescript\n       * // 인터셉터 추가 (auth 유형 기본값)\n       * const authInterceptor = api.interceptors.request.use(config => {\n       *   config.headers = config.headers || {};\n       *   config.headers['Authorization'] = `Bearer ${getToken()}`;\n       *   return config;\n       * });\n       *\n       * // 다른 인터셉터 추가 시 이전 auth 유형 인터셉터는 자동 제거됨\n       * api.interceptors.request.use(config => {\n       *   config.headers = config.headers || {};\n       *   config.headers['Authorization'] = `Bearer ${getNewToken()}`;\n       *   return config;\n       * });\n       * ```\n       */\n      use: (interceptor: RequestInterceptor) =>\n        requestInterceptors.use(interceptor),\n\n      /**\n       * 인터셉터 제거 (하위 호환성)\n       * @deprecated InterceptorHandle.remove() 사용 권장\n       */\n      eject: (id: number) => {\n        console.warn(\n          \"eject() 메서드는 사용되지 않습니다. use()가 반환하는 InterceptorHandle.remove()를 사용하세요.\"\n        );\n      },\n\n      /**\n       * 모든 요청 인터셉터 제거\n       * @example\n       * ```typescript\n       * // 모든 요청 인터셉터 제거\n       * api.interceptors.request.clear();\n       * ```\n       */\n      clear: () => requestInterceptors.clear(),\n\n      /**\n       * 특정 유형의 인터셉터 제거\n       * @param type 제거할 인터셉터 유형\n       * @example\n       * ```typescript\n       * // 인증 관련 인터셉터만 제거\n       * api.interceptors.request.clearByType(interceptorTypes.auth);\n       * ```\n       */\n      clearByType: (type: symbol) => requestInterceptors.clearByType(type),\n\n      /**\n       * 요청 인터셉터 실행 (내부용)\n       */\n      run: requestInterceptors.run.bind(requestInterceptors),\n\n      /**\n       * 디버깅 용도로 현재 등록된 인터셉터 정보 조회\n       */\n      getRegistered: () => requestInterceptors.getRegisteredInterceptors(),\n    },\n    response: {\n      /**\n       * 응답 인터셉터 추가 - 자동으로 같은 유형의 이전 인터셉터 교체\n       * @param onFulfilled 성공 응답 처리 함수\n       * @returns 제거 함수가 포함된 핸들\n       */\n      use: (onFulfilled: ResponseInterceptor) =>\n        responseInterceptors.use(onFulfilled),\n\n      /**\n       * 인터셉터 제거 (하위 호환성)\n       * @deprecated InterceptorHandle.remove() 사용 권장\n       */\n      eject: (id: number) => {\n        console.warn(\n          \"eject() 메서드는 사용되지 않습니다. use()가 반환하는 InterceptorHandle.remove()를 사용하세요.\"\n        );\n      },\n\n      /**\n       * 모든 응답 인터셉터 제거\n       */\n      clear: () => responseInterceptors.clear(),\n\n      /**\n       * 특정 유형의 인터셉터 제거\n       * @param type 제거할 인터셉터 유형\n       */\n      clearByType: (type: symbol) => responseInterceptors.clearByType(type),\n\n      /**\n       * 응답 인터셉터 실행 (내부용)\n       */\n      run: responseInterceptors.run.bind(responseInterceptors),\n\n      /**\n       * 디버깅 용도로 현재 등록된 인터셉터 정보 조회\n       */\n      getRegistered: () => responseInterceptors.getRegisteredInterceptors(),\n    },\n    error: {\n      /**\n       * 에러 인터셉터 추가 - 자동으로 같은 유형의 이전 인터셉터 교체\n       * @param onRejected 에러 처리 함수\n       * @returns 제거 함수가 포함된 핸들\n       */\n      use: (onRejected: ErrorInterceptor) => errorInterceptors.use(onRejected),\n\n      /**\n       * 인터셉터 제거 (하위 호환성)\n       * @deprecated InterceptorHandle.remove() 사용 권장\n       */\n      eject: (id: number) => {\n        console.warn(\n          \"eject() 메서드는 사용되지 않습니다. use()가 반환하는 InterceptorHandle.remove()를 사용하세요.\"\n        );\n      },\n\n      /**\n       * 모든 에러 인터셉터 제거\n       */\n      clear: () => errorInterceptors.clear(),\n\n      /**\n       * 특정 유형의 인터셉터 제거\n       * @param type 제거할 인터셉터 유형\n       */\n      clearByType: (type: symbol) => errorInterceptors.clearByType(type),\n\n      /**\n       * 에러 인터셉터 실행 (내부용)\n       */\n      run: errorInterceptors.run.bind(errorInterceptors),\n\n      /**\n       * 디버깅 용도로 현재 등록된 인터셉터 정보 조회\n       */\n      getRegistered: () => errorInterceptors.getRegisteredInterceptors(),\n    },\n  };\n}\n\n// 인터셉터 유형 타입 익스포트\nexport const interceptorTypes = interceptorTypeSymbols;\n","import { isEmpty } from \"es-toolkit/compat\";\nimport { compact, trim, isNil, pickBy } from \"es-toolkit\";\n\n/**\n * URL에 쿼리 파라미터를 추가합니다.\n * 순수한 문자열 처리로 구현하여 안전하고 예측 가능합니다.\n * @param url 기본 URL (절대 URL 또는 상대 경로)\n * @param params 쿼리 파라미터 객체\n * @returns 쿼리 파라미터가 추가된 URL\n */\nexport function appendQueryParams(\n  url: string,\n  params?: Record<string, string | number | boolean | undefined | null>\n): string {\n  // URL 정리 및 빈 파라미터 체크\n  const cleanUrl = trim(url);\n  if (!params || isEmpty(params)) return cleanUrl;\n\n  // 유효한 파라미터만 필터링\n  const validParams = pickBy(params, (value) => !isNil(value));\n\n  if (isEmpty(validParams)) return cleanUrl;\n\n  // URL을 파트별로 분리 (fragment 먼저 분리)\n  const [baseUrl, fragment] = cleanUrl.split(\"#\");\n  const [path, existingQuery] = baseUrl.split(\"?\");\n\n  // 기존 쿼리 파라미터 파싱\n  const existingParams = new URLSearchParams(existingQuery || \"\");\n\n  // 새 파라미터 추가 (덮어쓰기 방식으로 중복 방지)\n  Object.entries(validParams).forEach(([key, value]) => {\n    existingParams.set(key, String(value));\n  });\n\n  // URL 파트들을 배열로 구성하고 compact로 빈 값 제거\n  const queryString = existingParams.toString();\n  const urlParts = compact([\n    path,\n    queryString ? `?${queryString}` : null,\n    fragment ? `#${fragment}` : null,\n  ]);\n\n  return urlParts.join(\"\");\n}\n\n/**\n * 베이스 URL과 상대 경로를 합칩니다.\n * @param baseURL 베이스 URL\n * @param url 상대 경로\n * @returns 완전한 URL\n */\nexport function combineURLs(baseURL?: string, url?: string): string {\n  // 입력값 정리\n  const cleanBaseURL = baseURL ? trim(baseURL) : \"\";\n  const cleanUrl = url ? trim(url) : \"\";\n\n  if (!cleanBaseURL) return cleanUrl;\n  if (!cleanUrl) return cleanBaseURL;\n\n  const baseEndsWithSlash = cleanBaseURL.endsWith(\"/\");\n  const urlStartsWithSlash = cleanUrl.startsWith(\"/\");\n\n  if (baseEndsWithSlash && urlStartsWithSlash) {\n    return cleanBaseURL + cleanUrl.substring(1);\n  }\n\n  if (!baseEndsWithSlash && !urlStartsWithSlash) {\n    return `${cleanBaseURL}/${cleanUrl}`;\n  }\n\n  return cleanBaseURL + cleanUrl;\n}\n","import type { FetchConfig, RequestConfig } from \"../types\";\n\n/**\n * 요청 설정을 병합합니다.\n * @param defaultConfig 기본 설정\n * @param requestConfig 요청별 설정\n * @returns 병합된 설정\n */\nexport function mergeConfigs(\n  defaultConfig: FetchConfig = {},\n  requestConfig: RequestConfig = {}\n): RequestConfig {\n  // RequestConfig 타입으로 캐스팅\n  const mergedConfig = {\n    ...defaultConfig,\n    ...requestConfig,\n  } as RequestConfig;\n\n  // 헤더 병합\n  mergedConfig.headers = {\n    ...defaultConfig.headers,\n    ...requestConfig.headers,\n  };\n\n  // 쿼리 파라미터 병합\n  mergedConfig.params = {\n    ...defaultConfig.params,\n    ...requestConfig.params,\n  };\n\n  // next 옵션 병합\n  if (defaultConfig.next || requestConfig.next) {\n    mergedConfig.next = {\n      ...defaultConfig.next,\n      ...requestConfig.next,\n    };\n  }\n\n  return mergedConfig;\n}\n","import { isNil, isString } from \"es-toolkit\";\n\n/**\n * 객체를 JSON 문자열로 변환합니다.\n * @param data 객체\n * @returns JSON 문자열\n */\nexport function stringifyData(data: unknown): string | null {\n  if (isNil(data)) return null;\n  if (isString(data)) return data;\n\n  try {\n    return JSON.stringify(data);\n  } catch (e) {\n    console.error(\"Failed to stringify data:\", e);\n    return null;\n  }\n}\n","/**\n * 타임아웃 프로미스를 생성합니다.\n * @param ms 타임아웃 시간 (ms)\n * @returns Promise와 AbortController\n */\nexport function createTimeoutPromise(ms?: number): { promise: Promise<never>; controller: AbortController } | null {\n\tif (!ms || ms <= 0) return null;\n\n\tconst controller = new AbortController();\n\n\tconst promise = new Promise<never>((_, reject) => {\n\t\tsetTimeout(() => {\n\t\t\tcontroller.abort();\n\t\t\treject(new Error(`Request timeout of ${ms}ms exceeded`));\n\t\t}, ms);\n\t});\n\n\treturn { promise, controller };\n}\n","import {\n  FetchError,\n  type NextTypeResponse,\n  type RequestConfig,\n} from \"../types\";\n\n/**\n * 응답 객체에서 데이터를 추출합니다.\n * @param response NextTypeResponse 객체\n * @returns 데이터\n */\nexport function unwrap<T>(response: NextTypeResponse<T>): T {\n  return response.data;\n}\n\n/**\n * 응답 객체에서 상태 코드를 추출합니다.\n * @param response NextTypeResponse 객체\n * @returns HTTP 상태 코드\n */\nexport function getStatus<T>(response: NextTypeResponse<T>): number {\n  return response.status;\n}\n\n/**\n * 응답 객체에서 헤더를 추출합니다.\n * @param response NextTypeResponse 객체\n * @returns 응답 헤더\n */\nexport function getHeaders<T>(response: NextTypeResponse<T>): Headers {\n  return response.headers;\n}\n\n/**\n * 응답 객체가 특정 상태 코드인지 확인합니다.\n * @param response NextTypeResponse 객체\n * @param code HTTP 상태 코드\n * @returns 상태 코드 일치 여부\n */\nexport function hasStatus<T>(\n  response: NextTypeResponse<T>,\n  code: number\n): boolean {\n  return response.status === code;\n}\n\n/**\n * HTTP 에러를 생성합니다.\n * @param message 에러 메시지\n * @param config 요청 설정\n * @param code 에러 코드\n * @param response 응답 객체 (선택적)\n * @param data 응답 데이터 (선택적)\n * @returns FetchError 인스턴스\n */\nexport function createError(\n  message: string,\n  config: RequestConfig,\n  code = \"ERR_UNKNOWN\",\n  response?: Response,\n  data?: unknown\n): FetchError {\n  return new FetchError(message, config, code, undefined, response, data);\n}\n","import { isFunction } from \"es-toolkit\";\nimport { FetchError, type NextTypeResponse } from \"../types\";\n\n/**\n * 객체가 FetchError인지 확인합니다.\n * @param error 검사할 객체\n * @returns FetchError 여부\n *\n * @example\n * try {\n *   const response = await api.get('/api/users');\n *   // 성공 처리\n * } catch (error) {\n *   if (isFetchError(error)) {\n *     console.error('API 에러:', error.message, error.code);\n *   }\n * }\n */\nexport function isFetchError(error: unknown): error is FetchError {\n  return error instanceof FetchError;\n}\n\n/**\n * 에러가 특정 에러 코드를 가지고 있는지 확인합니다.\n * @param error 검사할 에러\n * @param code 확인할 에러 코드\n * @returns 일치 여부\n *\n * @example\n * if (hasErrorCode(error, 'ERR_CANCELED')) {\n *   console.log('요청이 취소되었습니다.');\n * }\n */\nexport function hasErrorCode(error: unknown, code: string): boolean {\n  return isFetchError(error) && error.code === code;\n}\n\n/**\n * FetchError 에러 코드 상수\n */\nexport const ErrorCode = {\n  /** 네트워크 에러 */\n  NETWORK: \"ERR_NETWORK\",\n  /** 요청 취소됨 */\n  CANCELED: \"ERR_CANCELED\",\n  /** 요청 타임아웃 */\n  TIMEOUT: \"ERR_TIMEOUT\",\n  /** 서버 응답 에러 (4xx, 5xx) */\n  BAD_RESPONSE: \"ERR_BAD_RESPONSE\",\n  /** 데이터 검증 실패 */\n  VALIDATION: \"ERR_VALIDATION\",\n  /** 알 수 없는 검증 오류 */\n  VALIDATION_UNKNOWN: \"ERR_VALIDATION_UNKNOWN\",\n  /** 알 수 없는 에러 */\n  UNKNOWN: \"ERR_UNKNOWN\",\n} as const;\n\n/**\n * FetchError 에러 코드 타입\n */\nexport type ErrorCodeType = (typeof ErrorCode)[keyof typeof ErrorCode];\n\n/**\n * 에러를 처리하는 유틸리티 함수\n * @param error 처리할 에러\n * @param handlers 에러 코드별 핸들러\n * @returns 처리 결과 (핸들러 함수의 반환값)\n *\n * @example\n * try {\n *   const response = await api.get('/api/users');\n *   return response.data;\n * } catch (error) {\n *   return handleFetchError(error, {\n *     [ErrorCode.NETWORK]: () => '네트워크 연결을 확인해주세요.',\n *     [ErrorCode.TIMEOUT]: () => '요청 시간이 초과되었습니다.',\n *     [ErrorCode.CANCELED]: () => '요청이 취소되었습니다.',\n *     default: (err) => `오류가 발생했습니다: ${err.message}`,\n *   });\n * }\n */\nexport function handleFetchError<T>(\n  error: unknown,\n  handlers: {\n    [code in ErrorCodeType]?: (error: FetchError) => T;\n  } & {\n    default?: (error: unknown) => T;\n  }\n): T {\n  if (isFetchError(error) && error.code) {\n    const errorCode = error.code as ErrorCodeType;\n    const handler = handlers[errorCode];\n    if (handler) {\n      return handler(error);\n    }\n  }\n\n  if (handlers.default) {\n    return handlers.default(error);\n  }\n\n  // 핸들러가 없으면 에러를 다시 throw\n  throw error;\n}\n\n/**\n * HTTP 상태 코드에 따라 에러를 처리합니다.\n * @param error 처리할 에러\n * @param handlers HTTP 상태 코드별 핸들러\n * @returns 처리 결과 (핸들러 함수의 반환값)\n *\n * @example\n * try {\n *   const response = await api.get('/api/users');\n *   return response.data;\n * } catch (error) {\n *   return handleHttpError(error, {\n *     400: () => '잘못된 요청입니다.',\n *     401: () => '인증이 필요합니다.',\n *     404: () => '리소스를 찾을 수 없습니다.',\n *     default: () => '서버 오류가 발생했습니다.',\n *   });\n * }\n */\nexport function handleHttpError<T>(\n  error: unknown,\n  handlers: {\n    [status: number]: (error: FetchError) => T;\n    default?: (error: unknown) => T;\n  }\n): T {\n  if (\n    isFetchError(error) &&\n    error.response &&\n    isFunction(handlers[error.response.status])\n  ) {\n    return handlers[error.response.status](error);\n  }\n\n  if (handlers.default) {\n    return handlers.default(error);\n  }\n\n  // 핸들러가 없으면 에러를 다시 throw\n  throw error;\n}\n\n/**\n * 에러를 NextTypeResponse 형태로 변환합니다.\n * 인터셉터에서 에러를 응답으로 변환할 때 유용하게 사용할 수 있습니다.\n * @param error 변환할 에러\n * @param data 응답 데이터\n * @returns NextTypeResponse 객체\n *\n * @example\n * // 인터셉터에서 사용 예시\n * api.interceptors.error.use((error) => {\n *   if (hasErrorCode(error, ErrorCode.VALIDATION)) {\n *     return errorToResponse(error, {\n *       validationError: true,\n *       fields: error.response?.data\n *     });\n *   }\n *   throw error;\n * });\n */\nexport function errorToResponse<T>(\n  error: FetchError,\n  data: T\n): NextTypeResponse<T> {\n  return {\n    data,\n    status: error.response?.status || 500,\n    statusText: error.response?.statusText || error.message,\n    headers: error.response?.headers || new Headers(),\n    config: error.config,\n    request: error.request,\n  };\n}\n","import { z } from \"zod/v4\";\nimport type {\n  NextTypeResponse,\n  CancelablePromise,\n  FetchConfig,\n  RequestConfig,\n} from \"../types\";\nimport { ContentType, FetchError, ResponseType } from \"../types\";\nimport {\n  appendQueryParams,\n  combineURLs,\n  createTimeoutPromise,\n  stringifyData,\n} from \"../utils\";\n\ninterface InterceptorsType {\n  request: {\n    run: (config: RequestConfig) => Promise<RequestConfig>;\n  };\n  response: {\n    run: <T>(response: NextTypeResponse<T>) => Promise<NextTypeResponse<T>>;\n  };\n  error: {\n    run: (error: FetchError) => Promise<NextTypeResponse<unknown> | FetchError>;\n  };\n}\n\n/**\n * 특정 콘텐츠 타입에 맞게 요청 본문 데이터를 준비합니다.\n */\nfunction prepareRequestBody(\n  data: unknown,\n  contentType: string,\n  headers: Record<string, string>\n): { body: BodyInit | null; headers: Record<string, string> } {\n  const headersCopy = { ...headers };\n\n  // FormData, URLSearchParams, Blob은 직접 전달\n  if (\n    data instanceof FormData ||\n    data instanceof URLSearchParams ||\n    data instanceof Blob\n  ) {\n    // FormData의 경우 Content-Type 헤더를 설정하지 않도록 함\n    if (\n      data instanceof FormData &&\n      (contentType === \"\" || contentType === ContentType.MULTIPART)\n    ) {\n      const { \"Content-Type\": _, ...remainingHeaders } = headersCopy;\n      return { body: data, headers: remainingHeaders };\n    }\n    return { body: data, headers: headersCopy };\n  }\n\n  // 문자열로 변환된 컨텐츠 타입\n  const contentTypeStr = String(contentType);\n\n  // 컨텐츠 타입에 따른 처리\n  switch (true) {\n    // JSON 컨텐츠 타입\n    case contentTypeStr === ContentType.JSON ||\n      contentTypeStr.includes(\"application/json\"):\n      return {\n        body: stringifyData(data),\n        headers: { ...headersCopy, \"Content-Type\": ContentType.JSON },\n      };\n\n    // URL 인코딩된 폼 데이터\n    case contentTypeStr === ContentType.FORM ||\n      contentTypeStr.includes(\"application/x-www-form-urlencoded\"): {\n      let body: BodyInit;\n\n      if (\n        typeof data === \"object\" &&\n        data !== null &&\n        !(data instanceof URLSearchParams)\n      ) {\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(\n          data as Record<string, string>\n        )) {\n          if (value !== undefined && value !== null) {\n            params.append(key, String(value));\n          }\n        }\n        body = params;\n      } else if (data instanceof URLSearchParams) {\n        body = data;\n      } else {\n        // 문자열이나 null이면 그대로 사용\n        body = String(data || \"\");\n      }\n\n      return {\n        body,\n        headers: { ...headersCopy, \"Content-Type\": ContentType.FORM },\n      };\n    }\n\n    // XML 컨텐츠 타입\n    case contentTypeStr === ContentType.XML ||\n      contentTypeStr.includes(\"application/xml\"):\n      return {\n        body: typeof data === \"string\" ? data : String(data),\n        headers: { ...headersCopy, \"Content-Type\": ContentType.XML },\n      };\n\n    // HTML 컨텐츠 타입\n    case contentTypeStr === ContentType.HTML ||\n      contentTypeStr.includes(\"text/html\"):\n      return {\n        body: typeof data === \"string\" ? data : String(data),\n        headers: { ...headersCopy, \"Content-Type\": ContentType.HTML },\n      };\n\n    // 일반 텍스트\n    case contentTypeStr === ContentType.TEXT ||\n      contentTypeStr.includes(\"text/plain\"):\n      return {\n        body: typeof data === \"string\" ? data : String(data),\n        headers: { ...headersCopy, \"Content-Type\": ContentType.TEXT },\n      };\n\n    // 바이너리 데이터\n    case contentTypeStr === ContentType.BLOB ||\n      contentTypeStr.includes(\"application/octet-stream\"): {\n      const body =\n        data instanceof Blob || data instanceof ArrayBuffer\n          ? data\n          : typeof data === \"string\"\n          ? data\n          : String(data);\n\n      return {\n        body,\n        headers: { ...headersCopy, \"Content-Type\": ContentType.BLOB },\n      };\n    }\n\n    // 기타 컨텐츠 타입\n    default: {\n      const body =\n        typeof data === \"object\" ? stringifyData(data) : String(data);\n\n      return {\n        body,\n        headers: { ...headersCopy, \"Content-Type\": contentTypeStr },\n      };\n    }\n  }\n}\n\n/**\n * 응답 타입에 따라 응답 데이터를 처리합니다.\n */\nasync function processResponseByType(\n  response: Response,\n  responseType: ResponseType,\n  contentTypeHeader: string,\n  parseJSON = true\n): Promise<unknown> {\n  // 응답 타입 결정\n  const effectiveResponseType =\n    responseType ||\n    (contentTypeHeader.includes(\"application/json\") && parseJSON !== false\n      ? ResponseType.JSON\n      : ResponseType.TEXT);\n\n  // HEAD나 OPTIONS 요청과 같이 응답 본문이 없는 경우를 위한 안전 검사\n  const isEmptyResponse =\n    response.status === 204 || response.headers.get(\"content-length\") === \"0\";\n\n  // 응답 메서드 안전 검사 함수\n  const safeCall = async <T>(\n    method: \"json\" | \"text\" | \"blob\" | \"arrayBuffer\",\n    fallback: T\n  ): Promise<T> => {\n    if (!response[method] || typeof response[method] !== \"function\") {\n      // 모킹 환경 감지: 테스트 시 response는 모킹된 객체일 수 있음\n      // 테스트에서는 모킹된 응답 객체를 그대로 사용\n      if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"test\") {\n        // 테스트 환경에서 mocking된 객체라면 해당 메서드를 직접 호출\n        try {\n          if (response[method] && typeof response[method] === \"function\") {\n            // 타입 단언을 사용하여 타입 오류 해결\n            return await (response[method] as () => Promise<T>)();\n          }\n        } catch (e) {\n          // 테스트 환경에서 오류 발생 시 fallback 반환\n        }\n      }\n      return fallback;\n    }\n\n    try {\n      // 타입 단언을 사용하여 타입 오류 해결\n      return await (response[method] as () => Promise<T>)();\n    } catch (e) {\n      console.warn(`Failed to process response with ${method}:`, e);\n      return fallback;\n    }\n  };\n\n  switch (effectiveResponseType) {\n    case ResponseType.JSON:\n      // 빈 응답 본문이면 빈 객체 반환\n      if (isEmptyResponse) {\n        return {};\n      }\n\n      try {\n        return await response.json();\n      } catch (e) {\n        // JSON 파싱 실패 시 텍스트로 대체\n        return await safeCall(\"text\", \"\");\n      }\n\n    case ResponseType.BLOB:\n      if (isEmptyResponse) {\n        return new Blob();\n      }\n      return await safeCall(\"blob\", new Blob());\n\n    case ResponseType.ARRAY_BUFFER:\n      if (isEmptyResponse) {\n        return new ArrayBuffer(0);\n      }\n      return await safeCall(\"arrayBuffer\", new ArrayBuffer(0));\n\n    case ResponseType.RAW:\n      // Response 객체 자체를 반환\n      return response;\n\n    default:\n      // 기본값은 텍스트\n      if (isEmptyResponse) {\n        return \"\";\n      }\n      return await safeCall(\"text\", \"\");\n  }\n}\n\n/**\n * 요청 함수 생성\n * @param defaultConfig 기본 설정\n * @param interceptors 인터셉터\n * @returns 요청 함수\n */\nexport function createRequestFunction(\n  defaultConfig: FetchConfig,\n  interceptors: InterceptorsType\n) {\n  /**\n   * 기본 요청 함수\n   */\n  function request<T>(\n    config: RequestConfig\n  ): CancelablePromise<NextTypeResponse<T>> {\n    // 취소 상태 관리\n    let isCanceled = false;\n    let abortController = new AbortController();\n\n    // 취소 메서드\n    const cancel = () => {\n      isCanceled = true;\n      abortController.abort();\n    };\n\n    // 최대 재시도 횟수 및 설정 준비\n    let maxRetries = 0;\n    let retryStatusCodes: number[] = [];\n    let retryBackoff: (retryCount: number) => number = (count) =>\n      Math.min(1000 * 2 ** (count - 1), 10000);\n\n    if (typeof config.retry === \"number\") {\n      maxRetries = config.retry;\n    } else if (config.retry && typeof config.retry === \"object\") {\n      maxRetries = config.retry.limit;\n      retryStatusCodes = config.retry.statusCodes || [];\n\n      if (config.retry.backoff === \"linear\") {\n        retryBackoff = (count) => 1000 * count;\n      } else if (config.retry.backoff === \"exponential\") {\n        retryBackoff = (count) => Math.min(1000 * 2 ** (count - 1), 10000);\n      } else if (typeof config.retry.backoff === \"function\") {\n        retryBackoff = config.retry.backoff;\n      }\n    }\n\n    let retryCount = 0;\n    let authRetryCount = config._authRetryCount || 0;\n    const authRetryOption = config.authRetry || defaultConfig.authRetry;\n\n    // 사용자 정의 AbortSignal이 있는 경우 즉시 확인\n    if (config.signal) {\n      if (config.signal.aborted) {\n        // 이미 취소된 경우 즉시 취소 상태 설정\n        isCanceled = true;\n        abortController.abort();\n      } else {\n        // 이벤트 리스너 연결\n        config.signal.addEventListener(\"abort\", () => {\n          isCanceled = true;\n          abortController.abort();\n        });\n      }\n    }\n\n    // 재시도 함수\n    async function performRequest(): Promise<NextTypeResponse<T>> {\n      try {\n        // 이미 취소된 경우 에러 반환\n        if (isCanceled) {\n          throw new FetchError(\"Request was canceled\", config, \"ERR_CANCELED\");\n        }\n\n        // 스키마 추출 (요청 인터셉터 전에 제거)\n        const { schema, ...restConfig } = config;\n\n        // 요청 인터셉터 실행\n        const requestConfig = await interceptors.request.run(restConfig);\n\n        // URL 조합\n        const url = combineURLs(requestConfig.baseURL, requestConfig.url);\n\n        // URL에 쿼리 파라미터 추가\n        const fullUrl = appendQueryParams(url, requestConfig.params);\n\n        // 타임아웃 설정\n        const timeoutResult = createTimeoutPromise(requestConfig.timeout);\n\n        // 사용자 정의 AbortSignal이 있으면 이벤트 리스너 연결\n        if (requestConfig.signal && !isCanceled) {\n          if (requestConfig.signal.aborted) {\n            isCanceled = true;\n            abortController.abort();\n            // 이미 취소된 경우 즉시 취소 에러 던짐\n            throw new FetchError(\n              \"Request was canceled\",\n              config,\n              \"ERR_CANCELED\"\n            );\n          }\n        }\n\n        // 요청 옵션 구성 - fetch API 관련 속성만 추출\n        const {\n          method = \"GET\",\n          headers = {},\n          cache,\n          credentials,\n          integrity,\n          keepalive,\n          mode,\n          redirect,\n          referrer,\n          referrerPolicy,\n          next,\n          signal, // 여기서는 사용하지 않음 (위에서 처리)\n          contentType, // 새로 추가된 컨텐츠 타입 옵션\n          responseType, // 새로 추가된 응답 타입 옵션\n          data,\n        } = requestConfig;\n\n        // RequestInit 객체 생성 - fetch API 관련 속성만 포함\n        const requestInit: RequestInit = {\n          method,\n          headers: headers as Record<string, string>,\n          signal: abortController.signal, // 항상 내부 AbortController 사용\n          cache,\n          credentials,\n          integrity,\n          keepalive,\n          mode,\n          redirect,\n          referrer,\n          referrerPolicy,\n        };\n\n        // Next.js의 next 옵션이 있으면 RequestInit에 추가\n        if (next) {\n          // TypeScript 정의에는 next가 없으므로 타입 단언 사용\n          // DOM 타입에는 next 속성이 없지만 Next.js는 이를 지원함\n          (requestInit as RequestInit & { next?: typeof next }).next = next;\n        }\n\n        // data가 있으면 요청 본문에 추가\n        if (data !== undefined) {\n          // Content-Type 결정 로직\n          const effectiveContentType =\n            contentType ||\n            (headers as Record<string, string>)[\"Content-Type\"] ||\n            \"\";\n\n          // 컨텐츠 타입이 제공되지 않았고 객체인 경우 기본값은 JSON\n          if (\n            effectiveContentType === \"\" &&\n            typeof data === \"object\" &&\n            data !== null &&\n            !(data instanceof FormData) &&\n            !(data instanceof URLSearchParams) &&\n            !(data instanceof Blob)\n          ) {\n            // 기본적으로 JSON으로 처리\n            requestInit.body = stringifyData(data);\n            requestInit.headers = {\n              ...(headers as Record<string, string>),\n              \"Content-Type\": ContentType.JSON,\n            };\n          } else {\n            // 컨텐츠 타입에 따라 요청 본문 데이터 처리\n            const { body, headers: processedHeaders } = prepareRequestBody(\n              data,\n              effectiveContentType,\n              headers as Record<string, string>\n            );\n\n            requestInit.body = body;\n            requestInit.headers = processedHeaders;\n          }\n        }\n\n        // 이미 취소된 경우 fetch를 호출하지 않음\n        if (isCanceled) {\n          throw new FetchError(\"Request was canceled\", config, \"ERR_CANCELED\");\n        }\n\n        // 실제 fetch 요청 실행\n        const fetchPromise = fetch(fullUrl, requestInit);\n\n        // 타임아웃이 있으면 타임아웃 Promise와 함께 race\n        const response = await (timeoutResult\n          ? Promise.race([fetchPromise, timeoutResult.promise])\n          : fetchPromise);\n\n        // 응답 처리\n        const contentTypeHeader = response.headers.get(\"content-type\") || \"\";\n\n        // 응답 타입에 따라 응답 데이터 처리\n        const responseData = await processResponseByType(\n          response,\n          responseType as ResponseType,\n          contentTypeHeader,\n          requestConfig.parseJSON\n        );\n\n        // HTTP 에러 검사\n        if (!response.ok) {\n          // HTTP 에러 생성 및 throw\n          const fetchError = new FetchError(\n            response.statusText || `HTTP error ${response.status}`,\n            requestConfig,\n            \"ERR_BAD_RESPONSE\",\n            requestInit as unknown as Request,\n            response,\n            responseData\n          );\n\n          // 에러 인터셉터 실행\n          const processedError = await interceptors.error.run(fetchError);\n\n          // 만약 인터셉터가 NextTypeResponse를 반환하면 정상 응답으로 처리\n          if (\"data\" in processedError && \"status\" in processedError) {\n            return processedError as NextTypeResponse<T>;\n          }\n\n          // 처리된 에러 던짐\n          throw processedError;\n        }\n\n        // NextTypeResponse 생성\n        const NextTypeResponse: NextTypeResponse<T> = {\n          data: responseData as T,\n          status: response.status,\n          statusText: response.statusText,\n          headers: response.headers,\n          config: requestConfig,\n          request: requestInit as unknown as Request,\n        };\n\n        // 응답 인터셉터 실행\n        const processedResponse = await interceptors.response.run(\n          NextTypeResponse\n        );\n\n        // 스키마 검증 (스키마가 제공된 경우)\n        if (schema) {\n          try {\n            const validatedData = schema.parse(processedResponse.data);\n\n            // 검증된 데이터로 업데이트\n            processedResponse.data = validatedData as T;\n\n            return processedResponse;\n          } catch (validationError) {\n            // 스키마 검증 실패\n            if (validationError instanceof z.ZodError) {\n              const fetchError = new FetchError(\n                \"Validation failed\",\n                requestConfig,\n                \"ERR_VALIDATION\",\n                requestInit as unknown as Request,\n                response,\n                processedResponse.data\n              );\n\n              fetchError.name = \"ValidationError\";\n\n              // 에러 인터셉터 실행\n              const processedError = await interceptors.error.run(fetchError);\n\n              // 만약 인터셉터가 NextTypeResponse를 반환하면 정상 응답으로 처리\n              if (\"data\" in processedError && \"status\" in processedError) {\n                return processedError as NextTypeResponse<T>;\n              }\n\n              throw processedError;\n            }\n\n            // 알 수 없는 검증 오류\n            const fetchError = new FetchError(\n              \"Unknown validation error\",\n              requestConfig,\n              \"ERR_VALIDATION_UNKNOWN\",\n              requestInit as unknown as Request,\n              response,\n              processedResponse.data\n            );\n\n            // 에러 인터셉터 실행\n            const processedError = await interceptors.error.run(fetchError);\n\n            // 만약 인터셉터가 NextTypeResponse를 반환하면 정상 응답으로 처리\n            if (\"data\" in processedError && \"status\" in processedError) {\n              return processedError as NextTypeResponse<T>;\n            }\n\n            throw processedError;\n          }\n        }\n\n        // 스키마 없이 응답 반환\n        return processedResponse;\n      } catch (error) {\n        // 401 인증 오류 처리 (authRetry 옵션 적용)\n        if (\n          error instanceof FetchError &&\n          authRetryOption &&\n          typeof authRetryOption.handler === \"function\"\n        ) {\n          const statusCodes = authRetryOption.statusCodes ?? [401];\n          const statusMatch =\n            error.response && statusCodes.includes(error.response.status);\n          const shouldRetryResult =\n            !authRetryOption.shouldRetry ||\n            authRetryOption.shouldRetry(error, config);\n          if (statusMatch && shouldRetryResult) {\n            authRetryCount = config._authRetryCount || 0;\n            if (authRetryCount < (authRetryOption.limit ?? 1)) {\n              const shouldRetry = await authRetryOption.handler(error, config);\n              if (shouldRetry) {\n                return request<T>({\n                  ...config,\n                  _authRetryCount: authRetryCount + 1,\n                });\n              }\n            }\n          }\n        }\n\n        // FetchError는 에러 인터셉터가 이미 실행되었으므로 그대로 throw\n        if (error instanceof FetchError) {\n          throw error;\n        }\n\n        // 취소된 요청인 경우\n        if (error instanceof Error && error.name === \"AbortError\") {\n          const fetchError = new FetchError(\n            isCanceled ? \"Request was canceled\" : \"Request timed out\",\n            config,\n            isCanceled ? \"ERR_CANCELED\" : \"ERR_TIMEOUT\"\n          );\n\n          // 에러 인터셉터 실행\n          const processedError = await interceptors.error.run(fetchError);\n\n          // 만약 인터셉터가 NextTypeResponse를 반환하면 정상 응답으로 처리\n          if (\"data\" in processedError && \"status\" in processedError) {\n            return processedError as NextTypeResponse<T>;\n          }\n\n          throw processedError;\n        }\n\n        // 재시도 로직\n        if (retryCount < maxRetries && !isCanceled) {\n          // HTTP 에러인 경우 상태 코드를 확인\n          if (\n            error instanceof FetchError &&\n            error.response &&\n            (retryStatusCodes.length === 0 ||\n              retryStatusCodes.includes(error.response.status))\n          ) {\n            retryCount++;\n            // 새 AbortController 생성 (이전 것은 abort되었을 수 있으므로)\n            abortController = new AbortController();\n            // 재시도 간격 계산\n            const delay = retryBackoff(retryCount);\n            await new Promise((resolve) => setTimeout(resolve, delay));\n            return performRequest();\n          }\n\n          // 네트워크 에러인 경우 항상 재시도\n          if (!(error instanceof FetchError)) {\n            retryCount++;\n            // 새 AbortController 생성\n            abortController = new AbortController();\n            // 재시도 간격 계산\n            const delay = retryBackoff(retryCount);\n            await new Promise((resolve) => setTimeout(resolve, delay));\n            return performRequest();\n          }\n        }\n\n        // 모든 재시도가 실패하거나 재시도가 없는 경우\n        // 네트워크 에러 등을 FetchError로 변환\n        const fetchError = new FetchError(\n          error instanceof Error ? error.message : \"Request failed\",\n          config,\n          \"ERR_NETWORK\"\n        );\n\n        // 에러 인터셉터 실행\n        const processedError = await interceptors.error.run(fetchError);\n\n        // 만약 인터셉터가 NextTypeResponse를 반환하면 정상 응답으로 처리\n        if (\"data\" in processedError && \"status\" in processedError) {\n          return processedError as NextTypeResponse<T>;\n        }\n\n        throw processedError;\n      }\n    }\n\n    // 요청 실행 프로미스\n    const requestPromise = performRequest();\n\n    // 취소 가능한 프로미스 생성\n    const cancelablePromise = Object.assign(requestPromise, {\n      cancel,\n      isCanceled: () => isCanceled,\n    }) as CancelablePromise<NextTypeResponse<T>>;\n\n    return cancelablePromise;\n  }\n\n  return request;\n}\n","import type {\n  NextTypeResponse,\n  CancelablePromise,\n  FetchConfig,\n  HttpMethod,\n  RequestConfig,\n} from \"../types\";\nimport { mergeConfigs } from \"../utils\";\n\n/**\n * HTTP 메서드 함수들을 생성합니다.\n * @param request 기본 요청 함수\n * @param defaultConfig 기본 설정\n * @returns HTTP 메서드 함수 객체\n */\nexport function createHttpMethods(\n  request: <T>(config: RequestConfig) => CancelablePromise<NextTypeResponse<T>>,\n  defaultConfig: FetchConfig\n) {\n  return {\n    get<T>(\n      url: string,\n      config: FetchConfig = {}\n    ): CancelablePromise<NextTypeResponse<T>> {\n      return request<T>(\n        mergeConfigs(defaultConfig, {\n          ...config,\n          url,\n          method: \"GET\" as HttpMethod,\n        })\n      );\n    },\n\n    post<T>(\n      url: string,\n      data?: unknown,\n      config: FetchConfig = {}\n    ): CancelablePromise<NextTypeResponse<T>> {\n      return request<T>(\n        mergeConfigs(defaultConfig, {\n          ...config,\n          url,\n          method: \"POST\" as HttpMethod,\n          data,\n        })\n      );\n    },\n\n    put<T>(\n      url: string,\n      data?: unknown,\n      config: FetchConfig = {}\n    ): CancelablePromise<NextTypeResponse<T>> {\n      return request<T>(\n        mergeConfigs(defaultConfig, {\n          ...config,\n          url,\n          method: \"PUT\" as HttpMethod,\n          data,\n        })\n      );\n    },\n\n    delete<T>(\n      url: string,\n      config: FetchConfig = {}\n    ): CancelablePromise<NextTypeResponse<T>> {\n      return request<T>(\n        mergeConfigs(defaultConfig, {\n          ...config,\n          url,\n          method: \"DELETE\" as HttpMethod,\n        })\n      );\n    },\n\n    patch<T>(\n      url: string,\n      data?: unknown,\n      config: FetchConfig = {}\n    ): CancelablePromise<NextTypeResponse<T>> {\n      return request<T>(\n        mergeConfigs(defaultConfig, {\n          ...config,\n          url,\n          method: \"PATCH\" as HttpMethod,\n          data,\n        })\n      );\n    },\n\n    head<T>(\n      url: string,\n      config: FetchConfig = {}\n    ): CancelablePromise<NextTypeResponse<T>> {\n      return request<T>(\n        mergeConfigs(defaultConfig, {\n          ...config,\n          url,\n          method: \"HEAD\" as HttpMethod,\n        })\n      );\n    },\n\n    options<T>(\n      url: string,\n      config: FetchConfig = {}\n    ): CancelablePromise<NextTypeResponse<T>> {\n      return request<T>(\n        mergeConfigs(defaultConfig, {\n          ...config,\n          url,\n          method: \"OPTIONS\" as HttpMethod,\n        })\n      );\n    },\n  };\n}\n","import type { FetchConfig, NextTypeFetch } from \"../types\";\nimport { createInterceptors } from \"../interceptors\";\nimport { createRequestFunction } from \"./request\";\nimport { createHttpMethods } from \"../methods\";\nimport { ErrorCode } from \"../utils/error\";\n\n/**\n * Next.js App Router와 함께 사용할 수 있는 타입 안전한 fetch 클라이언트를 생성합니다.\n * @param defaultConfig 기본 설정\n * @returns fetch 클라이언트 인스턴스\n */\nexport function createFetch(defaultConfig: FetchConfig = {}): NextTypeFetch {\n  // 사용자 설정 적용\n  const mergedConfig: FetchConfig = {\n    ...defaultConfig,\n  };\n\n  // 인터셉터 생성\n  const interceptors = createInterceptors();\n\n  // 요청 함수 생성\n  const request = createRequestFunction(mergedConfig, interceptors);\n\n  // HTTP 메서드 생성\n  const methods = createHttpMethods(request, mergedConfig);\n\n  // 클라이언트 인스턴스 생성\n  const instance: NextTypeFetch = {\n    defaults: mergedConfig,\n    interceptors,\n    request,\n    ...methods,\n  };\n\n  return instance;\n}\n\n// 에러 코드 상수 노출\nexport { ErrorCode };\n","import { createFetch } from \"./core/client\";\nimport type { FetchConfig, NextTypeFetch } from \"./types\";\n\n/**\n * 기본 fetch 인스턴스\n */\nconst defaultInstance = createFetch();\n\n/**\n * 기본 요청 메서드 - 인스턴스 생성 없이 바로 사용 가능\n */\nexport const request = defaultInstance.request;\n\n/**\n * GET 요청 메서드 - 인스턴스 생성 없이 바로 사용 가능\n */\nexport const get = defaultInstance.get;\n\n/**\n * POST 요청 메서드 - 인스턴스 생성 없이 바로 사용 가능\n */\nexport const post = defaultInstance.post;\n\n/**\n * PUT 요청 메서드 - 인스턴스 생성 없이 바로 사용 가능\n */\nexport const put = defaultInstance.put;\n\n/**\n * DELETE 요청 메서드 - 인스턴스 생성 없이 바로 사용 가능\n */\nexport const del = defaultInstance.delete;\n\n/**\n * PATCH 요청 메서드 - 인스턴스 생성 없이 바로 사용 가능\n */\nexport const patch = defaultInstance.patch;\n\n/**\n * HEAD 요청 메서드 - 인스턴스 생성 없이 바로 사용 가능\n */\nexport const head = defaultInstance.head;\n\n/**\n * OPTIONS 요청 메서드 - 인스턴스 생성 없이 바로 사용 가능\n */\nexport const options = defaultInstance.options;\n\n/**\n * 기본 설정 - 전역 설정 변경 가능\n * 라이브러리 이름(Next Type Fetch)의 약자를 사용한 고유명사\n */\nexport const ntFetch: FetchConfig = defaultInstance.defaults;\n\n/**\n * 인터셉터 - 전역 인터셉터 설정 가능\n */\nexport const interceptors = defaultInstance.interceptors;\n\n/**\n * 기본 인스턴스 - 모든 메서드 포함\n */\nexport default defaultInstance as NextTypeFetch;\n","import type { ZodType } from \"zod/v4\";\nimport { isString, isFunction } from \"es-toolkit/compat\";\nimport { FetchConfig, NextTypeFetch } from \"../../types\";\n\n/**\n * 기본 Query 설정 (공통 속성)\n */\ninterface BaseQueryConfig<Params = void, Schema extends ZodType = ZodType> {\n  cacheKey: (params?: Params) => readonly unknown[];\n  schema?: Schema;\n  placeholderData?:\n    | any\n    | ((\n        prev?: any,\n        prevQuery?: import(\"../cache/query-cache\").QueryState<any>\n      ) => any);\n  fetchConfig?: Omit<FetchConfig, \"url\" | \"method\" | \"params\" | \"data\">;\n  select?: (data: any) => any;\n  enabled?: boolean | ((params?: Params) => boolean);\n}\n\n/**\n * URL 기반 Query 설정\n */\ninterface UrlBasedQueryConfig<Params = void, Schema extends ZodType = ZodType>\n  extends BaseQueryConfig<Params, Schema> {\n  /**\n   * API 요청 URL을 생성하는 함수\n   */\n  url: (params?: Params) => string;\n\n  /**\n   * queryFn이 있으면 안됨 (상호 배제)\n   */\n  queryFn?: never;\n}\n\n/**\n * Custom Function 기반 Query 설정\n */\ninterface FunctionBasedQueryConfig<\n  Params = void,\n  Schema extends ZodType = ZodType\n> extends BaseQueryConfig<Params, Schema> {\n  /**\n   * Custom query function for complex requests\n   * 복잡한 요청을 처리할 수 있는 사용자 정의 함수\n   */\n  queryFn: (params: Params, fetcher: NextTypeFetch) => Promise<any>;\n\n  /**\n   * url이 있으면 안됨 (상호 배제)\n   */\n  url?: never;\n}\n\n/**\n * Query를 정의하기 위한 설정 객체 인터페이스\n * URL 방식 또는 Custom Function 방식 중 하나를 선택할 수 있음\n */\nexport type QueryConfig<Params = void, Schema extends ZodType = ZodType> =\n  | UrlBasedQueryConfig<Params, Schema>\n  | FunctionBasedQueryConfig<Params, Schema>;\n\nexport type QueryFactoryInput = Record<string, QueryConfig<any, any>>;\n\nexport type ExtractParams<T> = T extends QueryConfig<infer P, any> ? P : never;\n\n/**\n * 에러 메시지 상수\n */\nconst ERROR_MESSAGES = {\n  BOTH_APPROACHES:\n    \"QueryConfig cannot have both 'queryFn' and 'url' at the same time. \" +\n    \"Choose either custom function approach (queryFn) or URL-based approach (url).\",\n  MISSING_APPROACHES:\n    \"QueryConfig must have either 'queryFn' or 'url'. \" +\n    \"Provide either a custom function or URL-based configuration.\",\n} as const;\n\n/**\n * Query 설정의 유효성을 검증\n * QueryConfig와 UseQueryOptions 모두 지원\n */\nexport function validateQueryConfig(\n  config: QueryConfig<any, any> | any // UseQueryOptions도 받을 수 있도록\n): void {\n  const hasQueryFn = isFunction(config.queryFn);\n  const hasUrl = isFunction(config.url) || isString(config.url); // function 또는 string 둘 다 허용\n\n  if (hasQueryFn && hasUrl) {\n    throw new Error(ERROR_MESSAGES.BOTH_APPROACHES);\n  }\n\n  if (!hasQueryFn && !hasUrl) {\n    throw new Error(ERROR_MESSAGES.MISSING_APPROACHES);\n  }\n}\n\nexport function createQueryFactory<T extends QueryFactoryInput>(defs: T): T {\n  // 각 QueryConfig 검증\n  Object.entries(defs).forEach(([key, config]) => {\n    try {\n      validateQueryConfig(config);\n    } catch (error) {\n      throw new Error(\n        `Invalid QueryConfig for '${key}': ${(error as Error).message}`\n      );\n    }\n  });\n\n  return defs;\n}\n","import type { z, ZodType } from \"zod/v4\";\nimport { isFunction } from \"es-toolkit/compat\";\nimport type {\n  FetchConfig,\n  HttpMethod,\n  QueryKey,\n  NextTypeFetch,\n} from \"../../types\";\n\n/**\n * Zod 스키마가 명확히 있을 때만 z.infer<T>를 사용, 아니면 Fallback\n */\ntype InferIfZodSchema<T, Fallback> = [T] extends [ZodType]\n  ? z.infer<T>\n  : Fallback;\n\n/**\n * 기본 Mutation 설정 (url + method 방식)\n */\ninterface BaseMutationConfig<\n  TVariables = any,\n  TData = any,\n  TError = Error,\n  TContext = unknown,\n  RequestSchema extends ZodType = never,\n  ResponseSchema extends ZodType = never\n> {\n  /**\n   * Mutation을 식별하는 캐시 키입니다. (선택적)\n   * Devtools 등에서 사용될 수 있습니다.\n   */\n  cacheKey?: QueryKey;\n\n  /**\n   * 요청 본문의 유효성 검사를 위한 Zod 스키마입니다. (선택적)\n   */\n  requestSchema?: RequestSchema;\n\n  /**\n   * 응답 데이터의 유효성 검사를 위한 Zod 스키마입니다. (선택적)\n   * 이 스키마로 파싱된 데이터가 TData 타입이 됩니다.\n   */\n  responseSchema?: ResponseSchema;\n\n  /**\n   * Mutation 함수 실행 전 호출되는 콜백입니다. (선택적)\n   * 컨텍스트를 반환하여 onSuccess, onError, onSettled에서 사용할 수 있습니다.\n   */\n  onMutate?: (\n    variables: TVariables\n  ) => Promise<TContext | void> | TContext | void;\n\n  /**\n   * Mutation 성공 시 호출되는 콜백입니다. (선택적)\n   */\n  onSuccess?: (\n    data: InferIfZodSchema<ResponseSchema, TData>,\n    variables: TVariables,\n    context: TContext | undefined\n  ) => Promise<void> | void;\n\n  /**\n   * Mutation 실패 시 호출되는 콜백입니다. (선택적)\n   */\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined\n  ) => Promise<void> | void;\n\n  /**\n   * Mutation 성공 또는 실패 여부와 관계없이 항상 호출되는 콜백입니다. (선택적)\n   */\n  onSettled?: (\n    data: InferIfZodSchema<ResponseSchema, TData> | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined\n  ) => Promise<void> | void;\n\n  /**\n   * Mutation 성공 시 무효화할 쿼리 키 목록 또는 동적으로 키 목록을 반환하는 함수입니다. (선택적)\n   */\n  invalidateQueries?:\n    | QueryKey[]\n    | ((\n        data: InferIfZodSchema<ResponseSchema, TData>,\n        variables: TVariables,\n        context: TContext | undefined\n      ) => QueryKey[]);\n\n  /**\n   * 이 Mutation에만 적용될 특정 fetch 설정을 지정합니다. (선택적)\n   * baseURL, timeout, headers 등이 포함될 수 있습니다.\n   */\n  fetchConfig?: Omit<\n    FetchConfig,\n    \"url\" | \"method\" | \"params\" | \"data\" | \"schema\"\n  >;\n}\n\n/**\n * URL + Method 기반 Mutation 설정\n */\ninterface UrlBasedMutationConfig<\n  TVariables = any,\n  TData = any,\n  TError = Error,\n  TContext = unknown,\n  RequestSchema extends ZodType = never,\n  ResponseSchema extends ZodType = never\n> extends BaseMutationConfig<\n    TVariables,\n    TData,\n    TError,\n    TContext,\n    RequestSchema,\n    ResponseSchema\n  > {\n  /**\n   * API 요청 URL을 생성하는 함수 또는 문자열입니다.\n   * TVariables를 인자로 받아 URL 문자열을 반환합니다.\n   */\n  url: string | ((variables: TVariables) => string);\n\n  /**\n   * HTTP 요청 메서드입니다. (예: \"POST\", \"PUT\", \"DELETE\")\n   */\n  method: HttpMethod;\n\n  /**\n   * mutationFn이 있으면 안됨\n   */\n  mutationFn?: never;\n}\n\n/**\n * Custom Function 기반 Mutation 설정\n */\ninterface FunctionBasedMutationConfig<\n  TVariables = any,\n  TData = any,\n  TError = Error,\n  TContext = unknown,\n  RequestSchema extends ZodType = never,\n  ResponseSchema extends ZodType = never\n> extends BaseMutationConfig<\n    TVariables,\n    TData,\n    TError,\n    TContext,\n    RequestSchema,\n    ResponseSchema\n  > {\n  /**\n   * 사용자 정의 mutation 함수입니다.\n   * variables와 fetcher를 인자로 받아 복잡한 로직을 처리할 수 있습니다.\n   */\n  mutationFn: (\n    variables: TVariables,\n    fetcher: NextTypeFetch\n  ) => Promise<InferIfZodSchema<ResponseSchema, TData>>;\n\n  /**\n   * url/method가 있으면 안됨\n   */\n  url?: never;\n  method?: never;\n}\n\n/**\n * Mutation을 정의하기 위한 설정 객체 인터페이스입니다.\n * URL + Method 방식 또는 Custom Function 방식 중 하나를 선택할 수 있습니다.\n */\nexport type MutationConfig<\n  TVariables = any,\n  TData = any,\n  TError = Error,\n  TContext = unknown,\n  RequestSchema extends ZodType = never,\n  ResponseSchema extends ZodType = never\n> =\n  | UrlBasedMutationConfig<\n      TVariables,\n      TData,\n      TError,\n      TContext,\n      RequestSchema,\n      ResponseSchema\n    >\n  | FunctionBasedMutationConfig<\n      TVariables,\n      TData,\n      TError,\n      TContext,\n      RequestSchema,\n      ResponseSchema\n    >;\n\n/**\n * MutationFactory에 전달될 입력 타입입니다.\n * 각 키는 특정 mutation을 나타내며, 값은 해당 mutation의 MutationConfig입니다.\n */\nexport type MutationFactoryInput = Record<\n  string,\n  MutationConfig<any, any, any, any, any, any>\n>;\n\n/**\n * MutationConfig에서 TVariables 타입을 추출합니다.\n */\nexport type ExtractMutationVariables<T> = T extends MutationConfig<\n  infer V,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n  ? V\n  : never;\n\n/**\n * MutationConfig에서 TData 타입을 추출합니다.\n * responseSchema가 있으면 해당 스키마의 추론 타입을, 없으면 TData를 사용합니다.\n */\nexport type ExtractMutationData<T> = T extends MutationConfig<\n  any,\n  infer D,\n  any,\n  any,\n  any,\n  infer RS\n>\n  ? [RS] extends [ZodType]\n    ? z.infer<RS>\n    : D\n  : never;\n\n/**\n * MutationConfig에서 TError 타입을 추출합니다.\n */\nexport type ExtractMutationError<T> = T extends MutationConfig<\n  any,\n  any,\n  infer E,\n  any,\n  any,\n  any\n>\n  ? E\n  : Error;\n\n/**\n * 에러 메시지 상수\n */\nconst ERROR_MESSAGES = {\n  BOTH_APPROACHES:\n    \"MutationConfig cannot have both 'mutationFn' and 'url'+'method' at the same time. \" +\n    \"Choose either custom function approach (mutationFn) or URL-based approach (url + method).\",\n  MISSING_APPROACHES:\n    \"MutationConfig must have either 'mutationFn' or both 'url' and 'method'. \" +\n    \"Provide either a custom function or URL-based configuration.\",\n} as const;\n\n/**\n * Mutation 설정의 유효성을 검증\n */\nexport function validateMutationConfig(\n  config: MutationConfig<any, any, any, any, any, any>\n): void {\n  const hasMutationFn = isFunction(config.mutationFn);\n  const hasUrlMethod = config.url && config.method;\n\n  if (hasMutationFn && hasUrlMethod) {\n    throw new Error(ERROR_MESSAGES.BOTH_APPROACHES);\n  }\n\n  if (!hasMutationFn && !hasUrlMethod) {\n    throw new Error(ERROR_MESSAGES.MISSING_APPROACHES);\n  }\n}\n\n/**\n * Mutation 정의 객체를 받아 그대로 반환하는 팩토리 함수입니다.\n * 타입 추론을 돕고, 중앙에서 mutation들을 관리할 수 있게 합니다.\n * @param defs Mutation 정의 객체\n * @returns 전달된 Mutation 정의 객체\n */\nexport function createMutationFactory<T extends MutationFactoryInput>(\n  defs: T\n): T {\n  // 각 MutationConfig 검증\n  Object.entries(defs).forEach(([key, config]) => {\n    try {\n      validateMutationConfig(config);\n    } catch (error) {\n      throw new Error(\n        `Invalid MutationConfig for '${key}': ${(error as Error).message}`\n      );\n    }\n  });\n\n  return defs;\n}\n","import { isArray, isString } from \"es-toolkit/compat\";\nimport QuickLRU from \"quick-lru\";\n\n/**\n * 쿼리키를 직렬화하여 string으로 변환합니다.\n * @param key 쿼리키(배열 또는 문자열)\n */\nexport function serializeQueryKey(key: string | readonly unknown[]): string {\n  return isArray(key) ? JSON.stringify(key) : isString(key) ? key : String(key);\n}\n\n/**\n * 쿼리 상태 타입\n */\nexport type QueryState<T = unknown> = {\n  data?: T;\n  error?: unknown;\n  isLoading: boolean;\n  isFetching: boolean;\n  updatedAt: number;\n};\n\n/**\n * QueryCache 옵션\n */\nexport interface QueryCacheOptions {\n  /**\n   * 메모리 보호를 위한 최대 쿼리 수 (하드 리미트)\n   * 이 수를 초과하면 LRU(Least Recently Used) 알고리즘으로 가장 오래된 쿼리부터 즉시 제거됩니다.\n   * gcTime과는 별개로 동작하며, 메모리 사용량을 제한하는 안전장치 역할을 합니다.\n   * @default 1000\n   */\n  maxQueries?: number;\n}\n\n/**\n * 타이머 타입 (브라우저/Node.js 호환)\n */\ntype TimerHandle = ReturnType<typeof setTimeout>;\n\n/**\n * 쿼리 캐시 클래스\n *\n * 두 가지 캐시 전략을 사용합니다:\n * 1. **메모리 보호 (Hard Limit)**: maxQueries로 설정된 수를 초과하면 LRU 알고리즘으로 즉시 제거\n * 2. **생명주기 관리 (Soft Limit)**: 구독자가 0이 된 후 gcTime 시간이 지나면 가비지 컬렉션으로 제거\n */\nexport class QueryCache {\n  private cache: QuickLRU<string, QueryState>;\n  private subscribers = new Map<string, number>();\n  private listeners = new Map<string, Set<() => void>>();\n  private gcTimers = new Map<string, TimerHandle>();\n\n  constructor(options: QueryCacheOptions = {}) {\n    const { maxQueries = 1000 } = options;\n    this.cache = new QuickLRU({\n      maxSize: maxQueries,\n      onEviction: (key: string, value: QueryState) => {\n        // LRU에 의해 자동 제거될 때 메타데이터도 함께 정리\n        this.cleanupMetadata(key);\n      },\n    });\n  }\n\n  /**\n   * 특정 키의 메타데이터를 정리합니다.\n   */\n  private cleanupMetadata(sKey: string): void {\n    this.subscribers.delete(sKey);\n    this.listeners.delete(sKey);\n    const timer = this.gcTimers.get(sKey);\n    if (timer) {\n      clearTimeout(timer);\n      this.gcTimers.delete(sKey);\n    }\n  }\n\n  set(key: string | readonly unknown[], state: QueryState) {\n    const sKey = serializeQueryKey(key);\n    this.cache.set(sKey, state);\n    this.notifyListeners(sKey);\n  }\n\n  get<T = any>(key: string | readonly unknown[]): QueryState<T> | undefined {\n    const result = this.cache.get(serializeQueryKey(key)) as\n      | QueryState<T>\n      | undefined;\n    return result;\n  }\n\n  has(key: string | readonly unknown[]): boolean {\n    const result = this.cache.has(serializeQueryKey(key));\n    return result;\n  }\n\n  delete(key: string | readonly unknown[]): void {\n    const sKey = serializeQueryKey(key);\n    this.cache.delete(sKey);\n    this.cleanupMetadata(sKey);\n  }\n\n  clear(): void {\n    this.cache.clear();\n    this.subscribers.clear();\n    this.listeners.clear();\n    this.gcTimers.forEach((timer) => {\n      clearTimeout(timer);\n    });\n    this.gcTimers.clear();\n  }\n\n  getAll(): Record<string, QueryState> {\n    const result: Record<string, QueryState> = {};\n    for (const [key, value] of this.cache.entries()) {\n      result[key] = value;\n    }\n    return result;\n  }\n\n  /**\n   * 컴포넌트가 쿼리를 구독하여 refetch 콜백을 등록합니다.\n   * @returns unsubscribe 함수\n   */\n  subscribeListener(\n    key: string | readonly unknown[],\n    listener: () => void\n  ): () => void {\n    const sKey = serializeQueryKey(key);\n    if (!this.listeners.has(sKey)) {\n      this.listeners.set(sKey, new Set());\n    }\n    this.listeners.get(sKey)!.add(listener);\n\n    return () => {\n      const listenerSet = this.listeners.get(sKey);\n      if (listenerSet) {\n        listenerSet.delete(listener);\n        // 빈 Set이 되면 메모리 절약을 위해 제거\n        if (listenerSet.size === 0) {\n          this.listeners.delete(sKey);\n        }\n      }\n    };\n  }\n\n  /**\n   * 특정 쿼리 키의 모든 리스너에게 알림을 보냅니다.\n   */\n  notifyListeners(key: string | readonly unknown[]): void {\n    const sKey = serializeQueryKey(key);\n    Promise.resolve().then(() => {\n      this.listeners.get(sKey)?.forEach((l) => l());\n    });\n  }\n\n  /**\n   * 구독자 수 증가 및 gcTime 타이머 해제 (생명주기 관리)\n   */\n  subscribe(key: string | readonly unknown[]): void {\n    const sKey = serializeQueryKey(key);\n    const prev = this.subscribers.get(sKey) ?? 0;\n    this.subscribers.set(sKey, prev + 1);\n    const timer = this.gcTimers.get(sKey);\n    if (timer) {\n      clearTimeout(timer);\n      this.gcTimers.delete(sKey);\n    }\n  }\n\n  /**\n   * 구독자 수 감소 및 0이 되면 gcTime 타이머 시작 (생명주기 관리)\n   */\n  unsubscribe(key: string | readonly unknown[], gcTime: number): void {\n    const sKey = serializeQueryKey(key);\n    const prev = this.subscribers.get(sKey) ?? 0;\n    if (prev <= 1) {\n      this.subscribers.set(sKey, 0);\n      const timer = setTimeout(() => {\n        this.delete(key);\n      }, gcTime);\n      this.gcTimers.set(sKey, timer);\n    } else {\n      this.subscribers.set(sKey, prev - 1);\n    }\n  }\n\n  serialize(): Record<string, QueryState> {\n    return this.getAll();\n  }\n\n  deserialize(cache: Record<string, QueryState>): void {\n    Object.entries(cache).forEach(([key, state]) => {\n      this.cache.set(key, state);\n    });\n  }\n\n  /**\n   * 현재 캐시 크기를 반환합니다.\n   */\n  get size(): number {\n    return this.cache.size;\n  }\n\n  /**\n   * 캐시의 최대 크기를 반환합니다.\n   */\n  get maxSize(): number {\n    return this.cache.maxSize;\n  }\n\n  /**\n   * 캐시 통계를 반환합니다.\n   *\n   * @description 디버깅 및 모니터링 목적으로 사용됩니다.\n   * 성능 분석, 메모리 사용량 추적, 캐시 상태 확인 등에 활용할 수 있습니다.\n   *\n   * @example\n   * ```typescript\n   * const queryClient = useQueryClient();\n   * const stats = queryClient.getQueryCache().getStats();\n   * console.log('Current cache size:', stats.cacheSize);\n   * console.log('Active GC timers:', stats.activeGcTimersCount);\n   * ```\n   */\n  getStats() {\n    return {\n      /** 현재 캐시된 쿼리 수 */\n      cacheSize: this.cache.size,\n      /** 최대 쿼리 수 (메모리 보호 한계) */\n      maxSize: this.cache.maxSize,\n      /** 활성 구독자 수 */\n      subscribersCount: this.subscribers.size,\n      /** 등록된 리스너 수 */\n      listenersCount: this.listeners.size,\n      /** 활성 GC 타이머 수 (생명주기 관리 중인 쿼리) */\n      activeGcTimersCount: this.gcTimers.size,\n    };\n  }\n}\n","import { QueryCache } from \"../cache/query-cache\";\nimport type { QueryState, QueryCacheOptions } from \"../cache/query-cache\";\nimport { isArray, isString, forEach, isEqual } from \"es-toolkit/compat\";\nimport { createFetch } from \"../../core/client\";\nimport type { FetchConfig, NextTypeFetch } from \"../../types/index\";\nimport type { QueryConfig } from \"../factories/query-factory\";\n\nexport interface QueryClientOptions extends FetchConfig {\n  fetcher?: NextTypeFetch;\n  /**\n   * QueryCache 옵션\n   */\n  queryCache?: QueryCacheOptions;\n}\n\nexport class QueryClient {\n  private cache: QueryCache;\n  private fetcher: NextTypeFetch;\n\n  constructor(options?: QueryClientOptions) {\n    this.cache = new QueryCache(options?.queryCache);\n    this.fetcher = options?.fetcher || createFetch(options);\n  }\n\n  has(key: string | readonly unknown[]): boolean {\n    return this.cache.has(key);\n  }\n\n  getFetcher() {\n    return this.fetcher;\n  }\n\n  /**\n   * 쿼리 상태 조회\n   */\n  get<T = unknown>(\n    key: string | readonly unknown[]\n  ): QueryState<T> | undefined {\n    return this.cache.get<T>(key);\n  }\n\n  /**\n   * 쿼리 상태 저장\n   */\n  set(key: string | readonly unknown[], state: QueryState): void {\n    this.cache.set(key, state);\n  }\n\n  /**\n   * 쿼리 데이터만 업데이트 (optimistic update에 최적화)\n   * 기존 상태(isLoading, isFetching, error)를 유지하면서 data와 updatedAt만 업데이트\n   */\n  setQueryData<T = unknown>(\n    key: string | readonly unknown[],\n    updater: T | ((oldData: T | undefined) => T | undefined)\n  ): void {\n    const existing = this.get<T>(key);\n    \n    const newData = typeof updater === 'function' \n      ? (updater as (oldData: T | undefined) => T | undefined)(existing?.data)\n      : updater;\n\n    // 기존 상태를 유지하면서 data와 updatedAt만 업데이트\n    const newState: QueryState<T> = {\n      data: newData,\n      error: existing?.error,\n      isLoading: existing?.isLoading ?? false,\n      isFetching: existing?.isFetching ?? false,\n      updatedAt: Date.now(),\n    };\n\n    this.set(key, newState);\n  }\n\n  /**\n   * 쿼리 상태 삭제\n   */\n  delete(key: string | readonly unknown[]): void {\n    this.cache.delete(key);\n  }\n\n  /**\n   * 모든 쿼리 상태 반환\n   */\n  getAll(): Record<string, QueryState> {\n    return this.cache.getAll();\n  }\n\n  /**\n   * 모든 쿼리 상태 초기화\n   */\n  clear(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * 특정 쿼리키(혹은 prefix)로 시작하는 모든 쿼리 캐시를 무효화(삭제)\n   * 예: invalidateQueries(['user']) → ['user', ...]로 시작하는 모든 캐시 삭제\n   */\n  invalidateQueries(prefix: string | readonly unknown[]) {\n    const all = this.getAll();\n    if (isArray(prefix)) {\n      const prefixArr = Array.from(prefix);\n      forEach(Object.keys(all), (key) => {\n        try {\n          const keyArr = JSON.parse(key);\n          if (\n            Array.isArray(keyArr) &&\n            isEqual(keyArr.slice(0, prefixArr.length), prefixArr)\n          ) {\n            const currentState = this.cache.get(keyArr);\n            if (currentState) {\n              this.cache.set(keyArr, { ...currentState, updatedAt: 0 });\n            }\n          }\n        } catch {\n          // string key는 무시\n        }\n      });\n    } else {\n      const prefixStr = isString(prefix) ? prefix : String(prefix);\n      forEach(Object.keys(all), (key) => {\n        if (key.startsWith(prefixStr)) {\n          const currentState = this.cache.get(key);\n          if (currentState) {\n            this.cache.set(key, { ...currentState, updatedAt: 0 });\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * 구독자 관리 (public)\n   */\n  subscribeListener(\n    key: string | readonly unknown[],\n    listener: () => void\n  ): () => void {\n    return this.cache.subscribeListener(key, listener);\n  }\n  subscribe(key: string | readonly unknown[]): void {\n    this.cache.subscribe(key);\n  }\n  unsubscribe(key: string | readonly unknown[], gcTime: number): void {\n    this.cache.unsubscribe(key, gcTime);\n  }\n\n  // 기존 fetchFn 방식\n  async prefetchQuery<T = unknown>(\n    key: string | readonly unknown[],\n    fetchFn: () => Promise<T>\n  ): Promise<T>;\n\n  // QueryConfig 방식 (오버로드)\n  async prefetchQuery<T = unknown>(\n    query: QueryConfig<any, any>,\n    params: any\n  ): Promise<T>;\n\n  // 구현\n  async prefetchQuery<T = unknown>(\n    keyOrQuery: string | readonly unknown[] | QueryConfig<any, any>,\n    fetchFnOrParams: (() => Promise<T>) | any\n  ): Promise<T> {\n    // QueryConfig 방식인지 확인\n    if (\n      typeof keyOrQuery === \"object\" &&\n      keyOrQuery &&\n      \"cacheKey\" in keyOrQuery\n    ) {\n      const query = keyOrQuery as QueryConfig<any, any>;\n      const params = fetchFnOrParams;\n      const cacheKey = query.cacheKey(params);\n\n      const fetchFn = async (): Promise<T> => {\n        let data: any;\n\n        // queryFn이 있는 경우 커스텀 함수 사용\n        if (query.queryFn) {\n          data = await query.queryFn(params, this.fetcher);\n        } else if (query.url) {\n          // 기존 URL 기반 방식\n          const url = query.url(params);\n          const response = await this.fetcher.get(url, query.fetchConfig);\n          data = response.data;\n        } else {\n          throw new Error(\n            \"Either 'url' or 'queryFn' must be provided in QueryConfig\"\n          );\n        }\n\n        // 스키마 검증\n        if (query.schema) {\n          data = query.schema.parse(data);\n        }\n\n        // select 처리\n        if (query.select) {\n          data = query.select(data);\n        }\n\n        return data;\n      };\n\n      return this.prefetchQuery(cacheKey, fetchFn);\n    }\n\n    // 기존 fetchFn 방식\n    const key = keyOrQuery as string | readonly unknown[];\n    const fetchFn = fetchFnOrParams as () => Promise<T>;\n\n    const data = await fetchFn();\n    this.set(key, {\n      data,\n      error: undefined,\n      isLoading: false,\n      isFetching: false,\n      updatedAt: Date.now(),\n    });\n    return data;\n  }\n\n  dehydrate(): Record<string, QueryState> {\n    return this.cache.serialize();\n  }\n\n  hydrate(cache: Record<string, QueryState>): void {\n    this.cache.deserialize(cache);\n  }\n\n  /**\n   * 캐시 통계를 반환합니다. (디버깅 목적)\n   *\n   * @description 성능 분석, 메모리 사용량 추적, 캐시 상태 확인 등에 활용할 수 있습니다.\n   */\n  getQueryCache() {\n    return this.cache;\n  }\n}\n","import { QueryClient } from \"./query-client\";\nimport type { QueryClientOptions } from \"./query-client\";\nimport type { NextTypeFetch } from \"../../types/index\";\n\n/**\n * 인터셉터 설정 함수 타입\n */\nexport type InterceptorSetupFunction = (fetcher: NextTypeFetch) => void;\n\n/**\n * 인터셉터 설정을 포함한 QueryClient 옵션\n */\nexport interface QueryClientOptionsWithInterceptors extends QueryClientOptions {\n  /**\n   * 인터셉터 설정 함수\n   * fetcher 인스턴스를 받아서 인터셉터를 등록하는 함수\n   */\n  setupInterceptors?: InterceptorSetupFunction;\n}\n\n/**\n * 전역 QueryClient 인스턴스 (클라이언트 환경에서만 사용)\n */\nlet globalQueryClient: QueryClient | undefined = undefined;\n\n/**\n * 기본 QueryClient 옵션\n */\nlet defaultOptions: QueryClientOptionsWithInterceptors | undefined = undefined;\n\n/**\n * 기본 QueryClient 옵션을 설정합니다.\n * 앱 시작 시 한 번만 호출하면 됩니다.\n *\n * @internal React의 configureQueryClient를 사용하는 것을 권장합니다.\n */\nexport function setDefaultQueryClientOptions(\n  options: QueryClientOptionsWithInterceptors\n): void {\n  defaultOptions = options;\n\n  // 클라이언트 환경에서 이미 생성된 전역 인스턴스가 있다면 재생성\n  if (typeof window !== \"undefined\" && globalQueryClient) {\n    globalQueryClient = undefined;\n  }\n}\n\n/**\n * 인터셉터 설정을 포함한 QueryClient를 생성합니다.\n */\nfunction createQueryClientWithSetup(\n  options?: QueryClientOptionsWithInterceptors\n): QueryClient {\n  if (!options?.setupInterceptors) {\n    return new QueryClient(options);\n  }\n\n  const { setupInterceptors, ...clientOptions } = options;\n  const client = new QueryClient(clientOptions);\n\n  // 인터셉터 설정 실행\n  setupInterceptors(client.getFetcher());\n\n  return client;\n}\n\n/**\n * 환경에 맞는 QueryClient를 자동으로 반환합니다.\n * - 서버 환경: 항상 새로운 인스턴스 생성 (요청 격리)\n * - 클라이언트 환경: 싱글톤 패턴 사용 (상태 유지)\n */\nexport function getQueryClient(\n  options?: QueryClientOptionsWithInterceptors\n): QueryClient {\n  const finalOptions = options || defaultOptions;\n\n  // 서버 환경에서는 항상 새로운 인스턴스 생성\n  if (typeof window === \"undefined\") {\n    return createQueryClientWithSetup(finalOptions);\n  }\n\n  // 클라이언트 환경에서는 싱글톤 패턴 사용\n  if (!globalQueryClient) {\n    globalQueryClient = createQueryClientWithSetup(finalOptions);\n  }\n\n  return globalQueryClient;\n}\n\n/**\n * 클라이언트 환경에서 전역 QueryClient를 재설정합니다.\n * 주로 테스트나 특수한 경우에 사용됩니다.\n */\nexport function resetQueryClient(): void {\n  if (typeof window !== \"undefined\") {\n    globalQueryClient = undefined;\n  }\n}\n\n/**\n * 인터셉터 설정을 포함한 QueryClient 생성 헬퍼 함수\n *\n * @example\n * ```typescript\n * import { createQueryClientWithInterceptors } from 'next-type-fetch';\n *\n * const queryClient = createQueryClientWithInterceptors({\n *   baseURL: 'https://api.example.com',\n * }, (fetcher) => {\n *   // 인터셉터 설정\n *   fetcher.interceptors.request.use((config) => {\n *     config.headers = config.headers || {};\n *     config.headers['Authorization'] = `Bearer ${getToken()}`;\n *     return config;\n *   });\n * });\n * ```\n */\nexport function createQueryClientWithInterceptors(\n  options: QueryClientOptions,\n  setupInterceptors: InterceptorSetupFunction\n): QueryClient {\n  return createQueryClientWithSetup({\n    ...options,\n    setupInterceptors,\n  });\n}\n","import { isEqual, isPlainObject, keys, isArray } from \"es-toolkit/compat\";\n\n/**\n * Structural Sharing 구현\n * es-toolkit/compat 함수들을 사용한 참조 안정성 최적화\n *\n * @description\n * 이 함수는 두 값을 비교하여 값이 동일한 경우 이전 참조를 유지하는\n * \"Structural Sharing\" 최적화를 수행합니다. 이를 통해 React의 렌더링 최적화와\n * 메모이제이션 효과를 얻을 수 있습니다.\n *\n * @param prev - 이전 값\n * @param next - 새로운 값\n * @returns 최적화된 값 (가능한 경우 이전 참조 유지)\n *\n * @example\n * ```typescript\n * const prev = { user: { id: 1, name: 'John' } };\n * const next = { user: { id: 1, name: 'John' } };\n * const result = replaceEqualDeep(prev, next);\n * console.log(result === prev); // true (참조가 유지됨)\n * ```\n */\nexport function replaceEqualDeep<T>(prev: T, next: T): T {\n  // 1. 참조 동일성 체크 (가장 빠른 경로)\n  if (prev === next) {\n    return prev;\n  }\n\n  // 2. 깊은 비교로 값이 같으면 이전 참조 유지 (Structural Sharing)\n  if (isEqual(prev, next)) {\n    return prev;\n  }\n\n  // 3. null/undefined 처리\n  if (prev == null || next == null) {\n    return next;\n  }\n\n  // 4. 배열 처리\n  if (isArray(prev) && isArray(next)) {\n    if (prev.length !== next.length) {\n      return next;\n    }\n\n    let hasChanged = false;\n    const result = prev.map((item, index) => {\n      const nextItem = replaceEqualDeep(item, next[index]);\n      if (nextItem !== item) {\n        hasChanged = true;\n      }\n      return nextItem;\n    });\n\n    return hasChanged ? (result as T) : prev;\n  }\n\n  // 5. 배열과 비배열 타입이 섞인 경우\n  if (isArray(prev) !== isArray(next)) {\n    return next;\n  }\n\n  // 6. 순수 객체 처리\n  if (isPlainObject(prev) && isPlainObject(next)) {\n    const prevObj = prev as Record<string, unknown>;\n    const nextObj = next as Record<string, unknown>;\n    const prevKeys = keys(prevObj);\n    const nextKeys = keys(nextObj);\n\n    // 키 개수가 다르면 새 객체 반환\n    if (prevKeys.length !== nextKeys.length) {\n      return next;\n    }\n\n    let hasChanged = false;\n    const result: Record<string, unknown> = {};\n\n    for (const key of nextKeys) {\n      // 이전 객체에 키가 없으면 새 객체 반환\n      if (!(key in prevObj)) {\n        return next;\n      }\n\n      const prevValue = prevObj[key];\n      const nextValue = nextObj[key];\n      const optimizedValue = replaceEqualDeep(prevValue, nextValue);\n\n      if (optimizedValue !== prevValue) {\n        hasChanged = true;\n      }\n      result[key] = optimizedValue;\n    }\n\n    return hasChanged ? (result as T) : prev;\n  }\n\n  // 7. 객체가 아닌 경우 또는 다른 타입의 객체인 경우\n  return next;\n}\n","import type { QueryObserverResult } from \"../types\";\n\n/**\n * Tracked Properties 구현\n * Proxy를 사용하여 실제 사용된 속성만 추적\n */\nexport class TrackedResult<T = unknown, E = unknown> {\n  private trackedProps = new Set<keyof QueryObserverResult<T, E>>();\n  private result: QueryObserverResult<T, E>;\n  private cachedProxy: QueryObserverResult<T, E> | null = null;\n\n  constructor(result: QueryObserverResult<T, E>) {\n    this.result = result;\n  }\n\n  createProxy(): QueryObserverResult<T, E> {\n    // 이미 캐시된 Proxy가 있으면 재사용\n    if (this.cachedProxy) {\n      return this.cachedProxy;\n    }\n\n    this.cachedProxy = new Proxy(this.result, {\n      get: (target, prop) => {\n        // 속성 접근 추적 - 유효한 프로퍼티만 추적\n        if (typeof prop === \"string\" && prop in target) {\n          this.trackedProps.add(prop as keyof QueryObserverResult<T, E>);\n        }\n        return target[prop as keyof QueryObserverResult<T, E>];\n      },\n    });\n\n    return this.cachedProxy;\n  }\n\n  getTrackedProps(): Set<keyof QueryObserverResult<T, E>> {\n    return this.trackedProps;\n  }\n\n  hasTrackedProp(prop: keyof QueryObserverResult<T, E>): boolean {\n    return this.trackedProps.has(prop);\n  }\n\n  getResult(): QueryObserverResult<T, E> {\n    return this.result;\n  }\n\n  // 결과가 변경될 때 캐시 무효화\n  updateResult(newResult: QueryObserverResult<T, E>): void {\n    this.result = newResult;\n    this.cachedProxy = null; // 캐시 무효화\n  }\n}\n","import type { QueryClient } from \"../../client/query-client\";\nimport type { QueryObserverOptions } from \"../types\";\nimport type { FetchConfig, NextTypeFetch } from \"../../../types/index\";\nimport { PlaceholderManager } from \"./placeholder-manager\";\nimport { isNotNil } from \"es-toolkit/predicate\";\nimport { merge } from \"es-toolkit/compat\";\n\n/**\n * QueryObserver fetch 관리자 클래스\n *\n * @description\n * QueryObserver의 데이터 페칭 로직을 담당합니다.\n * fetch 실행 조건 확인, 실제 데이터 페칭, 상태 업데이트,\n * 에러 처리를 관리합니다.\n */\nexport class FetchManager<T = unknown> {\n  private queryClient: QueryClient;\n  private placeholderManager: PlaceholderManager<T>;\n\n  constructor(\n    queryClient: QueryClient,\n    placeholderManager: PlaceholderManager<T>\n  ) {\n    this.queryClient = queryClient;\n    this.placeholderManager = placeholderManager;\n  }\n\n  /**\n   * Fetch 실행\n   * enabled 옵션과 stale 상태를 확인하여 필요한 경우에만 페칭을 수행합니다.\n   */\n  async executeFetch<T>(\n    cacheKey: string,\n    options: QueryObserverOptions<T>,\n    onComplete?: () => void\n  ): Promise<void> {\n    const { enabled = true, staleTime = 0 } = options;\n\n    if (!enabled) return;\n\n    const cached = this.queryClient.get<T>(cacheKey);\n    const isStale = cached ? Date.now() - cached.updatedAt >= staleTime : true;\n\n    if (!cached || isStale) {\n      await this.fetchData(cacheKey, options, onComplete);\n    }\n  }\n\n  /**\n   * 데이터 페칭\n   * 실제 HTTP 요청을 수행하고 결과를 캐시에 저장합니다.\n   */\n  async fetchData<T>(\n    cacheKey: string,\n    options: QueryObserverOptions<T>,\n    onComplete?: () => void\n  ): Promise<void> {\n    try {\n      // fetch 설정이 이미 다른 곳에서 처리되었는지 확인\n      const currentState = this.queryClient.get<T>(cacheKey);\n\n      // 아직 isFetching이 설정되지 않은 경우에만 설정\n      if (currentState && !currentState.isFetching) {\n        this.queryClient.set(cacheKey, {\n          ...currentState,\n          isFetching: true,\n        });\n      }\n\n      // fetch 결과\n      const result = await this.performHttpRequest(options);\n\n      // 성공 상태 저장 - placeholderData 비활성화\n      this.placeholderManager.deactivatePlaceholder();\n\n      this.queryClient.set(cacheKey, {\n        data: result,\n        error: undefined,\n        isLoading: false,\n        isFetching: false,\n        updatedAt: Date.now(),\n      });\n\n      // 완료 콜백 실행\n      onComplete?.();\n    } catch (error: any) {\n      // 에러 상태 저장 - placeholderData 비활성화\n      this.placeholderManager.deactivatePlaceholder();\n\n      this.queryClient.set(cacheKey, {\n        data: undefined as T | undefined,\n        error,\n        isLoading: false,\n        isFetching: false,\n        updatedAt: Date.now(),\n      });\n\n      // 에러 시에도 완료 콜백 실행\n      onComplete?.();\n    }\n  }\n\n  /**\n   * HTTP 요청 수행\n   * 실제 네트워크 요청을 처리하고 스키마 검증을 수행합니다.\n   */\n  private async performHttpRequest<T>(\n    options: QueryObserverOptions<T>\n  ): Promise<T> {\n    const fetcher = this.queryClient.getFetcher();\n\n    // queryFn 방식 처리\n    if (\"queryFn\" in options && options.queryFn) {\n      return this.executeQueryFn(options, fetcher);\n    }\n\n    // URL 방식 처리\n    if (\"url\" in options && options.url) {\n      return this.executeUrlRequest(options, fetcher);\n    }\n\n    // 이론적으로 도달할 수 없는 코드 (타입 시스템이 보장)\n    throw new Error(\n      \"Invalid QueryObserverOptions: neither 'url' nor 'queryFn' is provided\"\n    );\n  }\n\n  /**\n   * queryFn 실행\n   * Factory 방식과 Options 방식을 구분하여 적절한 매개변수로 호출\n   */\n  private async executeQueryFn<T>(\n    options: QueryObserverOptions<T>,\n    fetcher: NextTypeFetch\n  ): Promise<T> {\n    const queryFn = (options as any).queryFn;\n    let result: any;\n\n    // Factory 방식 (params가 있는 경우)\n    if (\"params\" in options && options.params !== undefined) {\n      result = await queryFn(options.params, fetcher);\n    } else {\n      // Options 방식 (fetcher만 전달)\n      result = await queryFn(fetcher);\n    }\n\n    return this.applySchemaValidation(result, options.schema);\n  }\n\n  /**\n   * URL 기반 요청 실행\n   */\n  private async executeUrlRequest<T>(\n    options: QueryObserverOptions<T>,\n    fetcher: NextTypeFetch\n  ): Promise<T> {\n    const url = (options as any).url;\n    const config = this.buildFetchConfig(options);\n    const response = await fetcher.get(url, config);\n\n    return this.applySchemaValidation(response.data, options.schema);\n  }\n\n  /**\n   * Fetch 설정 구성\n   */\n  private buildFetchConfig<T>(options: QueryObserverOptions<T>): FetchConfig {\n    let config: FetchConfig = merge({}, options.fetchConfig ?? {});\n\n    if (isNotNil(options.params)) {\n      config = merge(config, { params: options.params });\n    }\n    if (isNotNil(options.schema)) {\n      config = merge(config, { schema: options.schema });\n    }\n\n    return config;\n  }\n\n  /**\n   * 스키마 검증 적용\n   */\n  private applySchemaValidation<T>(data: any, schema?: any): T {\n    if (schema) {\n      return schema.parse(data) as T;\n    }\n    return data as T;\n  }\n\n  /**\n   * 수동 refetch\n   * 캐시 키와 옵션을 받아 즉시 데이터를 다시 페칭합니다.\n   */\n  async refetch<T>(\n    cacheKey: string,\n    options: QueryObserverOptions<T>,\n    onComplete?: () => void\n  ): Promise<void> {\n    await this.fetchData(cacheKey, options, onComplete);\n  }\n\n  /**\n   * 페칭 상태 확인\n   * 현재 페칭 중인지 확인합니다.\n   */\n  isFetching<T>(cacheKey: string): boolean {\n    const cached = this.queryClient.get<T>(cacheKey);\n    return cached?.isFetching ?? false;\n  }\n\n  /**\n   * Stale 상태 확인\n   * 캐시된 데이터가 stale한지 확인합니다.\n   */\n  isStale<T>(cacheKey: string, staleTime: number = 0): boolean {\n    const cached = this.queryClient.get<T>(cacheKey);\n    return cached ? Date.now() - cached.updatedAt >= staleTime : true;\n  }\n}\n","import type { QueryClient } from \"../../client/query-client\";\nimport type { QueryObserverOptions } from \"../types\";\nimport { serializeQueryKey } from \"../../cache/query-cache\";\nimport { PlaceholderManager } from \"./placeholder-manager\";\nimport { pick } from \"es-toolkit/compat\";\n\n/**\n * 옵션 변경 처리 콜백 타입\n */\nexport interface OptionsChangeCallbacks<T, E> {\n  updateResult: () => boolean;\n  scheduleNotifyListeners: () => void;\n  executeFetch: () => Promise<void>;\n  subscribeToCache: () => void;\n  computeResult: () => any;\n  handleCachedDataAvailable: () => void;\n  handleNoCachedData: () => void;\n}\n\n/**\n * QueryObserver 옵션 관리자 클래스\n *\n * @description\n * QueryObserver의 옵션 관리 로직을 담당합니다.\n * 옵션 해시 생성, 변경 감지, 키 변경 처리,\n * 상태 초기화 등을 관리합니다.\n */\nexport class OptionsManager<T = unknown, E = unknown> {\n  private queryClient: QueryClient;\n  private placeholderManager: PlaceholderManager<T>;\n\n  constructor(\n    queryClient: QueryClient,\n    placeholderManager: PlaceholderManager<T>\n  ) {\n    this.queryClient = queryClient;\n    this.placeholderManager = placeholderManager;\n  }\n\n  /**\n   * 옵션 해시 생성\n   * 해시에 포함할 속성들만 선택하여 JSON 직렬화\n   */\n  createOptionsHash<T>(options: QueryObserverOptions<T>): string {\n    // pick을 사용하여 해시에 포함할 속성들만 선택\n    const hashableOptions = pick(options, [\n      \"key\",\n      \"url\",\n      \"params\",\n      \"enabled\",\n      \"staleTime\",\n      \"gcTime\",\n      // queryFn은 함수이므로 해시에서 제외 (함수 참조는 항상 다르므로)\n    ]);\n    return JSON.stringify(hashableOptions);\n  }\n\n  /**\n   * 옵션 변경 여부 확인\n   */\n  isOptionsUnchanged(prevHash: string, newHash: string): boolean {\n    return prevHash === newHash;\n  }\n\n  /**\n   * 키 변경 여부 확인\n   */\n  isKeyChanged(prevKey: string, newKey: string): boolean {\n    return prevKey !== newKey;\n  }\n\n  /**\n   * 옵션만 업데이트 (키는 동일)\n   */\n  updateOptionsOnly<T>(\n    options: QueryObserverOptions<T>,\n    callbacks: OptionsChangeCallbacks<T, E>\n  ): void {\n    const hasChanged = callbacks.updateResult();\n    if (hasChanged) {\n      callbacks.scheduleNotifyListeners();\n    }\n  }\n\n  /**\n   * 옵션과 키 업데이트\n   */\n  updateOptionsAndKey<T>(\n    options: QueryObserverOptions<T>,\n    newHash: string\n  ): { cacheKey: string; optionsHash: string } {\n    const cacheKey = serializeQueryKey(options.key);\n    return { cacheKey, optionsHash: newHash };\n  }\n\n  /**\n   * 키 변경 처리\n   */\n  handleKeyChange<T>(\n    prevOptions: QueryObserverOptions<T>,\n    newCacheKey: string,\n    callbacks: OptionsChangeCallbacks<T, E>\n  ): void {\n    // 이전 구독 해제\n    this.unsubscribeFromPreviousKey(prevOptions);\n\n    // 상태 초기화 (PlaceholderData만 처리)\n    this.placeholderManager.deactivatePlaceholder();\n\n    // 새 키로 구독\n    callbacks.subscribeToCache();\n\n    // 캐시 상태에 따른 처리\n    if (this.queryClient.has(newCacheKey)) {\n      callbacks.handleCachedDataAvailable();\n    } else {\n      callbacks.handleNoCachedData();\n    }\n  }\n\n  /**\n   * 옵션 변경 처리 (키는 동일)\n   */\n  handleOptionsChange<T>(callbacks: OptionsChangeCallbacks<T, E>): void {\n    // 키는 같지만 다른 옵션이 변경된 경우\n    const hasChanged = callbacks.updateResult();\n    callbacks.executeFetch();\n\n    if (hasChanged) {\n      callbacks.scheduleNotifyListeners();\n    }\n  }\n\n  /**\n   * 이전 키 구독 해제\n   */\n  private unsubscribeFromPreviousKey<T>(\n    prevOptions: QueryObserverOptions<T>\n  ): void {\n    this.queryClient.unsubscribe(prevOptions.key, prevOptions.gcTime || 300000);\n  }\n\n  /**\n   * Observer 상태 초기화 (PlaceholderData만 처리)\n   */\n  resetObserverState(): void {\n    this.placeholderManager.deactivatePlaceholder();\n  }\n\n  /**\n   * 캐시된 데이터 처리 로직\n   */\n  handleCachedDataAvailable<T>(\n    cacheKey: string,\n    options: QueryObserverOptions<T>,\n    callbacks: {\n      computeResult: () => any;\n      executeFetch: () => Promise<void>;\n      scheduleNotifyListeners: () => void;\n    }\n  ): { currentResult: any; lastResultReference: any } {\n    // 캐시된 데이터가 있는 경우: 즉시 결과 업데이트, 백그라운드 fetch\n    const currentResult = callbacks.computeResult();\n    const lastResultReference = currentResult;\n\n    // 백그라운드 fetch가 필요한 경우 캐시 상태 미리 업데이트\n    const cached = this.queryClient.get<T>(cacheKey);\n    const isStale = cached\n      ? Date.now() - cached.updatedAt >= (options.staleTime || 0)\n      : true;\n    const shouldFetch = isStale && options.enabled !== false;\n\n    if (shouldFetch && cached) {\n      // 백그라운드 fetch 시작을 위해 isFetching 상태 미리 설정\n      this.queryClient.set(cacheKey, {\n        ...cached,\n        isFetching: true,\n      });\n\n      // 결과 재계산하여 isFetching: true 반영\n      const updatedResult = callbacks.computeResult();\n      callbacks.executeFetch();\n      callbacks.scheduleNotifyListeners();\n\n      return {\n        currentResult: updatedResult,\n        lastResultReference: updatedResult,\n      };\n    }\n\n    // 백그라운드에서 fetch 수행\n    callbacks.executeFetch();\n\n    // 단일 렌더링을 위해 한 번만 알림\n    callbacks.scheduleNotifyListeners();\n\n    return { currentResult, lastResultReference };\n  }\n\n  /**\n   * 캐시된 데이터가 없는 경우 처리\n   */\n  handleNoCachedData<T>(callbacks: OptionsChangeCallbacks<T, E>): void {\n    // 캐시가 없는 경우: placeholderData 사용 가능\n    const hasChanged = callbacks.updateResult();\n    callbacks.executeFetch();\n\n    if (hasChanged) {\n      callbacks.scheduleNotifyListeners();\n    }\n  }\n}\n","import type { QueryClient } from \"../../client/query-client\";\nimport type { QueryState } from \"../../cache/query-cache\";\nimport type { QueryObserverOptions } from \"../types\";\nimport { isEqual, isNil } from \"es-toolkit/compat\";\nimport { isFunction } from \"es-toolkit/predicate\";\n\n/**\n * PlaceholderData 상태 타입\n */\nexport interface PlaceholderState {\n  data: any;\n  isActive: boolean;\n}\n\n/**\n * PlaceholderData 관리자 클래스\n *\n * @description\n * placeholderData 처리를 담당합니다.\n * 캐시와 완전히 독립적으로 UI 레벨에서만 관리되며,\n * 이전 쿼리 데이터를 찾아서 placeholderData로 사용할 수 있습니다.\n */\nexport class PlaceholderManager<T = unknown> {\n  private queryClient: QueryClient;\n  private placeholderState: PlaceholderState | null = null;\n\n  constructor(queryClient: QueryClient) {\n    this.queryClient = queryClient;\n  }\n\n  /**\n   * placeholderData 계산\n   * 캐시와 완전히 독립적으로 처리\n   */\n  computePlaceholderData<T>(options: QueryObserverOptions<T>): any {\n    const { placeholderData } = options;\n\n    if (!placeholderData) return undefined;\n\n    // 직접 값이 제공된 경우 (함수가 아닌 경우)\n    if (!isFunction(placeholderData)) {\n      return placeholderData;\n    }\n\n    // 함수인 경우: 이전 쿼리 데이터 찾기\n    const prevQuery = this.findPreviousQuery(options);\n\n    if (!prevQuery || prevQuery.data === undefined) return undefined;\n\n    return placeholderData(prevQuery.data, prevQuery);\n  }\n\n  /**\n   * 이전 쿼리 데이터 찾기\n   * 같은 타입의 쿼리 중에서 가장 최근에 성공한 쿼리를 찾습니다.\n   */\n  private findPreviousQuery<T>(\n    options: QueryObserverOptions<T>\n  ): QueryState<T> | undefined {\n    const allQueries = this.queryClient.getAll();\n    const currentKey = options.key;\n\n    let mostRecentQuery: QueryState<T> | undefined;\n    let mostRecentTime = 0;\n\n    for (const [keyStr, state] of Object.entries(allQueries)) {\n      try {\n        const keyArray = JSON.parse(keyStr);\n\n        if (this.isValidPreviousQuery(keyArray, currentKey, state, options)) {\n          const updatedAt = (state as QueryState<T>).updatedAt || 0;\n\n          if (this.isMoreRecent(updatedAt, mostRecentTime)) {\n            mostRecentQuery = state as QueryState<T>;\n            mostRecentTime = updatedAt;\n          }\n        }\n      } catch {\n        // JSON 파싱 실패 시 무시\n      }\n    }\n\n    return mostRecentQuery;\n  }\n\n  /**\n   * 유효한 이전 쿼리인지 확인\n   */\n  private isValidPreviousQuery<T>(\n    keyArray: any,\n    currentKey: readonly unknown[],\n    state: any,\n    options: QueryObserverOptions<T>\n  ): boolean {\n    return (\n      this.isArrayKey(keyArray, options) &&\n      this.isSameQueryType(keyArray, currentKey) &&\n      this.isDifferentQueryKey(keyArray, currentKey) &&\n      this.hasValidData(state)\n    );\n  }\n\n  /**\n   * 배열 키인지 확인\n   */\n  private isArrayKey<T>(\n    keyArray: any,\n    options: QueryObserverOptions<T>\n  ): boolean {\n    return Array.isArray(keyArray) && Array.isArray(options.key);\n  }\n\n  /**\n   * 같은 쿼리 타입인지 확인 (첫 번째 키 요소로 판단)\n   */\n  private isSameQueryType(\n    keyArray: any[],\n    currentKey: readonly unknown[]\n  ): boolean {\n    return keyArray[0] === currentKey[0];\n  }\n\n  /**\n   * 다른 쿼리 키인지 확인 (같은 키는 제외)\n   */\n  private isDifferentQueryKey(\n    keyArray: any[],\n    currentKey: readonly unknown[]\n  ): boolean {\n    return !isEqual(keyArray, currentKey);\n  }\n\n  /**\n   * 유효한 데이터가 있는지 확인\n   */\n  private hasValidData<T>(state: any): boolean {\n    return state && !isNil((state as QueryState<T>).data);\n  }\n\n  /**\n   * 더 최근 데이터인지 확인\n   */\n  private isMoreRecent(updatedAt: number, mostRecentTime: number): boolean {\n    return updatedAt > mostRecentTime;\n  }\n\n  /**\n   * PlaceholderData가 유효한지 확인\n   */\n  hasValidPlaceholderData(placeholderData: any): boolean {\n    return !isNil(placeholderData);\n  }\n\n  /**\n   * PlaceholderState 설정\n   */\n  setPlaceholderState(state: PlaceholderState | null): void {\n    this.placeholderState = state;\n  }\n\n  /**\n   * PlaceholderState 가져오기\n   */\n  getPlaceholderState(): PlaceholderState | null {\n    return this.placeholderState;\n  }\n\n  /**\n   * PlaceholderData 비활성화 (fetch 성공 또는 실패 시)\n   */\n  deactivatePlaceholder(): void {\n    this.placeholderState = null;\n  }\n}\n","import type { QueryClient } from \"../../client/query-client\";\nimport type { QueryState } from \"../../cache/query-cache\";\nimport type { QueryObserverOptions, QueryObserverResult } from \"../types\";\nimport { PlaceholderManager } from \"./placeholder-manager\";\nimport { isNil } from \"es-toolkit/compat\";\n\n/**\n * QueryObserver 결과 계산기 클래스\n *\n * @description\n * QueryObserver의 결과 계산 로직을 담당합니다.\n * 캐시 상태, PlaceholderData, 초기 로딩 상태에 따라\n * 적절한 QueryObserverResult를 생성합니다.\n */\nexport class ResultComputer<T = unknown, E = unknown> {\n  private queryClient: QueryClient;\n  private placeholderManager: PlaceholderManager<T>;\n\n  constructor(\n    queryClient: QueryClient,\n    placeholderManager: PlaceholderManager<T>\n  ) {\n    this.queryClient = queryClient;\n    this.placeholderManager = placeholderManager;\n  }\n\n  /**\n   * 결과 계산\n   * 캐시 상태와 placeholderData를 완전히 분리하여 처리\n   */\n  computeResult(\n    cacheKey: string,\n    options: QueryObserverOptions<T>,\n    refetchFn: () => void\n  ): QueryObserverResult<T, E> {\n    const { enabled = true } = options;\n    const cached = this.queryClient.get<T>(cacheKey);\n\n    // 1. enabled가 false인 경우: 비활성화된 상태 반환\n    if (!enabled) {\n      return this.createDisabledResult(cached, options, refetchFn);\n    }\n\n    // 2. 캐시된 데이터가 있는 경우\n    if (this.hasCachedData(cached)) {\n      return this.createCachedResult(cached!, options, refetchFn);\n    }\n\n    // 3. 캐시가 없는 경우: placeholderData 확인\n    const placeholderData =\n      this.placeholderManager.computePlaceholderData(options);\n    if (this.placeholderManager.hasValidPlaceholderData(placeholderData)) {\n      return this.createPlaceholderResult(placeholderData!, options, refetchFn);\n    }\n\n    // 4. 캐시도 placeholderData도 없는 경우: 초기 loading 상태\n    return this.createInitialLoadingResult(refetchFn);\n  }\n\n  /**\n   * 비활성화된 결과 생성 (enabled: false)\n   */\n  private createDisabledResult(\n    cached: QueryState<T> | undefined,\n    options: QueryObserverOptions<T>,\n    refetchFn: () => void\n  ): QueryObserverResult<T, E> {\n    // enabled가 false일 때는 캐시된 데이터가 있어도 로딩하지 않는 상태\n    if (cached) {\n      const finalData = this.applySelect(cached.data, options);\n      const isStale = this.computeStaleTime(cached.updatedAt, options);\n\n      return {\n        data: finalData,\n        error: cached.error as E,\n        isLoading: false, // enabled: false이므로 로딩하지 않음\n        isFetching: false, // enabled: false이므로 fetch하지 않음\n        isError: !!cached.error,\n        isSuccess: this.isSuccessState(cached),\n        isStale,\n        isPlaceholderData: false,\n        refetch: refetchFn,\n      };\n    }\n\n    // 캐시도 없고 enabled도 false인 경우: 비활성화된 초기 상태\n    this.placeholderManager.deactivatePlaceholder();\n\n    return {\n      data: undefined,\n      error: undefined,\n      isLoading: false, // enabled: false이므로 로딩하지 않음\n      isFetching: false, // enabled: false이므로 fetch하지 않음\n      isError: false,\n      isSuccess: false,\n      isStale: true,\n      isPlaceholderData: false,\n      refetch: refetchFn,\n    };\n  }\n\n  /**\n   * 캐시된 데이터가 있는지 확인\n   */\n  private hasCachedData(cached: QueryState<T> | undefined): boolean {\n    return !!cached;\n  }\n\n  /**\n   * 캐시된 결과 생성\n   */\n  private createCachedResult(\n    cached: QueryState<T>,\n    options: QueryObserverOptions<T>,\n    refetchFn: () => void\n  ): QueryObserverResult<T, E> {\n    const finalData = this.applySelect(cached.data, options);\n    const isStale = this.computeStaleTime(cached.updatedAt, options);\n\n    return {\n      data: finalData,\n      error: cached.error as E,\n      isLoading: cached.isLoading,\n      isFetching: cached.isFetching, // 캐시된 상태의 isFetching 값 사용\n      isError: !!cached.error,\n      isSuccess: this.isSuccessState(cached),\n      isStale,\n      isPlaceholderData: false, // 캐시된 데이터는 항상 false\n      refetch: refetchFn,\n    };\n  }\n\n  /**\n   * PlaceholderData 결과 생성\n   */\n  private createPlaceholderResult(\n    placeholderData: any,\n    options: QueryObserverOptions<T>,\n    refetchFn: () => void\n  ): QueryObserverResult<T, E> {\n    // placeholderData가 있는 경우: success 상태로 시작\n    this.placeholderManager.setPlaceholderState({\n      data: placeholderData,\n      isActive: true,\n    });\n\n    const finalData = this.applySelect(placeholderData as T, options);\n\n    return {\n      data: finalData,\n      error: undefined,\n      isLoading: false, // placeholderData는 success 상태\n      isFetching: true, // 백그라운드에서 fetch 중\n      isError: false,\n      isSuccess: true,\n      isStale: true,\n      isPlaceholderData: true,\n      refetch: refetchFn,\n    };\n  }\n\n  /**\n   * 초기 로딩 결과 생성\n   */\n  private createInitialLoadingResult(\n    refetchFn: () => void\n  ): QueryObserverResult<T, E> {\n    this.placeholderManager.deactivatePlaceholder();\n\n    return {\n      data: undefined,\n      error: undefined,\n      isLoading: true,\n      isFetching: true,\n      isError: false,\n      isSuccess: false,\n      isStale: true,\n      isPlaceholderData: false,\n      refetch: refetchFn,\n    };\n  }\n\n  /**\n   * 성공 상태인지 확인\n   */\n  private isSuccessState(cached: QueryState<T>): boolean {\n    return !cached.isLoading && !cached.error && !isNil(cached.data);\n  }\n\n  /**\n   * select 함수 적용\n   */\n  private applySelect(\n    data: T | React.ReactNode | undefined,\n    options: QueryObserverOptions<T>\n  ): T | undefined {\n    if (isNil(data) || !options.select) return data as T;\n\n    try {\n      return options.select(data as T);\n    } catch {\n      return data as T;\n    }\n  }\n\n  /**\n   * Stale 시간 계산\n   */\n  private computeStaleTime(\n    updatedAt: number,\n    options: QueryObserverOptions<T>\n  ): boolean {\n    return updatedAt\n      ? Date.now() - updatedAt >= (options.staleTime || 0)\n      : true;\n  }\n}\n","import type { QueryClient } from \"../client/query-client\";\nimport { serializeQueryKey } from \"../cache/query-cache\";\nimport { isEmpty } from \"es-toolkit/compat\";\nimport { TrackedResult, replaceEqualDeep } from \"./utils\";\nimport type { QueryObserverOptions, QueryObserverResult } from \"./types\";\nimport {\n  PlaceholderManager,\n  ResultComputer,\n  FetchManager,\n  OptionsManager,\n  type OptionsChangeCallbacks,\n} from \"./managers\";\n\n/**\n *  Observer 패턴 구현\n * placeholderData는 캐시와 완전히 분리하여 UI 레벨에서만 관리\n */\nexport class QueryObserver<T = unknown, E = unknown> {\n  private queryClient: QueryClient;\n  private options: QueryObserverOptions<T>;\n  private listeners = new Set<() => void>();\n  private cacheKey: string;\n  private isDestroyed = false;\n  private currentResult: QueryObserverResult<T, E>;\n  private optionsHash: string = \"\";\n\n  // 결과 캐싱으로 불필요한 렌더링 방지\n  private lastResultReference: QueryObserverResult<T, E> | null = null;\n\n  // Tracked Properties\n  private trackedResult: TrackedResult<T, E> | null = null;\n\n  // PlaceholderData 관리자\n  private placeholderManager: PlaceholderManager<T>;\n\n  // 결과 계산기\n  private resultComputer: ResultComputer<T, E>;\n\n  // Fetch 관리자\n  private fetchManager: FetchManager<T>;\n\n  // 옵션 관리자\n  private optionsManager: OptionsManager<T, E>;\n\n  constructor(queryClient: QueryClient, options: QueryObserverOptions<T>) {\n    this.queryClient = queryClient;\n    this.options = options;\n    this.cacheKey = serializeQueryKey(options.key);\n    this.placeholderManager = new PlaceholderManager<T>(queryClient);\n    this.resultComputer = new ResultComputer(\n      queryClient,\n      this.placeholderManager\n    );\n    this.fetchManager = new FetchManager(queryClient, this.placeholderManager);\n    this.optionsManager = new OptionsManager(\n      queryClient,\n      this.placeholderManager\n    );\n    this.optionsHash = this.optionsManager.createOptionsHash(options);\n\n    // 초기 결과 계산 (placeholderData 고려)\n    this.currentResult = this.computeResult();\n\n    // 캐시 변경 구독\n    this.subscribeToCache();\n\n    // 초기 fetch 실행\n    this.executeFetch();\n  }\n\n  private subscribeToCache(): void {\n    this.queryClient.subscribeListener(this.options.key, () => {\n      if (!this.isDestroyed) {\n        const hasChanged = this.updateResult();\n        if (hasChanged) {\n          this.scheduleNotifyListeners();\n        }\n\n        // invalidateQueries로 인한 무효화 감지 및 자동 refetch\n        this.handlePotentialInvalidation();\n      }\n    });\n\n    this.queryClient.subscribe(this.options.key);\n  }\n\n  /**\n   * invalidateQueries로 인한 무효화 감지 및 처리\n   * updatedAt이 0이면 invalidateQueries로 인한 무효화로 간주\n   */\n  private handlePotentialInvalidation(): void {\n    const { enabled = true } = this.options;\n\n    if (!enabled) return;\n\n    const cached = this.queryClient.get<T>(this.cacheKey);\n    if (cached && cached.updatedAt === 0) {\n      // invalidateQueries로 인한 무효화 감지\n      // 현재 fetching 중이 아니고 로딩 중이 아닌 경우에만 refetch\n      if (!cached.isFetching && !cached.isLoading) {\n        this.fetchData();\n      }\n    }\n  }\n\n  /**\n   * 결과 계산\n   * 캐시 상태와 placeholderData를 완전히 분리하여 처리\n   */\n  private computeResult(): QueryObserverResult<T, E> {\n    return this.resultComputer.computeResult(this.cacheKey, this.options, () =>\n      this.refetch()\n    );\n  }\n\n  /**\n   * Tracked Properties 기반 결과 업데이트\n   * 기본적으로 tracked 모드로 동작\n   */\n  private updateResult(): boolean {\n    const newResult = this.computeResult();\n\n    // Structural Sharing 적용\n    const optimizedResult = this.applyStructuralSharing(newResult);\n\n    // 'tracked' 모드: 실제 사용된 속성만 확인\n    if (this.hasChangeInTrackedProps(optimizedResult)) {\n      this.currentResult = optimizedResult;\n      this.lastResultReference = optimizedResult;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Structural Sharing 적용\n   */\n  private applyStructuralSharing(\n    newResult: QueryObserverResult<T, E>\n  ): QueryObserverResult<T, E> {\n    if (!this.lastResultReference) {\n      return newResult;\n    }\n\n    return replaceEqualDeep(this.lastResultReference, newResult);\n  }\n\n  private hasChangeInTrackedProps(\n    newResult: QueryObserverResult<T, E>\n  ): boolean {\n    // 초기 상태 확인\n    if (this.isInitialState()) {\n      return true;\n    }\n\n    const trackedProps = this.trackedResult!.getTrackedProps();\n\n    // 추적된 속성이 없으면 초기 상태로 간주\n    if (this.hasNoTrackedProperties(trackedProps)) {\n      return true;\n    }\n\n    // 추적된 속성 중 변경된 것이 있는지 확인\n    return this.hasTrackedPropertyChanged(trackedProps, newResult);\n  }\n\n  private isInitialState(): boolean {\n    return !this.lastResultReference || !this.trackedResult;\n  }\n\n  private hasNoTrackedProperties(\n    trackedProps: Set<keyof QueryObserverResult<T, E>>\n  ): boolean {\n    return isEmpty(trackedProps);\n  }\n\n  private hasTrackedPropertyChanged(\n    trackedProps: Set<keyof QueryObserverResult<T, E>>,\n    newResult: QueryObserverResult<T, E>\n  ): boolean {\n    for (const prop of trackedProps) {\n      if (this.lastResultReference![prop] !== newResult[prop]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private async executeFetch(): Promise<void> {\n    await this.fetchManager.executeFetch(this.cacheKey, this.options);\n  }\n\n  private async fetchData(): Promise<void> {\n    await this.fetchManager.fetchData(this.cacheKey, this.options, () => {\n      // fetch 완료 후 결과 업데이트 및 리스너 알림\n      const hasChanged = this.updateResult();\n      if (hasChanged) {\n        this.scheduleNotifyListeners();\n      }\n    });\n  }\n\n  private notifyListeners(): void {\n    this.listeners.forEach((listener) => listener());\n  }\n\n  /**\n   * 결과 구독 (React 컴포넌트에서 사용)\n   */\n  subscribe(listener: () => void): () => void {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  /**\n   * Tracked Properties가 적용된 현재 결과 반환\n   * TrackedResult 인스턴스를 재사용하여 속성 추적을 유지\n   */\n  getCurrentResult(): QueryObserverResult<T, E> {\n    // TrackedResult가 없으면 새로 생성\n    if (!this.trackedResult) {\n      this.trackedResult = new TrackedResult(this.currentResult);\n    } else if (this.trackedResult.getResult() !== this.currentResult) {\n      // 결과가 변경된 경우 업데이트 (캐시 무효화)\n      this.trackedResult.updateResult(this.currentResult);\n    }\n\n    return this.trackedResult.createProxy();\n  }\n\n  /**\n   * 수동 refetch\n   */\n  refetch(): void {\n    this.fetchManager.refetch(this.cacheKey, this.options, () => {\n      // refetch 완료 후 결과 업데이트 및 리스너 알림\n      const hasChanged = this.updateResult();\n      if (hasChanged) {\n        this.scheduleNotifyListeners();\n      }\n    });\n  }\n\n  /**\n   * 옵션 업데이트 최적화\n   */\n  setOptions(options: QueryObserverOptions<T>): void {\n    const prevKey = this.cacheKey;\n    const prevHash = this.optionsHash;\n    const newHash = this.optionsManager.createOptionsHash(options);\n\n    // 해시가 동일한 경우 함수만 업데이트\n    if (this.optionsManager.isOptionsUnchanged(prevHash, newHash)) {\n      this.options = options;\n      this.optionsManager.updateOptionsOnly(options, this.createCallbacks());\n      return;\n    }\n\n    const prevOptions = this.options;\n    const { cacheKey, optionsHash } = this.optionsManager.updateOptionsAndKey(\n      options,\n      newHash\n    );\n    this.options = options;\n    this.cacheKey = cacheKey;\n    this.optionsHash = optionsHash;\n\n    // 키가 변경된 경우\n    if (this.optionsManager.isKeyChanged(prevKey, this.cacheKey)) {\n      this.trackedResult = null;\n      this.optionsManager.handleKeyChange(\n        prevOptions,\n        this.cacheKey,\n        this.createCallbacks()\n      );\n    } else {\n      this.optionsManager.handleOptionsChange(this.createCallbacks());\n    }\n  }\n\n  private createCallbacks(): OptionsChangeCallbacks<T, E> {\n    return {\n      updateResult: () => this.updateResult(),\n      scheduleNotifyListeners: () => this.scheduleNotifyListeners(),\n      executeFetch: () => this.executeFetch(),\n      subscribeToCache: () => this.subscribeToCache(),\n      computeResult: () => this.computeResult(),\n      handleCachedDataAvailable: () => this.handleCachedDataAvailable(),\n      handleNoCachedData: () => this.handleNoCachedData(),\n    };\n  }\n\n  private handleCachedDataAvailable(): void {\n    // 캐시된 데이터가 있는 경우: 즉시 결과 업데이트, 백그라운드 fetch\n    this.currentResult = this.computeResult();\n    this.lastResultReference = this.currentResult;\n\n    // 백그라운드 fetch가 필요한 경우 캐시 상태 미리 업데이트\n    const cached = this.queryClient.get<T>(this.cacheKey);\n    const isStale = cached\n      ? Date.now() - cached.updatedAt >= (this.options.staleTime || 0)\n      : true;\n    const shouldFetch = isStale && this.options.enabled !== false;\n\n    if (shouldFetch && cached) {\n      // 백그라운드 fetch 시작을 위해 isFetching 상태 미리 설정\n      this.queryClient.set(this.cacheKey, {\n        ...cached,\n        isFetching: true,\n      });\n\n      // 결과 재계산하여 isFetching: true 반영\n      this.currentResult = this.computeResult();\n      this.lastResultReference = this.currentResult;\n    }\n\n    // 백그라운드에서 fetch 수행\n    this.executeFetch();\n\n    // 단일 렌더링을 위해 한 번만 알림\n    this.scheduleNotifyListeners();\n  }\n\n  private handleNoCachedData(): void {\n    // 캐시가 없는 경우: placeholderData 사용 가능\n    const hasChanged = this.updateResult();\n    this.executeFetch();\n\n    if (hasChanged) {\n      this.scheduleNotifyListeners();\n    }\n  }\n\n  private scheduleNotifyListeners(): void {\n    Promise.resolve().then(() => {\n      if (!this.isDestroyed) {\n        this.notifyListeners();\n      }\n    });\n  }\n\n  /**\n   * Observer 정리\n   */\n  destroy(): void {\n    this.isDestroyed = true;\n    this.queryClient.unsubscribe(\n      this.options.key,\n      this.options.gcTime || 300000\n    );\n    this.listeners.clear();\n    this.placeholderManager.deactivatePlaceholder();\n    this.lastResultReference = null;\n    this.trackedResult = null;\n  }\n}\n","import type { QueryClient } from \"../client/query-client\";\nimport type { QueryConfig } from \"../factories/query-factory\";\nimport { getQueryClient } from \"../client/query-client-manager\";\nimport { merge } from \"es-toolkit/compat\";\n\n/**\n * 쿼리 항목 타입\n */\ntype QueryItem =\n  | [QueryConfig<any, any>] // 파라미터가 없는 경우\n  | [QueryConfig<any, any>, any]; // 파라미터가 있는 경우\n\n/**\n * SSR에서 여러 쿼리를 미리 패칭(prefetch)합니다.\n *\n * @example\n * ```typescript\n * // 파라미터가 없는 쿼리\n * await ssrPrefetch([\n *   [queries.users],\n *   [queries.posts, { userId: 1 }], // 파라미터가 있는 경우\n * ]);\n *\n * // 혼합 사용\n * await ssrPrefetch([\n *   [queries.users], // 파라미터 없음\n *   [queries.user, { userId: 1 }], // 파라미터 있음\n *   [queries.posts, { page: 1, limit: 10 }]\n * ]);\n * ```\n *\n * @param queries QueryItem[] 형태의 쿼리 배열\n * @param globalFetchConfig 모든 쿼리에 공통 적용할 fetchConfig (예: baseURL)\n * @param client QueryClient 인스턴스 (선택사항, 제공하지 않으면 자동 생성)\n */\nexport async function ssrPrefetch(\n  queries: Array<QueryItem>,\n  globalFetchConfig: Record<string, any> = {},\n  client?: QueryClient\n): Promise<Record<string, any>> {\n  // client가 제공되지 않으면 자동으로 생성 (서버 환경에서는 새 인스턴스)\n  const queryClient = client || getQueryClient();\n\n  const results = await Promise.allSettled(\n    queries.map(async (queryItem) => {\n      try {\n        // query와 params 추출\n        const [query, params] = queryItem;\n\n        // 전역 fetchConfig를 쿼리 fetchConfig에 병합\n        const mergedQuery = {\n          ...query,\n          fetchConfig: merge({}, globalFetchConfig, query.fetchConfig || {}),\n        };\n\n        // QueryClient의 오버로드된 prefetchQuery 사용\n        await queryClient.prefetchQuery(mergedQuery, params);\n      } catch (error) {\n        console.error(`[ssrPrefetch] Failed to prefetch query:`, error);\n        // 개별 쿼리 실패는 전체 prefetch를 중단하지 않음\n      }\n    })\n  );\n\n  // 실패한 쿼리들 로깅\n  const failures = results.filter(\n    (result): result is PromiseRejectedResult => result.status === \"rejected\"\n  );\n\n  if (failures.length > 0) {\n    console.warn(`[ssrPrefetch] ${failures.length} queries failed to prefetch`);\n  }\n\n  // 캐시된 상태를 반환하여 HydrationBoundary에서 사용할 수 있도록 함\n  return queryClient.dehydrate();\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A;;;;;;;ACAA;AAAA,IAAqB,WAArB,cAAsC,IAAI;AAAA,EAQzC,YAAYA,WAAU,CAAC,GAAG;AACzB,UAAM;AATR;AACC,8BAAQ;AACR,+BAAS,oBAAI,IAAI;AACjB,kCAAY,oBAAI,IAAI;AACpB;AACA;AACA;AAKC,QAAI,EAAEA,SAAQ,WAAWA,SAAQ,UAAU,IAAI;AAC9C,YAAM,IAAI,UAAU,2CAA2C;AAAA,IAChE;AAEA,QAAI,OAAOA,SAAQ,WAAW,YAAYA,SAAQ,WAAW,GAAG;AAC/D,YAAM,IAAI,UAAU,0CAA0C;AAAA,IAC/D;AAEA,uBAAK,UAAWA,SAAQ;AACxB,uBAAK,SAAUA,SAAQ,UAAU,OAAO;AACxC,uBAAK,aAAcA,SAAQ;AAAA,EAC5B;AAAA;AAAA,EAGA,IAAI,aAAa;AAChB,WAAO,mBAAK;AAAA,EACb;AAAA,EA8EA,IAAI,KAAK;AACR,QAAI,mBAAK,QAAO,IAAI,GAAG,GAAG;AACzB,YAAM,OAAO,mBAAK,QAAO,IAAI,GAAG;AAChC,aAAO,sBAAK,sCAAL,WAAmB,KAAK;AAAA,IAChC;AAEA,QAAI,mBAAK,WAAU,IAAI,GAAG,GAAG;AAC5B,YAAM,OAAO,mBAAK,WAAU,IAAI,GAAG;AACnC,UAAI,sBAAK,yCAAL,WAAsB,KAAK,UAAU,OAAO;AAC/C,8BAAK,sCAAL,WAAmB,KAAK;AACxB,eAAO,KAAK;AAAA,MACb;AAAA,IACD;AAAA,EACD;AAAA,EAEA,IAAI,KAAK,OAAO,EAAC,SAAS,mBAAK,SAAO,IAAI,CAAC,GAAG;AAC7C,UAAM,SAAS,OAAO,WAAW,YAAY,WAAW,OAAO,oBAC3D,KAAK,IAAI,IAAI,SACd;AAEH,QAAI,mBAAK,QAAO,IAAI,GAAG,GAAG;AACzB,yBAAK,QAAO,IAAI,KAAK;AAAA,QACpB;AAAA,QACA;AAAA,MACD,CAAC;AAAA,IACF,OAAO;AACN,4BAAK,6BAAL,WAAU,KAAK,EAAC,OAAO,OAAM;AAAA,IAC9B;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,IAAI,KAAK;AACR,QAAI,mBAAK,QAAO,IAAI,GAAG,GAAG;AACzB,aAAO,CAAC,sBAAK,yCAAL,WAAsB,KAAK,mBAAK,QAAO,IAAI,GAAG;AAAA,IACvD;AAEA,QAAI,mBAAK,WAAU,IAAI,GAAG,GAAG;AAC5B,aAAO,CAAC,sBAAK,yCAAL,WAAsB,KAAK,mBAAK,WAAU,IAAI,GAAG;AAAA,IAC1D;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,KAAK,KAAK;AACT,QAAI,mBAAK,QAAO,IAAI,GAAG,GAAG;AACzB,aAAO,sBAAK,8BAAL,WAAW,KAAK,mBAAK;AAAA,IAC7B;AAEA,QAAI,mBAAK,WAAU,IAAI,GAAG,GAAG;AAC5B,aAAO,sBAAK,8BAAL,WAAW,KAAK,mBAAK;AAAA,IAC7B;AAAA,EACD;AAAA,EAEA,OAAO,KAAK;AACX,UAAM,UAAU,mBAAK,QAAO,OAAO,GAAG;AACtC,QAAI,SAAS;AACZ,6BAAK,OAAL;AAAA,IACD;AAEA,WAAO,mBAAK,WAAU,OAAO,GAAG,KAAK;AAAA,EACtC;AAAA,EAEA,QAAQ;AACP,uBAAK,QAAO,MAAM;AAClB,uBAAK,WAAU,MAAM;AACrB,uBAAK,OAAQ;AAAA,EACd;AAAA,EAEA,OAAO,SAAS;AACf,QAAI,EAAE,WAAW,UAAU,IAAI;AAC9B,YAAM,IAAI,UAAU,2CAA2C;AAAA,IAChE;AAEA,UAAM,QAAQ,CAAC,GAAG,sBAAK,0CAAL,UAAwB;AAC1C,UAAM,cAAc,MAAM,SAAS;AACnC,QAAI,cAAc,GAAG;AACpB,yBAAK,QAAS,IAAI,IAAI,KAAK;AAC3B,yBAAK,WAAY,oBAAI,IAAI;AACzB,yBAAK,OAAQ,MAAM;AAAA,IACpB,OAAO;AACN,UAAI,cAAc,GAAG;AACpB,8BAAK,uCAAL,WAAoB,MAAM,MAAM,GAAG,WAAW;AAAA,MAC/C;AAEA,yBAAK,WAAY,IAAI,IAAI,MAAM,MAAM,WAAW,CAAC;AACjD,yBAAK,QAAS,oBAAI,IAAI;AACtB,yBAAK,OAAQ;AAAA,IACd;AAEA,uBAAK,UAAW;AAAA,EACjB;AAAA,EAEA,CAAE,OAAO;AACR,eAAW,CAAC,GAAG,KAAK,MAAM;AACzB,YAAM;AAAA,IACP;AAAA,EACD;AAAA,EAEA,CAAE,SAAS;AACV,eAAW,CAAC,EAAE,KAAK,KAAK,MAAM;AAC7B,YAAM;AAAA,IACP;AAAA,EACD;AAAA,EAEA,EAAG,OAAO,QAAQ,IAAI;AACrB,eAAW,QAAQ,mBAAK,SAAQ;AAC/B,YAAM,CAAC,KAAK,KAAK,IAAI;AACrB,YAAM,UAAU,sBAAK,yCAAL,WAAsB,KAAK;AAC3C,UAAI,YAAY,OAAO;AACtB,cAAM,CAAC,KAAK,MAAM,KAAK;AAAA,MACxB;AAAA,IACD;AAEA,eAAW,QAAQ,mBAAK,YAAW;AAClC,YAAM,CAAC,KAAK,KAAK,IAAI;AACrB,UAAI,CAAC,mBAAK,QAAO,IAAI,GAAG,GAAG;AAC1B,cAAM,UAAU,sBAAK,yCAAL,WAAsB,KAAK;AAC3C,YAAI,YAAY,OAAO;AACtB,gBAAM,CAAC,KAAK,MAAM,KAAK;AAAA,QACxB;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAAA,EAEA,CAAE,oBAAoB;AACrB,QAAI,QAAQ,CAAC,GAAG,mBAAK,OAAM;AAC3B,aAAS,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAC3C,YAAM,OAAO,MAAM,CAAC;AACpB,YAAM,CAAC,KAAK,KAAK,IAAI;AACrB,YAAM,UAAU,sBAAK,yCAAL,WAAsB,KAAK;AAC3C,UAAI,YAAY,OAAO;AACtB,cAAM,CAAC,KAAK,MAAM,KAAK;AAAA,MACxB;AAAA,IACD;AAEA,YAAQ,CAAC,GAAG,mBAAK,UAAS;AAC1B,aAAS,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAC3C,YAAM,OAAO,MAAM,CAAC;AACpB,YAAM,CAAC,KAAK,KAAK,IAAI;AACrB,UAAI,CAAC,mBAAK,QAAO,IAAI,GAAG,GAAG;AAC1B,cAAM,UAAU,sBAAK,yCAAL,WAAsB,KAAK;AAC3C,YAAI,YAAY,OAAO;AACtB,gBAAM,CAAC,KAAK,MAAM,KAAK;AAAA,QACxB;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAAA,EAEA,CAAE,mBAAmB;AACpB,eAAW,CAAC,KAAK,KAAK,KAAK,sBAAK,0CAAL,YAA0B;AACpD,YAAM,CAAC,KAAK,MAAM,KAAK;AAAA,IACxB;AAAA,EACD;AAAA,EAEA,IAAI,OAAO;AACV,QAAI,CAAC,mBAAK,QAAO;AAChB,aAAO,mBAAK,WAAU;AAAA,IACvB;AAEA,QAAI,eAAe;AACnB,eAAW,OAAO,mBAAK,WAAU,KAAK,GAAG;AACxC,UAAI,CAAC,mBAAK,QAAO,IAAI,GAAG,GAAG;AAC1B;AAAA,MACD;AAAA,IACD;AAEA,WAAO,KAAK,IAAI,mBAAK,SAAQ,cAAc,mBAAK,SAAQ;AAAA,EACzD;AAAA,EAEA,IAAI,UAAU;AACb,WAAO,mBAAK;AAAA,EACb;AAAA,EAEA,UAAU;AACT,WAAO,KAAK,iBAAiB;AAAA,EAC9B;AAAA,EAEA,QAAQ,kBAAkB,eAAe,MAAM;AAC9C,eAAW,CAAC,KAAK,KAAK,KAAK,KAAK,iBAAiB,GAAG;AACnD,uBAAiB,KAAK,cAAc,OAAO,KAAK,IAAI;AAAA,IACrD;AAAA,EACD;AAAA,EAEA,KAAK,OAAO,WAAW,IAAI;AAC1B,WAAO;AAAA,EACR;AAAA,EAEA,WAAW;AACV,WAAO,YAAY,KAAK,IAAI,IAAI,KAAK,OAAO;AAAA,EAC7C;AAAA,EAEA,CAAC,OAAO,IAAI,4BAA4B,CAAC,IAAI;AAC5C,WAAO,KAAK,SAAS;AAAA,EACtB;AACD;AA3SC;AACA;AACA;AACA;AACA;AACA;AAND;AA6BC,mBAAc,SAAC,OAAO;AACrB,MAAI,OAAO,mBAAK,iBAAgB,YAAY;AAC3C;AAAA,EACD;AAEA,aAAW,CAAC,KAAK,IAAI,KAAK,OAAO;AAChC,uBAAK,aAAL,WAAiB,KAAK,KAAK;AAAA,EAC5B;AACD;AAEA,qBAAgB,SAAC,KAAK,MAAM;AAC3B,MAAI,OAAO,KAAK,WAAW,YAAY,KAAK,UAAU,KAAK,IAAI,GAAG;AACjE,QAAI,OAAO,mBAAK,iBAAgB,YAAY;AAC3C,yBAAK,aAAL,WAAiB,KAAK,KAAK;AAAA,IAC5B;AAEA,WAAO,KAAK,OAAO,GAAG;AAAA,EACvB;AAEA,SAAO;AACR;AAEA,0BAAqB,SAAC,KAAK,MAAM;AAChC,QAAM,UAAU,sBAAK,yCAAL,WAAsB,KAAK;AAC3C,MAAI,YAAY,OAAO;AACtB,WAAO,KAAK;AAAA,EACb;AACD;AAEA,kBAAa,SAAC,KAAK,MAAM;AACxB,SAAO,KAAK,SAAS,sBAAK,8CAAL,WAA2B,KAAK,QAAQ,KAAK;AACnE;AAEA,UAAK,SAAC,KAAK,OAAO;AACjB,QAAM,OAAO,MAAM,IAAI,GAAG;AAE1B,SAAO,sBAAK,sCAAL,WAAmB,KAAK;AAChC;AAEA,SAAI,SAAC,KAAK,OAAO;AAChB,qBAAK,QAAO,IAAI,KAAK,KAAK;AAC1B,yBAAK,OAAL;AAEA,MAAI,mBAAK,UAAS,mBAAK,WAAU;AAChC,uBAAK,OAAQ;AACb,0BAAK,uCAAL,WAAoB,mBAAK;AACzB,uBAAK,WAAY,mBAAK;AACtB,uBAAK,QAAS,oBAAI,IAAI;AAAA,EACvB;AACD;AAEA,kBAAa,SAAC,KAAK,MAAM;AACxB,qBAAK,WAAU,OAAO,GAAG;AACzB,wBAAK,6BAAL,WAAU,KAAK;AAChB;AAEE,sBAAiB,aAAG;AACrB,aAAW,QAAQ,mBAAK,YAAW;AAClC,UAAM,CAAC,KAAK,KAAK,IAAI;AACrB,QAAI,CAAC,mBAAK,QAAO,IAAI,GAAG,GAAG;AAC1B,YAAM,UAAU,sBAAK,yCAAL,WAAsB,KAAK;AAC3C,UAAI,YAAY,OAAO;AACtB,cAAM;AAAA,MACP;AAAA,IACD;AAAA,EACD;AAEA,aAAW,QAAQ,mBAAK,SAAQ;AAC/B,UAAM,CAAC,KAAK,KAAK,IAAI;AACrB,UAAM,UAAU,sBAAK,yCAAL,WAAsB,KAAK;AAC3C,QAAI,YAAY,OAAO;AACtB,YAAM;AAAA,IACP;AAAA,EACD;AACD;;;;AClGW,IAAA,cAAA,kBAAAC,iBAAL;AAILA,eAAA,MAAO,IAAA;AAKPA,eAAA,MAAO,IAAA;AAKPA,eAAA,MAAO,IAAA;AAKPA,eAAA,MAAO,IAAA;AAKPA,eAAA,WAAY,IAAA;AAKZA,eAAA,KAAM,IAAA;AAKNA,eAAA,MAAO,IAAA;AAlCGA,SAAAA;AAAA,GAAA,eAAA,CAAA,CAAA;AAwCA,IAAA,eAAA,kBAAAC,kBAAL;AAILA,gBAAA,MAAO,IAAA;AAKPA,gBAAA,MAAO,IAAA;AAKPA,gBAAA,MAAO,IAAA;AAKPA,gBAAA,cAAe,IAAA;AAKfA,gBAAA,KAAM,IAAA;AAxBIA,SAAAA;AAAA,GAAA,gBAAA,CAAA,CAAA;AA0CC,IAAA,aAAN,cAAyB,MAAM;;;;;;;;;;EAwCpC,YACE,SACA,QACA,MACAC,UACA,UACA,cACA;AACA,UAAM,OAAO;AA5CR,SAAA,OAAA;AA6CL,SAAK,SAAS;AACd,SAAK,OAAO;AACZ,SAAK,UAAUA;AAEf,QAAI,UAAU;AACZ,WAAK,WAAW;QACd,MAAM;QACN,QAAQ,SAAS;QACjB,YAAY,SAAS;QACrB,SAAS,SAAS;MAAA;IACpB;EACF;AAEJ;AC9HA,IAAM,yBAAyB;;EAE7B,SAAS,OAAO,qBAAqB;;EAErC,MAAM,OAAO,kBAAkB;;EAE/B,SAAS,OAAO,qBAAqB;;EAErC,cAAc,OAAO,2BAA2B;AAClD;AAqBO,IAAM,qBAAN,MAEL;EAFK,cAAA;AAGL,SAAQ,WAKI,CAAA;AAEZ,SAAQ,YAAY;EAAA;;;;;;;;EASpB,IAAI,SAAYC,UAAiD;AAC/D,UAAM,KAAK,KAAK;AACV,UAAA,OAAOA,UAAS,QAAQ,uBAAuB;AAC/C,UAAA,MAAMA,UAAS,OAAO;AAE5B,SAAK,SAAS,KAAK;MACjB;MACA;MACA;MACA;IAAA,CACD;AAEM,WAAA;MACL,QAAQ,MAAM,KAAK,MAAM,EAAE;IAAA;EAC7B;;;;;EAOF,MAAM,IAAkB;AAChB,UAAA,QAAQ,KAAK,SAAS,UAAU,CAAC,MAAM,MAAM,QAAQ,EAAE,OAAO,EAAE;AACtE,QAAI,UAAU,IAAI;AACX,WAAA,SAAS,KAAK,IAAI;IAAA;EACzB;;;;;EAOF,YAAY,MAAoB;AAC9B,SAAK,SAAS,QAAQ,CAAC,MAAM,UAAU;AACrC,UAAI,SAAS,QAAQ,KAAK,SAAS,MAAM;AAClC,aAAA,SAAS,KAAK,IAAI;MAAA;IACzB,CACD;EAAA;;;;EAMH,QAAc;AACZ,SAAK,WAAW,CAAA;EAAC;;;;;;EAQnB,MAAM,QAAW,OAAsB;AACrC,QAAI,SAAS;AAEF,eAAA,WAAW,KAAK,UAAU;AACnC,UAAI,YAAY,MAAM;AAEV,iBAAA,MACR,QAAQ,QACR,MAAM;MAAA;IACV;AAGK,WAAA;EAAA;;;;EAMT,4BAA4B;AACnB,WAAA,KAAK,SACT,OAAO,CAAC,MAAM,MAAM,IAAI,EACxB,IAAI,CAAC,OAAO;MACX,IAAI,GAAG;MACP,KAAK,GAAG,OAAO;MACf,MAAM,GAAG,MAAM,eAAe;IAAA,EAC9B;EAAA;AAER;AAKO,IAAM,4BAAN,MAAgC;EAAhC,cAAA;AACG,SAAA,UAAU,IAAI,mBAAuC;EAAA;;;;;;;EAQ7D,IACE,aACA,OAAO,uBAAuB,MACX;AACZ,WAAA,KAAK,QAAQ,IAAI,aAAa,EAAE,MAAM,KAAK,sBAAA,CAAuB;EAAA;;;;EAM3E,QAAc;AACZ,SAAK,QAAQ,MAAM;EAAA;;;;;EAOrB,YAAY,MAAoB;AACzB,SAAA,QAAQ,YAAY,IAAI;EAAA;;;;EAM/B,MAAM,IAAI,QAA+C;AAChD,WAAA,KAAK,QAAQ,QAAuB,MAAM;EAAA;;;;EAMnD,4BAA4B;AACnB,WAAA,KAAK,QAAQ,0BAA0B;EAAA;AAElD;AAKO,IAAM,6BAAN,MAAiC;EAAjC,cAAA;AACG,SAAA,UAAU,IAAI,mBAAwC;EAAA;;;;;;;EAQ9D,IACE,aACA,OAAO,uBAAuB,MACX;AACZ,WAAA,KAAK,QAAQ,IAAI,aAAa,EAAE,MAAM,KAAK,uBAAA,CAAwB;EAAA;;;;EAM5E,QAAc;AACZ,SAAK,QAAQ,MAAM;EAAA;;;;;EAOrB,YAAY,MAAoB;AACzB,SAAA,QAAQ,YAAY,IAAI;EAAA;;;;EAM/B,MAAM,IAAO,UAA6D;AACjE,WAAA,KAAK,QAAQ,QAA6B,QAAQ;EAAA;;;;EAM3D,4BAA4B;AACnB,WAAA,KAAK,QAAQ,0BAA0B;EAAA;AAElD;AAKO,IAAM,0BAAN,MAA8B;EAA9B,cAAA;AACG,SAAA,UAAU,IAAI,mBAAqC;EAAA;;;;;;;EAQ3D,IACE,aACA,OAAO,uBAAuB,cACX;AACZ,WAAA,KAAK,QAAQ,IAAI,aAAa,EAAE,MAAM,KAAK,oBAAA,CAAqB;EAAA;;;;EAMzE,QAAc;AACZ,SAAK,QAAQ,MAAM;EAAA;;;;;EAOrB,YAAY,MAAoB;AACzB,SAAA,QAAQ,YAAY,IAAI;EAAA;;;;EAM/B,MAAM,IACJ,OACiD;AAC1C,WAAA,KAAK,QAAQ,QAAoB,KAAK;EAAA;;;;EAM/C,4BAA4B;AACnB,WAAA,KAAK,QAAQ,0BAA0B;EAAA;AAElD;AAKO,SAAS,qBAAqB;AAC7B,QAAA,sBAAsB,IAAI,0BAA0B;AACpD,QAAA,uBAAuB,IAAI,2BAA2B;AACtD,QAAA,oBAAoB,IAAI,wBAAwB;AAE/C,SAAA;IACL,SAAS;;;;;;;;;;;;;;;;;;;;;;MAsBP,KAAK,CAAC,gBACJ,oBAAoB,IAAI,WAAW;;;;;MAMrC,OAAO,CAAC,OAAe;AACb,gBAAA;UACN;QAAA;MACF;;;;;;;;;MAWF,OAAO,MAAM,oBAAoB,MAAM;;;;;;;;;;MAWvC,aAAa,CAAC,SAAiB,oBAAoB,YAAY,IAAI;;;;MAKnE,KAAK,oBAAoB,IAAI,KAAK,mBAAmB;;;;MAKrD,eAAe,MAAM,oBAAoB,0BAA0B;IAAA;IAErE,UAAU;;;;;;MAMR,KAAK,CAAC,gBACJ,qBAAqB,IAAI,WAAW;;;;;MAMtC,OAAO,CAAC,OAAe;AACb,gBAAA;UACN;QAAA;MACF;;;;MAMF,OAAO,MAAM,qBAAqB,MAAM;;;;;MAMxC,aAAa,CAAC,SAAiB,qBAAqB,YAAY,IAAI;;;;MAKpE,KAAK,qBAAqB,IAAI,KAAK,oBAAoB;;;;MAKvD,eAAe,MAAM,qBAAqB,0BAA0B;IAAA;IAEtE,OAAO;;;;;;MAML,KAAK,CAAC,eAAiC,kBAAkB,IAAI,UAAU;;;;;MAMvE,OAAO,CAAC,OAAe;AACb,gBAAA;UACN;QAAA;MACF;;;;MAMF,OAAO,MAAM,kBAAkB,MAAM;;;;;MAMrC,aAAa,CAAC,SAAiB,kBAAkB,YAAY,IAAI;;;;MAKjE,KAAK,kBAAkB,IAAI,KAAK,iBAAiB;;;;MAKjD,eAAe,MAAM,kBAAkB,0BAA0B;IAAA;EACnE;AAEJ;AAGO,IAAM,mBAAmB;AClczB,SAAS,kBACd,KACA,QACQ;AAEF,QAAA,eAAW,wBAAK,GAAG;AACzB,MAAI,CAAC,cAAU,uBAAQ,MAAM,EAAU,QAAA;AAGjC,QAAA,kBAAc,0BAAO,QAAQ,CAAC,UAAU,KAAC,yBAAM,KAAK,CAAC;AAEvD,UAAA,uBAAQ,WAAW,EAAU,QAAA;AAGjC,QAAM,CAAC,SAAS,QAAQ,IAAI,SAAS,MAAM,GAAG;AAC9C,QAAM,CAAC,MAAM,aAAa,IAAI,QAAQ,MAAM,GAAG;AAG/C,QAAM,iBAAiB,IAAI,gBAAgB,iBAAiB,EAAE;AAGvD,SAAA,QAAQ,WAAW,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,mBAAe,IAAI,KAAK,OAAO,KAAK,CAAC;EAAA,CACtC;AAGK,QAAA,cAAc,eAAe,SAAS;AAC5C,QAAM,eAAW,2BAAQ;IACvB;IACA,cAAc,IAAI,WAAW,KAAK;IAClC,WAAW,IAAI,QAAQ,KAAK;EAAA,CAC7B;AAEM,SAAA,SAAS,KAAK,EAAE;AACzB;AAQO,SAAS,YAAY,SAAkB,KAAsB;AAElE,QAAM,eAAe,cAAU,wBAAK,OAAO,IAAI;AAC/C,QAAM,WAAW,UAAM,wBAAK,GAAG,IAAI;AAE/B,MAAA,CAAC,aAAqB,QAAA;AACtB,MAAA,CAAC,SAAiB,QAAA;AAEhB,QAAA,oBAAoB,aAAa,SAAS,GAAG;AAC7C,QAAA,qBAAqB,SAAS,WAAW,GAAG;AAElD,MAAI,qBAAqB,oBAAoB;AACpC,WAAA,eAAe,SAAS,UAAU,CAAC;EAAA;AAGxC,MAAA,CAAC,qBAAqB,CAAC,oBAAoB;AACtC,WAAA,GAAG,YAAY,IAAI,QAAQ;EAAA;AAGpC,SAAO,eAAe;AACxB;AChEO,SAAS,aACd,gBAA6B,CAAA,GAC7B,gBAA+B,CAAA,GAChB;AAEf,QAAM,eAAe;IACnB,GAAG;IACH,GAAG;EAAA;AAIL,eAAa,UAAU;IACrB,GAAG,cAAc;IACjB,GAAG,cAAc;EAAA;AAInB,eAAa,SAAS;IACpB,GAAG,cAAc;IACjB,GAAG,cAAc;EAAA;AAIf,MAAA,cAAc,QAAQ,cAAc,MAAM;AAC5C,iBAAa,OAAO;MAClB,GAAG,cAAc;MACjB,GAAG,cAAc;IAAA;EACnB;AAGK,SAAA;AACT;AChCO,SAAS,cAAc,MAA8B;AACtDC,UAAAA,yBAAM,IAAI,EAAU,QAAA;AACpB,UAAA,4BAAS,IAAI,EAAU,QAAA;AAEvB,MAAA;AACK,WAAA,KAAK,UAAU,IAAI;EAAA,SACnB,GAAG;AACF,YAAA,MAAM,6BAA6B,CAAC;AACrC,WAAA;EAAA;AAEX;ACZO,SAAS,qBAAqB,IAA8E;AAClH,MAAI,CAAC,MAAM,MAAM,EAAU,QAAA;AAErB,QAAA,aAAa,IAAI,gBAAgB;AAEvC,QAAM,UAAU,IAAI,QAAe,CAAC,GAAG,WAAW;AACjD,eAAW,MAAM;AAChB,iBAAW,MAAM;AACjB,aAAO,IAAI,MAAM,sBAAsB,EAAE,aAAa,CAAC;IAAA,GACrD,EAAE;EAAA,CACL;AAEM,SAAA,EAAE,SAAS,WAAW;AAC9B;ACPO,SAAS,OAAU,UAAkC;AAC1D,SAAO,SAAS;AAClB;AAOO,SAAS,UAAa,UAAuC;AAClE,SAAO,SAAS;AAClB;AAOO,SAAS,WAAc,UAAwC;AACpE,SAAO,SAAS;AAClB;AAQO,SAAS,UACd,UACA,MACS;AACT,SAAO,SAAS,WAAW;AAC7B;AAWO,SAAS,YACd,SACA,QACA,OAAO,eACP,UACA,MACY;AACZ,SAAO,IAAI,WAAW,SAAS,QAAQ,MAAM,QAAW,UAAU,IAAI;AACxE;AC7CO,SAAS,aAAa,OAAqC;AAChE,SAAO,iBAAiB;AAC1B;AAaO,SAAS,aAAa,OAAgB,MAAuB;AAClE,SAAO,aAAa,KAAK,KAAK,MAAM,SAAS;AAC/C;AAKO,IAAM,YAAY;;EAEvB,SAAS;;EAET,UAAU;;EAEV,SAAS;;EAET,cAAc;;EAEd,YAAY;;EAEZ,oBAAoB;;EAEpB,SAAS;AACX;AA0BO,SAAS,iBACd,OACA,UAKG;AACH,MAAI,aAAa,KAAK,KAAK,MAAM,MAAM;AACrC,UAAM,YAAY,MAAM;AAClB,UAAA,UAAU,SAAS,SAAS;AAClC,QAAI,SAAS;AACX,aAAO,QAAQ,KAAK;IAAA;EACtB;AAGF,MAAI,SAAS,SAAS;AACb,WAAA,SAAS,QAAQ,KAAK;EAAA;AAIzB,QAAA;AACR;AAqBO,SAAS,gBACd,OACA,UAIG;AAED,MAAA,aAAa,KAAK,KAClB,MAAM,gBACN,8BAAW,SAAS,MAAM,SAAS,MAAM,CAAC,GAC1C;AACA,WAAO,SAAS,MAAM,SAAS,MAAM,EAAE,KAAK;EAAA;AAG9C,MAAI,SAAS,SAAS;AACb,WAAA,SAAS,QAAQ,KAAK;EAAA;AAIzB,QAAA;AACR;AAqBO,SAAS,gBACd,OACA,MACqB;AACd,SAAA;IACL;IACA,QAAQ,MAAM,UAAU,UAAU;IAClC,YAAY,MAAM,UAAU,cAAc,MAAM;IAChD,SAAS,MAAM,UAAU,WAAW,IAAI,QAAQ;IAChD,QAAQ,MAAM;IACd,SAAS,MAAM;EAAA;AAEnB;ACpJA,SAAS,mBACP,MACA,aACA,SAC4D;AACtD,QAAA,cAAc,EAAE,GAAG,QAAQ;AAGjC,MACE,gBAAgB,YAChB,gBAAgB,mBAChB,gBAAgB,MAChB;AAEA,QACE,gBAAgB,aACf,gBAAgB,MAAM,gBACvB,wBAAA;AACA,YAAM,EAAE,gBAAgB,GAAG,GAAG,iBAAA,IAAqB;AACnD,aAAO,EAAE,MAAM,MAAM,SAAS,iBAAiB;IAAA;AAEjD,WAAO,EAAE,MAAM,MAAM,SAAS,YAAY;EAAA;AAItC,QAAA,iBAAiB,OAAO,WAAW;AAGzC,UAAQ,MAAM;;IAEZ,MAAK,mBAAA,sBACH,eAAe,SAAS,kBAAkB;AACnC,aAAA;QACL,MAAM,cAAc,IAAI;QACxB,SAAS;UAAE,GAAG;UAAa,gBAAiC;;QAAA;MAAA;;IAIhE,MAAK,mBAAA,uCACH,eAAe,SAAS,mCAAmC,IAAG;AAC1D,UAAA;AAEJ,UACE,OAAO,SAAS,YAChB,SAAS,QACT,EAAE,gBAAgB,kBAClB;AACM,cAAA,SAAS,IAAI,gBAAgB;AACnC,mBAAW,CAAC,KAAK,KAAK,KAAK,OAAO;UAChC;QAAA,GACC;AACG,cAAA,UAAU,UAAa,UAAU,MAAM;AACzC,mBAAO,OAAO,KAAK,OAAO,KAAK,CAAC;UAAA;QAClC;AAEK,eAAA;MAAA,WACE,gBAAgB,iBAAiB;AACnC,eAAA;MAAA,OACF;AAEE,eAAA,OAAO,QAAQ,EAAE;MAAA;AAGnB,aAAA;QACL;QACA,SAAS;UAAE,GAAG;UAAa,gBAAiC;;QAAA;MAAA;IAC9D;;IAIF,MAAK,mBAAA,qBACH,eAAe,SAAS,iBAAiB;AAClC,aAAA;QACL,MAAM,OAAO,SAAS,WAAW,OAAO,OAAO,IAAI;QACnD,SAAS;UAAE,GAAG;UAAa,gBAAgC;;QAAA;MAAA;;IAI/D,MAAK,mBAAA,eACH,eAAe,SAAS,WAAW;AAC5B,aAAA;QACL,MAAM,OAAO,SAAS,WAAW,OAAO,OAAO,IAAI;QACnD,SAAS;UAAE,GAAG;UAAa,gBAAiC;;QAAA;MAAA;;IAIhE,MAAK,mBAAA,gBACH,eAAe,SAAS,YAAY;AAC7B,aAAA;QACL,MAAM,OAAO,SAAS,WAAW,OAAO,OAAO,IAAI;QACnD,SAAS;UAAE,GAAG;UAAa,gBAAiC;;QAAA;MAAA;;IAIhE,MAAK,mBAAA,8BACH,eAAe,SAAS,0BAA0B,IAAG;AAC/C,YAAA,OACJ,gBAAgB,QAAQ,gBAAgB,cACpC,OACA,OAAO,SAAS,WAChB,OACA,OAAO,IAAI;AAEV,aAAA;QACL;QACA,SAAS;UAAE,GAAG;UAAa,gBAAiC;;QAAA;MAAA;IAC9D;;IAIF,SAAS;AACD,YAAA,OACJ,OAAO,SAAS,WAAW,cAAc,IAAI,IAAI,OAAO,IAAI;AAEvD,aAAA;QACL;QACA,SAAS,EAAE,GAAG,aAAa,gBAAgB,eAAe;MAAA;IAC5D;EACF;AAEJ;AAKA,eAAe,sBACb,UACA,cACA,mBACA,YAAY,MACM;AAElB,QAAM,wBACJ,iBACC,kBAAkB,SAAS,kBAAkB,KAAK,cAAc,QAAA,SAAA;AAK7D,QAAA,kBACJ,SAAS,WAAW,OAAO,SAAS,QAAQ,IAAI,gBAAgB,MAAM;AAGlE,QAAA,WAAW,OACf,QACA,aACe;AACX,QAAA,CAAC,SAAS,MAAM,KAAK,OAAO,SAAS,MAAM,MAAM,YAAY;AAG/D,UAAI,OAAO,YAAY,eAAe,QAAQ,IAAI,aAAa,QAAQ;AAEjE,YAAA;AACF,cAAI,SAAS,MAAM,KAAK,OAAO,SAAS,MAAM,MAAM,YAAY;AAEvD,mBAAA,MAAO,SAAS,MAAM,EAAuB;UAAA;QACtD,SACO,GAAG;QAAA;MAEZ;AAEK,aAAA;IAAA;AAGL,QAAA;AAEK,aAAA,MAAO,SAAS,MAAM,EAAuB;IAAA,SAC7C,GAAG;AACV,cAAQ,KAAK,mCAAmC,MAAM,KAAK,CAAC;AACrD,aAAA;IAAA;EACT;AAGF,UAAQ,uBAAuB;IAC7B,KAAA;AAEE,UAAI,iBAAiB;AACnB,eAAO,CAAA;MAAC;AAGN,UAAA;AACK,eAAA,MAAM,SAAS,KAAK;MAAA,SACpB,GAAG;AAEH,eAAA,MAAM,SAAS,QAAQ,EAAE;MAAA;IAGpC,KAAA;AACE,UAAI,iBAAiB;AACnB,eAAO,IAAI,KAAK;MAAA;AAElB,aAAO,MAAM,SAAS,QAAQ,IAAI,KAAA,CAAM;IAE1C,KAAA;AACE,UAAI,iBAAiB;AACZ,eAAA,IAAI,YAAY,CAAC;MAAA;AAE1B,aAAO,MAAM,SAAS,eAAe,IAAI,YAAY,CAAC,CAAC;IAEzD,KAAA;AAES,aAAA;IAET;AAEE,UAAI,iBAAiB;AACZ,eAAA;MAAA;AAEF,aAAA,MAAM,SAAS,QAAQ,EAAE;EAAA;AAEtC;AAQO,SAAS,sBACd,eACAC,eACA;AAIA,WAASH,SACP,QACwC;AAExC,QAAI,aAAa;AACb,QAAA,kBAAkB,IAAI,gBAAgB;AAG1C,UAAM,SAAS,MAAM;AACN,mBAAA;AACb,sBAAgB,MAAM;IAAA;AAIxB,QAAI,aAAa;AACjB,QAAI,mBAA6B,CAAA;AAC7B,QAAA,eAA+C,CAAC,UAClD,KAAK,IAAI,MAAO,MAAM,QAAQ,IAAI,GAAK;AAErC,QAAA,OAAO,OAAO,UAAU,UAAU;AACpC,mBAAa,OAAO;IAAA,WACX,OAAO,SAAS,OAAO,OAAO,UAAU,UAAU;AAC3D,mBAAa,OAAO,MAAM;AACP,yBAAA,OAAO,MAAM,eAAe,CAAA;AAE3C,UAAA,OAAO,MAAM,YAAY,UAAU;AACtB,uBAAA,CAAC,UAAU,MAAO;MAAA,WACxB,OAAO,MAAM,YAAY,eAAe;AAClC,uBAAA,CAAC,UAAU,KAAK,IAAI,MAAO,MAAM,QAAQ,IAAI,GAAK;MAAA,WACxD,OAAO,OAAO,MAAM,YAAY,YAAY;AACrD,uBAAe,OAAO,MAAM;MAAA;IAC9B;AAGF,QAAI,aAAa;AACb,QAAA,iBAAiB,OAAO,mBAAmB;AACzC,UAAA,kBAAkB,OAAO,aAAa,cAAc;AAG1D,QAAI,OAAO,QAAQ;AACb,UAAA,OAAO,OAAO,SAAS;AAEZ,qBAAA;AACb,wBAAgB,MAAM;MAAA,OACjB;AAEE,eAAA,OAAO,iBAAiB,SAAS,MAAM;AAC/B,uBAAA;AACb,0BAAgB,MAAM;QAAA,CACvB;MAAA;IACH;AAIF,mBAAe,iBAA+C;AACxD,UAAA;AAEF,YAAI,YAAY;AACd,gBAAM,IAAI,WAAW,wBAAwB,QAAQ,cAAc;QAAA;AAIrE,cAAM,EAAE,QAAQ,GAAG,WAAA,IAAe;AAGlC,cAAM,gBAAgB,MAAMG,cAAa,QAAQ,IAAI,UAAU;AAG/D,cAAM,MAAM,YAAY,cAAc,SAAS,cAAc,GAAG;AAGhE,cAAM,UAAU,kBAAkB,KAAK,cAAc,MAAM;AAGrD,cAAA,gBAAgB,qBAAqB,cAAc,OAAO;AAG5D,YAAA,cAAc,UAAU,CAAC,YAAY;AACnC,cAAA,cAAc,OAAO,SAAS;AACnB,yBAAA;AACb,4BAAgB,MAAM;AAEtB,kBAAM,IAAI;cACR;cACA;cACA;YAAA;UACF;QACF;AAII,cAAA;UACJ,SAAS;UACT,UAAU,CAAA;UACV;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UACA;;UACA;;UACA;QAAA,IACE;AAGJ,cAAM,cAA2B;UAC/B;UACA;UACA,QAAQ,gBAAgB;;UACxB;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;AAIF,YAAI,MAAM;AAGP,sBAAqD,OAAO;QAAA;AAI/D,YAAI,SAAS,QAAW;AAEtB,gBAAM,uBACJ,eACC,QAAmC,cAAc,KAClD;AAGF,cACE,yBAAyB,MACzB,OAAO,SAAS,YAChB,SAAS,QACT,EAAE,gBAAgB,aAClB,EAAE,gBAAgB,oBAClB,EAAE,gBAAgB,OAClB;AAEY,wBAAA,OAAO,cAAc,IAAI;AACrC,wBAAY,UAAU;cACpB,GAAI;cACJ,gBAAA;;YAAA;UACF,OACK;AAEL,kBAAM,EAAE,MAAM,SAAS,iBAAA,IAAqB;cAC1C;cACA;cACA;YAAA;AAGF,wBAAY,OAAO;AACnB,wBAAY,UAAU;UAAA;QACxB;AAIF,YAAI,YAAY;AACd,gBAAM,IAAI,WAAW,wBAAwB,QAAQ,cAAc;QAAA;AAI/D,cAAA,eAAe,MAAM,SAAS,WAAW;AAGzC,cAAA,WAAW,OAAO,gBACpB,QAAQ,KAAK,CAAC,cAAc,cAAc,OAAO,CAAC,IAClD;AAGJ,cAAM,oBAAoB,SAAS,QAAQ,IAAI,cAAc,KAAK;AAGlE,cAAM,eAAe,MAAM;UACzB;UACA;UACA;UACA,cAAc;QAAA;AAIZ,YAAA,CAAC,SAAS,IAAI;AAEhB,gBAAM,aAAa,IAAI;YACrB,SAAS,cAAc,cAAc,SAAS,MAAM;YACpD;YACA;YACA;YACA;YACA;UAAA;AAIF,gBAAM,iBAAiB,MAAMA,cAAa,MAAM,IAAI,UAAU;AAG1D,cAAA,UAAU,kBAAkB,YAAY,gBAAgB;AACnD,mBAAA;UAAA;AAIH,gBAAA;QAAA;AAIR,cAAM,mBAAwC;UAC5C,MAAM;UACN,QAAQ,SAAS;UACjB,YAAY,SAAS;UACrB,SAAS,SAAS;UAClB,QAAQ;UACR,SAAS;QAAA;AAIL,cAAA,oBAAoB,MAAMA,cAAa,SAAS;UACpD;QAAA;AAIF,YAAI,QAAQ;AACN,cAAA;AACF,kBAAM,gBAAgB,OAAO,MAAM,kBAAkB,IAAI;AAGzD,8BAAkB,OAAO;AAElB,mBAAA;UAAA,SACA,iBAAiB;AAEpB,gBAAA,2BAA2B,YAAE,UAAU;AACzC,oBAAMC,cAAa,IAAI;gBACrB;gBACA;gBACA;gBACA;gBACA;gBACA,kBAAkB;cAAA;AAGpBA,0BAAW,OAAO;AAGlB,oBAAMC,kBAAiB,MAAMF,cAAa,MAAM,IAAIC,WAAU;AAG1D,kBAAA,UAAUC,mBAAkB,YAAYA,iBAAgB;AACnDA,uBAAAA;cAAA;AAGHA,oBAAAA;YAAA;AAIR,kBAAM,aAAa,IAAI;cACrB;cACA;cACA;cACA;cACA;cACA,kBAAkB;YAAA;AAIpB,kBAAM,iBAAiB,MAAMF,cAAa,MAAM,IAAI,UAAU;AAG1D,gBAAA,UAAU,kBAAkB,YAAY,gBAAgB;AACnD,qBAAA;YAAA;AAGH,kBAAA;UAAA;QACR;AAIK,eAAA;MAAA,SACA,OAAO;AAEd,YACE,iBAAiB,cACjB,mBACA,OAAO,gBAAgB,YAAY,YACnC;AACA,gBAAM,cAAc,gBAAgB,eAAe,CAAC,GAAG;AACvD,gBAAM,cACJ,MAAM,YAAY,YAAY,SAAS,MAAM,SAAS,MAAM;AAC9D,gBAAM,oBACJ,CAAC,gBAAgB,eACjB,gBAAgB,YAAY,OAAO,MAAM;AAC3C,cAAI,eAAe,mBAAmB;AACpC,6BAAiB,OAAO,mBAAmB;AACvC,gBAAA,kBAAkB,gBAAgB,SAAS,IAAI;AACjD,oBAAM,cAAc,MAAM,gBAAgB,QAAQ,OAAO,MAAM;AAC/D,kBAAI,aAAa;AACf,uBAAOH,SAAW;kBAChB,GAAG;kBACH,iBAAiB,iBAAiB;gBAAA,CACnC;cAAA;YACH;UACF;QACF;AAIF,YAAI,iBAAiB,YAAY;AACzB,gBAAA;QAAA;AAIR,YAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD,gBAAMI,cAAa,IAAI;YACrB,aAAa,yBAAyB;YACtC;YACA,aAAa,iBAAiB;UAAA;AAIhC,gBAAMC,kBAAiB,MAAMF,cAAa,MAAM,IAAIC,WAAU;AAG1D,cAAA,UAAUC,mBAAkB,YAAYA,iBAAgB;AACnDA,mBAAAA;UAAA;AAGHA,gBAAAA;QAAA;AAIJ,YAAA,aAAa,cAAc,CAAC,YAAY;AAE1C,cACE,iBAAiB,cACjB,MAAM,aACL,iBAAiB,WAAW,KAC3B,iBAAiB,SAAS,MAAM,SAAS,MAAM,IACjD;AACA;AAEA,8BAAkB,IAAI,gBAAgB;AAEhC,kBAAA,QAAQ,aAAa,UAAU;AACrC,kBAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,KAAK,CAAC;AACzD,mBAAO,eAAe;UAAA;AAIpB,cAAA,EAAE,iBAAiB,aAAa;AAClC;AAEA,8BAAkB,IAAI,gBAAgB;AAEhC,kBAAA,QAAQ,aAAa,UAAU;AACrC,kBAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,KAAK,CAAC;AACzD,mBAAO,eAAe;UAAA;QACxB;AAKF,cAAM,aAAa,IAAI;UACrB,iBAAiB,QAAQ,MAAM,UAAU;UACzC;UACA;QAAA;AAIF,cAAM,iBAAiB,MAAMF,cAAa,MAAM,IAAI,UAAU;AAG1D,YAAA,UAAU,kBAAkB,YAAY,gBAAgB;AACnD,iBAAA;QAAA;AAGH,cAAA;MAAA;IACR;AAIF,UAAM,iBAAiB,eAAe;AAGhC,UAAA,oBAAoB,OAAO,OAAO,gBAAgB;MACtD;MACA,YAAY,MAAM;IAAA,CACnB;AAEM,WAAA;EAAA;AAGFH,SAAAA;AACT;ACloBO,SAAS,kBACdA,UACA,eACA;AACO,SAAA;IACL,IACE,KACA,SAAsB,CAAA,GACkB;AACjCA,aAAAA;QACL,aAAa,eAAe;UAC1B,GAAG;UACH;UACA,QAAQ;QAAA,CACT;MAAA;IACH;IAGF,KACE,KACA,MACA,SAAsB,CAAA,GACkB;AACjCA,aAAAA;QACL,aAAa,eAAe;UAC1B,GAAG;UACH;UACA,QAAQ;UACR;QAAA,CACD;MAAA;IACH;IAGF,IACE,KACA,MACA,SAAsB,CAAA,GACkB;AACjCA,aAAAA;QACL,aAAa,eAAe;UAC1B,GAAG;UACH;UACA,QAAQ;UACR;QAAA,CACD;MAAA;IACH;IAGF,OACE,KACA,SAAsB,CAAA,GACkB;AACjCA,aAAAA;QACL,aAAa,eAAe;UAC1B,GAAG;UACH;UACA,QAAQ;QAAA,CACT;MAAA;IACH;IAGF,MACE,KACA,MACA,SAAsB,CAAA,GACkB;AACjCA,aAAAA;QACL,aAAa,eAAe;UAC1B,GAAG;UACH;UACA,QAAQ;UACR;QAAA,CACD;MAAA;IACH;IAGF,KACE,KACA,SAAsB,CAAA,GACkB;AACjCA,aAAAA;QACL,aAAa,eAAe;UAC1B,GAAG;UACH;UACA,QAAQ;QAAA,CACT;MAAA;IACH;IAGF,QACE,KACA,SAAsB,CAAA,GACkB;AACjCA,aAAAA;QACL,aAAa,eAAe;UAC1B,GAAG;UACH;UACA,QAAQ;QAAA,CACT;MAAA;IACH;EACF;AAEJ;AC1GO,SAAS,YAAY,gBAA6B,CAAA,GAAmB;AAE1E,QAAM,eAA4B;IAChC,GAAG;EAAA;AAIL,QAAMG,gBAAe,mBAAmB;AAGlCH,QAAAA,WAAU,sBAAsB,cAAcG,aAAY;AAG1D,QAAA,UAAU,kBAAkBH,UAAS,YAAY;AAGvD,QAAM,WAA0B;IAC9B,UAAU;IACV,cAAAG;IACA,SAAAH;IACA,GAAG;EAAA;AAGE,SAAA;AACT;AC7BA,IAAM,kBAAkB,YAAY;AAK7B,IAAM,UAAU,gBAAgB;AAKhC,IAAM,MAAM,gBAAgB;AAK5B,IAAM,OAAO,gBAAgB;AAK7B,IAAM,MAAM,gBAAgB;AAK5B,IAAM,MAAM,gBAAgB;AAK5B,IAAM,QAAQ,gBAAgB;AAK9B,IAAM,OAAO,gBAAgB;AAK7B,IAAM,UAAU,gBAAgB;AAMhC,IAAM,UAAuB,gBAAgB;AAK7C,IAAM,eAAe,gBAAgB;AAK5C,IAAO,gBAAQ;ACSf,IAAM,iBAAiB;EACrB,iBACE;EAEF,oBACE;AAEJ;AAMO,SAAS,oBACd,QACM;AACA,QAAA,iBAAaM,cAAAA,YAAW,OAAO,OAAO;AAC5C,QAAM,aAASA,cAAAA,YAAW,OAAO,GAAG,SAAKC,cAAAA,UAAS,OAAO,GAAG;AAE5D,MAAI,cAAc,QAAQ;AAClB,UAAA,IAAI,MAAM,eAAe,eAAe;EAAA;AAG5C,MAAA,CAAC,cAAc,CAAC,QAAQ;AACpB,UAAA,IAAI,MAAM,eAAe,kBAAkB;EAAA;AAErD;AAEO,SAAS,mBAAgD,MAAY;AAEnE,SAAA,QAAQ,IAAI,EAAE,QAAQ,CAAC,CAAC,KAAK,MAAM,MAAM;AAC1C,QAAA;AACF,0BAAoB,MAAM;IAAA,SACnB,OAAO;AACd,YAAM,IAAI;QACR,4BAA4B,GAAG,MAAO,MAAgB,OAAO;MAAA;IAC/D;EACF,CACD;AAEM,SAAA;AACT;ACgJA,IAAMC,kBAAiB;EACrB,iBACE;EAEF,oBACE;AAEJ;AAKO,SAAS,uBACd,QACM;AACA,QAAA,oBAAgBF,cAAAA,YAAW,OAAO,UAAU;AAC5C,QAAA,eAAe,OAAO,OAAO,OAAO;AAE1C,MAAI,iBAAiB,cAAc;AAC3B,UAAA,IAAI,MAAME,gBAAe,eAAe;EAAA;AAG5C,MAAA,CAAC,iBAAiB,CAAC,cAAc;AAC7B,UAAA,IAAI,MAAMA,gBAAe,kBAAkB;EAAA;AAErD;AAQO,SAAS,sBACd,MACG;AAEI,SAAA,QAAQ,IAAI,EAAE,QAAQ,CAAC,CAAC,KAAK,MAAM,MAAM;AAC1C,QAAA;AACF,6BAAuB,MAAM;IAAA,SACtB,OAAO;AACd,YAAM,IAAI;QACR,+BAA+B,GAAG,MAAO,MAAgB,OAAO;MAAA;IAClE;EACF,CACD;AAEM,SAAA;AACT;ACzSO,SAAS,kBAAkB,KAA0C;AAC1E,aAAO,uBAAQ,GAAG,IAAI,KAAK,UAAU,GAAG,QAAID,cAAAA,UAAS,GAAG,IAAI,MAAM,OAAO,GAAG;AAC9E;AAsCO,IAAM,aAAN,MAAiB;EAMtB,YAAYN,WAA6B,CAAA,GAAI;AAJrC,SAAA,cAAA,oBAAkB,IAAoB;AACtC,SAAA,YAAA,oBAAgB,IAA6B;AAC7C,SAAA,WAAA,oBAAe,IAAyB;AAGxC,UAAA,EAAE,aAAa,IAAA,IAASA;AACzB,SAAA,QAAQ,IAAI,SAAS;MACxB,SAAS;MACT,YAAY,CAAC,KAAa,UAAsB;AAE9C,aAAK,gBAAgB,GAAG;MAAA;IAC1B,CACD;EAAA;;;;EAMK,gBAAgB,MAAoB;AACrC,SAAA,YAAY,OAAO,IAAI;AACvB,SAAA,UAAU,OAAO,IAAI;AAC1B,UAAM,QAAQ,KAAK,SAAS,IAAI,IAAI;AACpC,QAAI,OAAO;AACT,mBAAa,KAAK;AACb,WAAA,SAAS,OAAO,IAAI;IAAA;EAC3B;EAGF,IAAI,KAAkC,OAAmB;AACjD,UAAA,OAAO,kBAAkB,GAAG;AAC7B,SAAA,MAAM,IAAI,MAAM,KAAK;AAC1B,SAAK,gBAAgB,IAAI;EAAA;EAG3B,IAAa,KAA6D;AACxE,UAAM,SAAS,KAAK,MAAM,IAAI,kBAAkB,GAAG,CAAC;AAG7C,WAAA;EAAA;EAGT,IAAI,KAA2C;AAC7C,UAAM,SAAS,KAAK,MAAM,IAAI,kBAAkB,GAAG,CAAC;AAC7C,WAAA;EAAA;EAGT,OAAO,KAAwC;AACvC,UAAA,OAAO,kBAAkB,GAAG;AAC7B,SAAA,MAAM,OAAO,IAAI;AACtB,SAAK,gBAAgB,IAAI;EAAA;EAG3B,QAAc;AACZ,SAAK,MAAM,MAAM;AACjB,SAAK,YAAY,MAAM;AACvB,SAAK,UAAU,MAAM;AAChB,SAAA,SAAS,QAAQ,CAAC,UAAU;AAC/B,mBAAa,KAAK;IAAA,CACnB;AACD,SAAK,SAAS,MAAM;EAAA;EAGtB,SAAqC;AACnC,UAAM,SAAqC,CAAA;AAC3C,eAAW,CAAC,KAAK,KAAK,KAAK,KAAK,MAAM,QAAA,GAAW;AAC/C,aAAO,GAAG,IAAI;IAAA;AAET,WAAA;EAAA;;;;;EAOT,kBACE,KACA,UACY;AACN,UAAA,OAAO,kBAAkB,GAAG;AAClC,QAAI,CAAC,KAAK,UAAU,IAAI,IAAI,GAAG;AAC7B,WAAK,UAAU,IAAI,MAAM,oBAAI,IAAA,CAAK;IAAA;AAEpC,SAAK,UAAU,IAAI,IAAI,EAAG,IAAI,QAAQ;AAEtC,WAAO,MAAM;AACX,YAAM,cAAc,KAAK,UAAU,IAAI,IAAI;AAC3C,UAAI,aAAa;AACf,oBAAY,OAAO,QAAQ;AAEvB,YAAA,YAAY,SAAS,GAAG;AACrB,eAAA,UAAU,OAAO,IAAI;QAAA;MAC5B;IACF;EACF;;;;EAMF,gBAAgB,KAAwC;AAChD,UAAA,OAAO,kBAAkB,GAAG;AAC1B,YAAA,QAAA,EAAU,KAAK,MAAM;AACtB,WAAA,UAAU,IAAI,IAAI,GAAG,QAAQ,CAAC,MAAM,EAAA,CAAG;IAAA,CAC7C;EAAA;;;;EAMH,UAAU,KAAwC;AAC1C,UAAA,OAAO,kBAAkB,GAAG;AAClC,UAAM,OAAO,KAAK,YAAY,IAAI,IAAI,KAAK;AAC3C,SAAK,YAAY,IAAI,MAAM,OAAO,CAAC;AACnC,UAAM,QAAQ,KAAK,SAAS,IAAI,IAAI;AACpC,QAAI,OAAO;AACT,mBAAa,KAAK;AACb,WAAA,SAAS,OAAO,IAAI;IAAA;EAC3B;;;;EAMF,YAAY,KAAkC,QAAsB;AAC5D,UAAA,OAAO,kBAAkB,GAAG;AAClC,UAAM,OAAO,KAAK,YAAY,IAAI,IAAI,KAAK;AAC3C,QAAI,QAAQ,GAAG;AACR,WAAA,YAAY,IAAI,MAAM,CAAC;AACtB,YAAA,QAAQ,WAAW,MAAM;AAC7B,aAAK,OAAO,GAAG;MAAA,GACd,MAAM;AACJ,WAAA,SAAS,IAAI,MAAM,KAAK;IAAA,OACxB;AACL,WAAK,YAAY,IAAI,MAAM,OAAO,CAAC;IAAA;EACrC;EAGF,YAAwC;AACtC,WAAO,KAAK,OAAO;EAAA;EAGrB,YAAY,OAAyC;AAC5C,WAAA,QAAQ,KAAK,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACzC,WAAA,MAAM,IAAI,KAAK,KAAK;IAAA,CAC1B;EAAA;;;;EAMH,IAAI,OAAe;AACjB,WAAO,KAAK,MAAM;EAAA;;;;EAMpB,IAAI,UAAkB;AACpB,WAAO,KAAK,MAAM;EAAA;;;;;;;;;;;;;;;EAiBpB,WAAW;AACF,WAAA;;MAEL,WAAW,KAAK,MAAM;;MAEtB,SAAS,KAAK,MAAM;;MAEpB,kBAAkB,KAAK,YAAY;;MAEnC,gBAAgB,KAAK,UAAU;;MAE/B,qBAAqB,KAAK,SAAS;IAAA;EACrC;AAEJ;AC/NO,IAAM,cAAN,MAAkB;EAIvB,YAAYA,UAA8B;AACxC,SAAK,QAAQ,IAAI,WAAWA,UAAS,UAAU;AAC/C,SAAK,UAAUA,UAAS,WAAW,YAAYA,QAAO;EAAA;EAGxD,IAAI,KAA2C;AACtC,WAAA,KAAK,MAAM,IAAI,GAAG;EAAA;EAG3B,aAAa;AACX,WAAO,KAAK;EAAA;;;;EAMd,IACE,KAC2B;AACpB,WAAA,KAAK,MAAM,IAAO,GAAG;EAAA;;;;EAM9B,IAAI,KAAkC,OAAyB;AACxD,SAAA,MAAM,IAAI,KAAK,KAAK;EAAA;;;;;EAO3B,aACE,KACA,SACM;AACA,UAAA,WAAW,KAAK,IAAO,GAAG;AAEhC,UAAM,UAAU,OAAO,YAAY,aAC9B,QAAsD,UAAU,IAAI,IACrE;AAGJ,UAAM,WAA0B;MAC9B,MAAM;MACN,OAAO,UAAU;MACjB,WAAW,UAAU,aAAa;MAClC,YAAY,UAAU,cAAc;MACpC,WAAW,KAAK,IAAI;IAAA;AAGjB,SAAA,IAAI,KAAK,QAAQ;EAAA;;;;EAMxB,OAAO,KAAwC;AACxC,SAAA,MAAM,OAAO,GAAG;EAAA;;;;EAMvB,SAAqC;AAC5B,WAAA,KAAK,MAAM,OAAO;EAAA;;;;EAM3B,QAAc;AACZ,SAAK,MAAM,MAAM;EAAA;;;;;EAOnB,kBAAkB,QAAqC;AAC/C,UAAA,MAAM,KAAK,OAAO;AACpBQ,YAAAA,uBAAQ,MAAM,GAAG;AACb,YAAA,YAAY,MAAM,KAAK,MAAM;AACnC,iCAAQ,OAAO,KAAK,GAAG,GAAG,CAAC,QAAQ;AAC7B,YAAA;AACI,gBAAA,SAAS,KAAK,MAAM,GAAG;AAC7B,cACE,MAAM,QAAQ,MAAM,SACpB,uBAAQ,OAAO,MAAM,GAAG,UAAU,MAAM,GAAG,SAAS,GACpD;AACA,kBAAM,eAAe,KAAK,MAAM,IAAI,MAAM;AAC1C,gBAAI,cAAc;AACX,mBAAA,MAAM,IAAI,QAAQ,EAAE,GAAG,cAAc,WAAW,EAAA,CAAG;YAAA;UAC1D;QACF,QACM;QAAA;MAER,CACD;IAAA,OACI;AACL,YAAM,gBAAYF,cAAAA,UAAS,MAAM,IAAI,SAAS,OAAO,MAAM;AAC3D,iCAAQ,OAAO,KAAK,GAAG,GAAG,CAAC,QAAQ;AAC7B,YAAA,IAAI,WAAW,SAAS,GAAG;AAC7B,gBAAM,eAAe,KAAK,MAAM,IAAI,GAAG;AACvC,cAAI,cAAc;AACX,iBAAA,MAAM,IAAI,KAAK,EAAE,GAAG,cAAc,WAAW,EAAA,CAAG;UAAA;QACvD;MACF,CACD;IAAA;EACH;;;;EAMF,kBACE,KACA,UACY;AACZ,WAAO,KAAK,MAAM,kBAAkB,KAAK,QAAQ;EAAA;EAEnD,UAAU,KAAwC;AAC3C,SAAA,MAAM,UAAU,GAAG;EAAA;EAE1B,YAAY,KAAkC,QAAsB;AAC7D,SAAA,MAAM,YAAY,KAAK,MAAM;EAAA;;EAgBpC,MAAM,cACJ,YACA,iBACY;AAEZ,QACE,OAAO,eAAe,YACtB,cACA,cAAc,YACd;AACA,YAAM,QAAQ;AACd,YAAM,SAAS;AACT,YAAA,WAAW,MAAM,SAAS,MAAM;AAEtC,YAAMG,WAAU,YAAwB;AAClCC,YAAAA;AAGJ,YAAI,MAAM,SAAS;AACjBA,kBAAO,MAAM,MAAM,QAAQ,QAAQ,KAAK,OAAO;QAAA,WACtC,MAAM,KAAK;AAEd,gBAAA,MAAM,MAAM,IAAI,MAAM;AAC5B,gBAAM,WAAW,MAAM,KAAK,QAAQ,IAAI,KAAK,MAAM,WAAW;AAC9DA,kBAAO,SAAS;QAAA,OACX;AACL,gBAAM,IAAI;YACR;UAAA;QACF;AAIF,YAAI,MAAM,QAAQ;AAChBA,kBAAO,MAAM,OAAO,MAAMA,KAAI;QAAA;AAIhC,YAAI,MAAM,QAAQ;AAChBA,kBAAO,MAAM,OAAOA,KAAI;QAAA;AAGnBA,eAAAA;MAAA;AAGF,aAAA,KAAK,cAAc,UAAUD,QAAO;IAAA;AAI7C,UAAM,MAAM;AACZ,UAAM,UAAU;AAEV,UAAA,OAAO,MAAM,QAAQ;AAC3B,SAAK,IAAI,KAAK;MACZ;MACA,OAAO;MACP,WAAW;MACX,YAAY;MACZ,WAAW,KAAK,IAAI;IAAA,CACrB;AACM,WAAA;EAAA;EAGT,YAAwC;AAC/B,WAAA,KAAK,MAAM,UAAU;EAAA;EAG9B,QAAQ,OAAyC;AAC1C,SAAA,MAAM,YAAY,KAAK;EAAA;;;;;;EAQ9B,gBAAgB;AACd,WAAO,KAAK;EAAA;AAEhB;ACxNA,IAAI,oBAA6C;AAKjD,IAAI,iBAAiE;AAQ9D,SAAS,6BACdT,UACM;AACWA,mBAAAA;AAGb,MAAA,OAAO,WAAW,eAAe,mBAAmB;AAClC,wBAAA;EAAA;AAExB;AAKA,SAAS,2BACPA,UACa;AACT,MAAA,CAACA,UAAS,mBAAmB;AACxB,WAAA,IAAI,YAAYA,QAAO;EAAA;AAGhC,QAAM,EAAE,mBAAmB,GAAG,cAAA,IAAkBA;AAC1C,QAAA,SAAS,IAAI,YAAY,aAAa;AAG1B,oBAAA,OAAO,WAAA,CAAY;AAE9B,SAAA;AACT;AAOO,SAAS,eACdA,UACa;AACb,QAAM,eAAeA,YAAW;AAG5B,MAAA,OAAO,WAAW,aAAa;AACjC,WAAO,2BAA2B,YAAY;EAAA;AAIhD,MAAI,CAAC,mBAAmB;AACtB,wBAAoB,2BAA2B,YAAY;EAAA;AAGtD,SAAA;AACT;AAMO,SAAS,mBAAyB;AACnC,MAAA,OAAO,WAAW,aAAa;AACb,wBAAA;EAAA;AAExB;AAqBO,SAAS,kCACdA,UACA,mBACa;AACb,SAAO,2BAA2B;IAChC,GAAGA;IACH;EAAA,CACD;AACH;ACvGO,SAAS,iBAAoB,MAAS,MAAY;AAEvD,MAAI,SAAS,MAAM;AACV,WAAA;EAAA;AAILW,UAAAA,uBAAQ,MAAM,IAAI,GAAG;AAChB,WAAA;EAAA;AAIL,MAAA,QAAQ,QAAQ,QAAQ,MAAM;AACzB,WAAA;EAAA;AAIT,UAAIH,uBAAQ,IAAI,SAAKA,uBAAQ,IAAI,GAAG;AAC9B,QAAA,KAAK,WAAW,KAAK,QAAQ;AACxB,aAAA;IAAA;AAGT,QAAI,aAAa;AACjB,UAAM,SAAS,KAAK,IAAI,CAAC,MAAM,UAAU;AACvC,YAAM,WAAW,iBAAiB,MAAM,KAAK,KAAK,CAAC;AACnD,UAAI,aAAa,MAAM;AACR,qBAAA;MAAA;AAER,aAAA;IAAA,CACR;AAED,WAAO,aAAc,SAAe;EAAA;AAItC,UAAIA,uBAAQ,IAAI,UAAMA,uBAAQ,IAAI,GAAG;AAC5B,WAAA;EAAA;AAIT,UAAI,6BAAc,IAAI,SAAK,6BAAc,IAAI,GAAG;AAC9C,UAAM,UAAU;AAChB,UAAM,UAAU;AACV,UAAA,eAAW,oBAAK,OAAO;AACvB,UAAA,eAAW,oBAAK,OAAO;AAGzB,QAAA,SAAS,WAAW,SAAS,QAAQ;AAChC,aAAA;IAAA;AAGT,QAAI,aAAa;AACjB,UAAM,SAAkC,CAAA;AAExC,eAAW,OAAO,UAAU;AAEtB,UAAA,EAAE,OAAO,UAAU;AACd,eAAA;MAAA;AAGH,YAAA,YAAY,QAAQ,GAAG;AACvB,YAAA,YAAY,QAAQ,GAAG;AACvB,YAAA,iBAAiB,iBAAiB,WAAW,SAAS;AAE5D,UAAI,mBAAmB,WAAW;AACnB,qBAAA;MAAA;AAEf,aAAO,GAAG,IAAI;IAAA;AAGhB,WAAO,aAAc,SAAe;EAAA;AAI/B,SAAA;AACT;AC5FO,IAAM,gBAAN,MAA8C;EAKnD,YAAY,QAAmC;AAJvC,SAAA,eAAA,oBAAmB,IAAqC;AAEhE,SAAQ,cAAgD;AAGtD,SAAK,SAAS;EAAA;EAGhB,cAAyC;AAEvC,QAAI,KAAK,aAAa;AACpB,aAAO,KAAK;IAAA;AAGd,SAAK,cAAc,IAAI,MAAM,KAAK,QAAQ;MACxC,KAAK,CAAC,QAAQ,SAAS;AAErB,YAAI,OAAO,SAAS,YAAY,QAAQ,QAAQ;AACzC,eAAA,aAAa,IAAI,IAAuC;QAAA;AAE/D,eAAO,OAAO,IAAuC;MAAA;IACvD,CACD;AAED,WAAO,KAAK;EAAA;EAGd,kBAAwD;AACtD,WAAO,KAAK;EAAA;EAGd,eAAe,MAAgD;AACtD,WAAA,KAAK,aAAa,IAAI,IAAI;EAAA;EAGnC,YAAuC;AACrC,WAAO,KAAK;EAAA;;EAId,aAAa,WAA4C;AACvD,SAAK,SAAS;AACd,SAAK,cAAc;EAAA;AAEvB;ACpCO,IAAM,eAAN,MAAgC;EAIrC,YACE,aACA,oBACA;AACA,SAAK,cAAc;AACnB,SAAK,qBAAqB;EAAA;;;;;EAO5B,MAAM,aACJ,UACAR,UACA,YACe;AACf,UAAM,EAAE,UAAU,MAAM,YAAY,EAAA,IAAMA;AAE1C,QAAI,CAAC,QAAS;AAEd,UAAM,SAAS,KAAK,YAAY,IAAO,QAAQ;AAC/C,UAAM,UAAU,SAAS,KAAK,IAAA,IAAQ,OAAO,aAAa,YAAY;AAElE,QAAA,CAAC,UAAU,SAAS;AACtB,YAAM,KAAK,UAAU,UAAUA,UAAS,UAAU;IAAA;EACpD;;;;;EAOF,MAAM,UACJ,UACAA,UACA,YACe;AACX,QAAA;AAEF,YAAM,eAAe,KAAK,YAAY,IAAO,QAAQ;AAGjD,UAAA,gBAAgB,CAAC,aAAa,YAAY;AACvC,aAAA,YAAY,IAAI,UAAU;UAC7B,GAAG;UACH,YAAY;QAAA,CACb;MAAA;AAIH,YAAM,SAAS,MAAM,KAAK,mBAAmBA,QAAO;AAGpD,WAAK,mBAAmB,sBAAsB;AAEzC,WAAA,YAAY,IAAI,UAAU;QAC7B,MAAM;QACN,OAAO;QACP,WAAW;QACX,YAAY;QACZ,WAAW,KAAK,IAAI;MAAA,CACrB;AAGY,mBAAA;IAAA,SACN,OAAY;AAEnB,WAAK,mBAAmB,sBAAsB;AAEzC,WAAA,YAAY,IAAI,UAAU;QAC7B,MAAM;QACN;QACA,WAAW;QACX,YAAY;QACZ,WAAW,KAAK,IAAI;MAAA,CACrB;AAGY,mBAAA;IAAA;EACf;;;;;EAOF,MAAc,mBACZA,UACY;AACN,UAAA,UAAU,KAAK,YAAY,WAAW;AAGxC,QAAA,aAAaA,YAAWA,SAAQ,SAAS;AACpC,aAAA,KAAK,eAAeA,UAAS,OAAO;IAAA;AAIzC,QAAA,SAASA,YAAWA,SAAQ,KAAK;AAC5B,aAAA,KAAK,kBAAkBA,UAAS,OAAO;IAAA;AAIhD,UAAM,IAAI;MACR;IAAA;EACF;;;;;EAOF,MAAc,eACZA,UACA,SACY;AACZ,UAAM,UAAWA,SAAgB;AAC7B,QAAA;AAGJ,QAAI,YAAYA,YAAWA,SAAQ,WAAW,QAAW;AACvD,eAAS,MAAM,QAAQA,SAAQ,QAAQ,OAAO;IAAA,OACzC;AAEI,eAAA,MAAM,QAAQ,OAAO;IAAA;AAGhC,WAAO,KAAK,sBAAsB,QAAQA,SAAQ,MAAM;EAAA;;;;EAM1D,MAAc,kBACZA,UACA,SACY;AACZ,UAAM,MAAOA,SAAgB;AACvB,UAAA,SAAS,KAAK,iBAAiBA,QAAO;AAC5C,UAAM,WAAW,MAAM,QAAQ,IAAI,KAAK,MAAM;AAE9C,WAAO,KAAK,sBAAsB,SAAS,MAAMA,SAAQ,MAAM;EAAA;;;;EAMzD,iBAAoBA,UAA+C;AACzE,QAAI,aAAsB,qBAAM,CAAA,GAAIA,SAAQ,eAAe,CAAA,CAAE;AAEzD,YAAA,2BAASA,SAAQ,MAAM,GAAG;AAC5B,mBAAS,qBAAM,QAAQ,EAAE,QAAQA,SAAQ,OAAA,CAAQ;IAAA;AAE/C,YAAA,2BAASA,SAAQ,MAAM,GAAG;AAC5B,mBAAS,qBAAM,QAAQ,EAAE,QAAQA,SAAQ,OAAA,CAAQ;IAAA;AAG5C,WAAA;EAAA;;;;EAMD,sBAAyB,MAAW,QAAiB;AAC3D,QAAI,QAAQ;AACH,aAAA,OAAO,MAAM,IAAI;IAAA;AAEnB,WAAA;EAAA;;;;;EAOT,MAAM,QACJ,UACAA,UACA,YACe;AACf,UAAM,KAAK,UAAU,UAAUA,UAAS,UAAU;EAAA;;;;;EAOpD,WAAc,UAA2B;AACvC,UAAM,SAAS,KAAK,YAAY,IAAO,QAAQ;AAC/C,WAAO,QAAQ,cAAc;EAAA;;;;;EAO/B,QAAW,UAAkB,YAAoB,GAAY;AAC3D,UAAM,SAAS,KAAK,YAAY,IAAO,QAAQ;AAC/C,WAAO,SAAS,KAAK,IAAA,IAAQ,OAAO,aAAa,YAAY;EAAA;AAEjE;AC/LO,IAAM,iBAAN,MAA+C;EAIpD,YACE,aACA,oBACA;AACA,SAAK,cAAc;AACnB,SAAK,qBAAqB;EAAA;;;;;EAO5B,kBAAqBA,UAA0C;AAEvD,UAAA,sBAAkB,oBAAKA,UAAS;MACpC;MACA;MACA;MACA;MACA;MACA;;IAAA,CAED;AACM,WAAA,KAAK,UAAU,eAAe;EAAA;;;;EAMvC,mBAAmB,UAAkB,SAA0B;AAC7D,WAAO,aAAa;EAAA;;;;EAMtB,aAAa,SAAiB,QAAyB;AACrD,WAAO,YAAY;EAAA;;;;EAMrB,kBACEA,UACA,WACM;AACA,UAAA,aAAa,UAAU,aAAa;AAC1C,QAAI,YAAY;AACd,gBAAU,wBAAwB;IAAA;EACpC;;;;EAMF,oBACEA,UACA,SAC2C;AACrC,UAAA,WAAW,kBAAkBA,SAAQ,GAAG;AACvC,WAAA,EAAE,UAAU,aAAa,QAAQ;EAAA;;;;EAM1C,gBACE,aACA,aACA,WACM;AAEN,SAAK,2BAA2B,WAAW;AAG3C,SAAK,mBAAmB,sBAAsB;AAG9C,cAAU,iBAAiB;AAG3B,QAAI,KAAK,YAAY,IAAI,WAAW,GAAG;AACrC,gBAAU,0BAA0B;IAAA,OAC/B;AACL,gBAAU,mBAAmB;IAAA;EAC/B;;;;EAMF,oBAAuB,WAA+C;AAE9D,UAAA,aAAa,UAAU,aAAa;AAC1C,cAAU,aAAa;AAEvB,QAAI,YAAY;AACd,gBAAU,wBAAwB;IAAA;EACpC;;;;EAMM,2BACN,aACM;AACN,SAAK,YAAY,YAAY,YAAY,KAAK,YAAY,UAAU,GAAM;EAAA;;;;EAM5E,qBAA2B;AACzB,SAAK,mBAAmB,sBAAsB;EAAA;;;;EAMhD,0BACE,UACAA,UACA,WAKkD;AAE5C,UAAA,gBAAgB,UAAU,cAAc;AAC9C,UAAM,sBAAsB;AAG5B,UAAM,SAAS,KAAK,YAAY,IAAO,QAAQ;AACzC,UAAA,UAAU,SACZ,KAAK,IAAA,IAAQ,OAAO,cAAcA,SAAQ,aAAa,KACvD;AACE,UAAA,cAAc,WAAWA,SAAQ,YAAY;AAEnD,QAAI,eAAe,QAAQ;AAEpB,WAAA,YAAY,IAAI,UAAU;QAC7B,GAAG;QACH,YAAY;MAAA,CACb;AAGK,YAAA,gBAAgB,UAAU,cAAc;AAC9C,gBAAU,aAAa;AACvB,gBAAU,wBAAwB;AAE3B,aAAA;QACL,eAAe;QACf,qBAAqB;MAAA;IACvB;AAIF,cAAU,aAAa;AAGvB,cAAU,wBAAwB;AAE3B,WAAA,EAAE,eAAe,oBAAoB;EAAA;;;;EAM9C,mBAAsB,WAA+C;AAE7D,UAAA,aAAa,UAAU,aAAa;AAC1C,cAAU,aAAa;AAEvB,QAAI,YAAY;AACd,gBAAU,wBAAwB;IAAA;EACpC;AAEJ;AC7LO,IAAM,qBAAN,MAAsC;EAI3C,YAAY,aAA0B;AAFtC,SAAQ,mBAA4C;AAGlD,SAAK,cAAc;EAAA;;;;;EAOrB,uBAA0BA,UAAuC;AACzD,UAAA,EAAE,gBAAA,IAAoBA;AAExB,QAAA,CAAC,gBAAwB,QAAA;AAGzB,QAAA,KAACK,iBAAAA,YAAW,eAAe,GAAG;AACzB,aAAA;IAAA;AAIH,UAAA,YAAY,KAAK,kBAAkBL,QAAO;AAEhD,QAAI,CAAC,aAAa,UAAU,SAAS,OAAkB,QAAA;AAEhD,WAAA,gBAAgB,UAAU,MAAM,SAAS;EAAA;;;;;EAO1C,kBACNA,UAC2B;AACrB,UAAA,aAAa,KAAK,YAAY,OAAO;AAC3C,UAAM,aAAaA,SAAQ;AAEvB,QAAA;AACJ,QAAI,iBAAiB;AAErB,eAAW,CAAC,QAAQ,KAAK,KAAK,OAAO,QAAQ,UAAU,GAAG;AACpD,UAAA;AACI,cAAA,WAAW,KAAK,MAAM,MAAM;AAElC,YAAI,KAAK,qBAAqB,UAAU,YAAY,OAAOA,QAAO,GAAG;AAC7D,gBAAA,YAAa,MAAwB,aAAa;AAExD,cAAI,KAAK,aAAa,WAAW,cAAc,GAAG;AAC9B,8BAAA;AACD,6BAAA;UAAA;QACnB;MACF,QACM;MAAA;IAER;AAGK,WAAA;EAAA;;;;EAMD,qBACN,UACA,YACA,OACAA,UACS;AACT,WACE,KAAK,WAAW,UAAUA,QAAO,KACjC,KAAK,gBAAgB,UAAU,UAAU,KACzC,KAAK,oBAAoB,UAAU,UAAU,KAC7C,KAAK,aAAa,KAAK;EAAA;;;;EAOnB,WACN,UACAA,UACS;AACT,WAAO,MAAM,QAAQ,QAAQ,KAAK,MAAM,QAAQA,SAAQ,GAAG;EAAA;;;;EAMrD,gBACN,UACA,YACS;AACT,WAAO,SAAS,CAAC,MAAM,WAAW,CAAC;EAAA;;;;EAM7B,oBACN,UACA,YACS;AACF,WAAA,KAACW,uBAAQ,UAAU,UAAU;EAAA;;;;EAM9B,aAAgB,OAAqB;AAC3C,WAAO,SAAS,KAACV,cAAAA,OAAO,MAAwB,IAAI;EAAA;;;;EAM9C,aAAa,WAAmB,gBAAiC;AACvE,WAAO,YAAY;EAAA;;;;EAMrB,wBAAwB,iBAA+B;AAC9C,WAAA,KAACA,cAAAA,OAAM,eAAe;EAAA;;;;EAM/B,oBAAoB,OAAsC;AACxD,SAAK,mBAAmB;EAAA;;;;EAM1B,sBAA+C;AAC7C,WAAO,KAAK;EAAA;;;;EAMd,wBAA8B;AAC5B,SAAK,mBAAmB;EAAA;AAE5B;AC/JO,IAAM,iBAAN,MAA+C;EAIpD,YACE,aACA,oBACA;AACA,SAAK,cAAc;AACnB,SAAK,qBAAqB;EAAA;;;;;EAO5B,cACE,UACAD,UACA,WAC2B;AACrB,UAAA,EAAE,UAAU,KAAA,IAASA;AAC3B,UAAM,SAAS,KAAK,YAAY,IAAO,QAAQ;AAG/C,QAAI,CAAC,SAAS;AACZ,aAAO,KAAK,qBAAqB,QAAQA,UAAS,SAAS;IAAA;AAIzD,QAAA,KAAK,cAAc,MAAM,GAAG;AAC9B,aAAO,KAAK,mBAAmB,QAASA,UAAS,SAAS;IAAA;AAI5D,UAAM,kBACJ,KAAK,mBAAmB,uBAAuBA,QAAO;AACxD,QAAI,KAAK,mBAAmB,wBAAwB,eAAe,GAAG;AACpE,aAAO,KAAK,wBAAwB,iBAAkBA,UAAS,SAAS;IAAA;AAInE,WAAA,KAAK,2BAA2B,SAAS;EAAA;;;;EAM1C,qBACN,QACAA,UACA,WAC2B;AAE3B,QAAI,QAAQ;AACV,YAAM,YAAY,KAAK,YAAY,OAAO,MAAMA,QAAO;AACvD,YAAM,UAAU,KAAK,iBAAiB,OAAO,WAAWA,QAAO;AAExD,aAAA;QACL,MAAM;QACN,OAAO,OAAO;QACd,WAAW;;QACX,YAAY;;QACZ,SAAS,CAAC,CAAC,OAAO;QAClB,WAAW,KAAK,eAAe,MAAM;QACrC;QACA,mBAAmB;QACnB,SAAS;MAAA;IACX;AAIF,SAAK,mBAAmB,sBAAsB;AAEvC,WAAA;MACL,MAAM;MACN,OAAO;MACP,WAAW;;MACX,YAAY;;MACZ,SAAS;MACT,WAAW;MACX,SAAS;MACT,mBAAmB;MACnB,SAAS;IAAA;EACX;;;;EAMM,cAAc,QAA4C;AAChE,WAAO,CAAC,CAAC;EAAA;;;;EAMH,mBACN,QACAA,UACA,WAC2B;AAC3B,UAAM,YAAY,KAAK,YAAY,OAAO,MAAMA,QAAO;AACvD,UAAM,UAAU,KAAK,iBAAiB,OAAO,WAAWA,QAAO;AAExD,WAAA;MACL,MAAM;MACN,OAAO,OAAO;MACd,WAAW,OAAO;MAClB,YAAY,OAAO;;MACnB,SAAS,CAAC,CAAC,OAAO;MAClB,WAAW,KAAK,eAAe,MAAM;MACrC;MACA,mBAAmB;;MACnB,SAAS;IAAA;EACX;;;;EAMM,wBACN,iBACAA,UACA,WAC2B;AAE3B,SAAK,mBAAmB,oBAAoB;MAC1C,MAAM;MACN,UAAU;IAAA,CACX;AAED,UAAM,YAAY,KAAK,YAAY,iBAAsBA,QAAO;AAEzD,WAAA;MACL,MAAM;MACN,OAAO;MACP,WAAW;;MACX,YAAY;;MACZ,SAAS;MACT,WAAW;MACX,SAAS;MACT,mBAAmB;MACnB,SAAS;IAAA;EACX;;;;EAMM,2BACN,WAC2B;AAC3B,SAAK,mBAAmB,sBAAsB;AAEvC,WAAA;MACL,MAAM;MACN,OAAO;MACP,WAAW;MACX,YAAY;MACZ,SAAS;MACT,WAAW;MACX,SAAS;MACT,mBAAmB;MACnB,SAAS;IAAA;EACX;;;;EAMM,eAAe,QAAgC;AAC9C,WAAA,CAAC,OAAO,aAAa,CAAC,OAAO,SAAS,KAACC,cAAAA,OAAM,OAAO,IAAI;EAAA;;;;EAMzD,YACN,MACAD,UACe;AACf,YAAIC,cAAAA,OAAM,IAAI,KAAK,CAACD,SAAQ,OAAe,QAAA;AAEvC,QAAA;AACKA,aAAAA,SAAQ,OAAO,IAAS;IAAA,QACzB;AACC,aAAA;IAAA;EACT;;;;EAMM,iBACN,WACAA,UACS;AACT,WAAO,YACH,KAAK,IAAA,IAAQ,cAAcA,SAAQ,aAAa,KAChD;EAAA;AAER;ACvMO,IAAM,gBAAN,MAA8C;EA2BnD,YAAY,aAA0BA,UAAkC;AAxBhE,SAAA,YAAA,oBAAgB,IAAgB;AAExC,SAAQ,cAAc;AAEtB,SAAQ,cAAsB;AAG9B,SAAQ,sBAAwD;AAGhE,SAAQ,gBAA4C;AAelD,SAAK,cAAc;AACnB,SAAK,UAAUA;AACV,SAAA,WAAW,kBAAkBA,SAAQ,GAAG;AACxC,SAAA,qBAAqB,IAAI,mBAAsB,WAAW;AAC/D,SAAK,iBAAiB,IAAI;MACxB;MACA,KAAK;IAAA;AAEP,SAAK,eAAe,IAAI,aAAa,aAAa,KAAK,kBAAkB;AACzE,SAAK,iBAAiB,IAAI;MACxB;MACA,KAAK;IAAA;AAEP,SAAK,cAAc,KAAK,eAAe,kBAAkBA,QAAO;AAG3D,SAAA,gBAAgB,KAAK,cAAc;AAGxC,SAAK,iBAAiB;AAGtB,SAAK,aAAa;EAAA;EAGZ,mBAAyB;AAC/B,SAAK,YAAY,kBAAkB,KAAK,QAAQ,KAAK,MAAM;AACrD,UAAA,CAAC,KAAK,aAAa;AACf,cAAA,aAAa,KAAK,aAAa;AACrC,YAAI,YAAY;AACd,eAAK,wBAAwB;QAAA;AAI/B,aAAK,4BAA4B;MAAA;IACnC,CACD;AAED,SAAK,YAAY,UAAU,KAAK,QAAQ,GAAG;EAAA;;;;;EAOrC,8BAAoC;AAC1C,UAAM,EAAE,UAAU,KAAK,IAAI,KAAK;AAEhC,QAAI,CAAC,QAAS;AAEd,UAAM,SAAS,KAAK,YAAY,IAAO,KAAK,QAAQ;AAChD,QAAA,UAAU,OAAO,cAAc,GAAG;AAGpC,UAAI,CAAC,OAAO,cAAc,CAAC,OAAO,WAAW;AAC3C,aAAK,UAAU;MAAA;IACjB;EACF;;;;;EAOM,gBAA2C;AACjD,WAAO,KAAK,eAAe;MAAc,KAAK;MAAU,KAAK;MAAS,MACpE,KAAK,QAAQ;IAAA;EACf;;;;;EAOM,eAAwB;AACxB,UAAA,YAAY,KAAK,cAAc;AAG/B,UAAA,kBAAkB,KAAK,uBAAuB,SAAS;AAGzD,QAAA,KAAK,wBAAwB,eAAe,GAAG;AACjD,WAAK,gBAAgB;AACrB,WAAK,sBAAsB;AACpB,aAAA;IAAA;AAGF,WAAA;EAAA;;;;EAMD,uBACN,WAC2B;AACvB,QAAA,CAAC,KAAK,qBAAqB;AACtB,aAAA;IAAA;AAGF,WAAA,iBAAiB,KAAK,qBAAqB,SAAS;EAAA;EAGrD,wBACN,WACS;AAEL,QAAA,KAAK,eAAA,GAAkB;AAClB,aAAA;IAAA;AAGH,UAAA,eAAe,KAAK,cAAe,gBAAgB;AAGrD,QAAA,KAAK,uBAAuB,YAAY,GAAG;AACtC,aAAA;IAAA;AAIF,WAAA,KAAK,0BAA0B,cAAc,SAAS;EAAA;EAGvD,iBAA0B;AAChC,WAAO,CAAC,KAAK,uBAAuB,CAAC,KAAK;EAAA;EAGpC,uBACN,cACS;AACT,eAAOY,uBAAQ,YAAY;EAAA;EAGrB,0BACN,cACA,WACS;AACT,eAAW,QAAQ,cAAc;AAC/B,UAAI,KAAK,oBAAqB,IAAI,MAAM,UAAU,IAAI,GAAG;AAChD,eAAA;MAAA;IACT;AAEK,WAAA;EAAA;EAGT,MAAc,eAA8B;AAC1C,UAAM,KAAK,aAAa,aAAa,KAAK,UAAU,KAAK,OAAO;EAAA;EAGlE,MAAc,YAA2B;AACvC,UAAM,KAAK,aAAa,UAAU,KAAK,UAAU,KAAK,SAAS,MAAM;AAE7D,YAAA,aAAa,KAAK,aAAa;AACrC,UAAI,YAAY;AACd,aAAK,wBAAwB;MAAA;IAC/B,CACD;EAAA;EAGK,kBAAwB;AAC9B,SAAK,UAAU,QAAQ,CAAC,aAAa,SAAA,CAAU;EAAA;;;;EAMjD,UAAU,UAAkC;AACrC,SAAA,UAAU,IAAI,QAAQ;AAC3B,WAAO,MAAM;AACN,WAAA,UAAU,OAAO,QAAQ;IAAA;EAChC;;;;;EAOF,mBAA8C;AAExC,QAAA,CAAC,KAAK,eAAe;AACvB,WAAK,gBAAgB,IAAI,cAAc,KAAK,aAAa;IAAA,WAChD,KAAK,cAAc,UAAU,MAAM,KAAK,eAAe;AAE3D,WAAA,cAAc,aAAa,KAAK,aAAa;IAAA;AAG7C,WAAA,KAAK,cAAc,YAAY;EAAA;;;;EAMxC,UAAgB;AACd,SAAK,aAAa,QAAQ,KAAK,UAAU,KAAK,SAAS,MAAM;AAErD,YAAA,aAAa,KAAK,aAAa;AACrC,UAAI,YAAY;AACd,aAAK,wBAAwB;MAAA;IAC/B,CACD;EAAA;;;;EAMH,WAAWZ,UAAwC;AACjD,UAAM,UAAU,KAAK;AACrB,UAAM,WAAW,KAAK;AACtB,UAAM,UAAU,KAAK,eAAe,kBAAkBA,QAAO;AAG7D,QAAI,KAAK,eAAe,mBAAmB,UAAU,OAAO,GAAG;AAC7D,WAAK,UAAUA;AACf,WAAK,eAAe,kBAAkBA,UAAS,KAAK,gBAAA,CAAiB;AACrE;IAAA;AAGF,UAAM,cAAc,KAAK;AACzB,UAAM,EAAE,UAAU,YAAY,IAAI,KAAK,eAAe;MACpDA;MACA;IAAA;AAEF,SAAK,UAAUA;AACf,SAAK,WAAW;AAChB,SAAK,cAAc;AAGnB,QAAI,KAAK,eAAe,aAAa,SAAS,KAAK,QAAQ,GAAG;AAC5D,WAAK,gBAAgB;AACrB,WAAK,eAAe;QAClB;QACA,KAAK;QACL,KAAK,gBAAgB;MAAA;IACvB,OACK;AACL,WAAK,eAAe,oBAAoB,KAAK,gBAAA,CAAiB;IAAA;EAChE;EAGM,kBAAgD;AAC/C,WAAA;MACL,cAAc,MAAM,KAAK,aAAa;MACtC,yBAAyB,MAAM,KAAK,wBAAwB;MAC5D,cAAc,MAAM,KAAK,aAAa;MACtC,kBAAkB,MAAM,KAAK,iBAAiB;MAC9C,eAAe,MAAM,KAAK,cAAc;MACxC,2BAA2B,MAAM,KAAK,0BAA0B;MAChE,oBAAoB,MAAM,KAAK,mBAAmB;IAAA;EACpD;EAGM,4BAAkC;AAEnC,SAAA,gBAAgB,KAAK,cAAc;AACxC,SAAK,sBAAsB,KAAK;AAGhC,UAAM,SAAS,KAAK,YAAY,IAAO,KAAK,QAAQ;AAC9C,UAAA,UAAU,SACZ,KAAK,IAAI,IAAI,OAAO,cAAc,KAAK,QAAQ,aAAa,KAC5D;AACJ,UAAM,cAAc,WAAW,KAAK,QAAQ,YAAY;AAExD,QAAI,eAAe,QAAQ;AAEpB,WAAA,YAAY,IAAI,KAAK,UAAU;QAClC,GAAG;QACH,YAAY;MAAA,CACb;AAGI,WAAA,gBAAgB,KAAK,cAAc;AACxC,WAAK,sBAAsB,KAAK;IAAA;AAIlC,SAAK,aAAa;AAGlB,SAAK,wBAAwB;EAAA;EAGvB,qBAA2B;AAE3B,UAAA,aAAa,KAAK,aAAa;AACrC,SAAK,aAAa;AAElB,QAAI,YAAY;AACd,WAAK,wBAAwB;IAAA;EAC/B;EAGM,0BAAgC;AAC9B,YAAA,QAAA,EAAU,KAAK,MAAM;AACvB,UAAA,CAAC,KAAK,aAAa;AACrB,aAAK,gBAAgB;MAAA;IACvB,CACD;EAAA;;;;EAMH,UAAgB;AACd,SAAK,cAAc;AACnB,SAAK,YAAY;MACf,KAAK,QAAQ;MACb,KAAK,QAAQ,UAAU;IAAA;AAEzB,SAAK,UAAU,MAAM;AACrB,SAAK,mBAAmB,sBAAsB;AAC9C,SAAK,sBAAsB;AAC3B,SAAK,gBAAgB;EAAA;AAEzB;ACnUA,eAAsB,YACpB,SACA,oBAAyC,CAAA,GACzC,QAC8B;AAExB,QAAA,cAAc,UAAU,eAAe;AAEvC,QAAA,UAAU,MAAM,QAAQ;IAC5B,QAAQ,IAAI,OAAO,cAAc;AAC3B,UAAA;AAEI,cAAA,CAAC,OAAO,MAAM,IAAI;AAGxB,cAAM,cAAc;UAClB,GAAG;UACH,iBAAaa,qBAAM,CAAA,GAAI,mBAAmB,MAAM,eAAe,CAAA,CAAE;QAAA;AAI7D,cAAA,YAAY,cAAc,aAAa,MAAM;MAAA,SAC5C,OAAO;AACN,gBAAA,MAAM,2CAA2C,KAAK;MAAA;IAEhE,CACD;EAAA;AAIH,QAAM,WAAW,QAAQ;IACvB,CAAC,WAA4C,OAAO,WAAW;EAAA;AAG7D,MAAA,SAAS,SAAS,GAAG;AACvB,YAAQ,KAAK,iBAAiB,SAAS,MAAM,6BAA6B;EAAA;AAI5E,SAAO,YAAY,UAAU;AAC/B;","names":["options","ContentType","ResponseType","request","options","isNil","interceptors","fetchError","processedError","isFunction","isString","ERROR_MESSAGES","isArray","fetchFn","data","isEqual","isEmpty","merge"]}